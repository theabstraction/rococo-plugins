<html>
	<head>
		<title>SEXML 1.0 Specification</title>
		<style>
			body {
				background-color: lightyellow;
				margin-left: 128px;
			}
			h1 {
				color: blue;
				text-align: center;
			}
			p {
				font-size: 18px;
				color: gray;
				max-width: 920
			}
			img {
				margin-top: 20px;
				margin-bottom: 80px;
			}
			#attribute_coldesc
			{
				padding-right: 10px;
				border: 1px solid black;
			}
			#attribute_type
			{
				padding-right: 20px;
				background-color: white;
				border: 1px solid black;
			}
			#attribute_format
			{
				padding-right: 20px;
				background-color: lightgray;
				border: 1px solid black;
			}
			#attribute_comment
			{
				padding-right: 20px;
				background-color: white;
				border: 1px solid black;
			}
			#attribute_table
			{
				border: 1px solid black;
				border-collapse: collapse;
				background-color: lightgreen;
			}
			#attribute_row
			{
				border: 1px solid black;
			}
		</style>
	</head>
  <body>
	<h1>Rococo SEXML 1.0 Specification</h1>
	<div>
		<h2>Introduction</h2>
	</div>
	<div>
		<p>SEXML is an abbreviation for S-Expression Mark-Up Language. It is similar to XML, 
		but easier on the eyes, a more effecient way of storing information, and is easier and faster to parse. 
		<p>The language is a specialization of <a href="s.html">Rococo S-Expressions</a> One should familiarize oneself with
		the specification to make sense of this document</p>		
		</p>
	</div>
	<div>
		<h2>Directives</h2>
	</div>
	<div>
		<p>	
		<p>	
		A directive is a compound S-Expression that is recursively defined as a sequence of attributes followed by the subdirective indicator (the colon character ':')  and then subdirectives. As you
		may have guessed each subdirective is... a directive. In the case that there are no subdirectives then it is permissible to omit the subdirective indicator.
		Any directive that is not the descandant of another directive is known as top-level directive. In a SEXML file, the top-level directives form the children of the root S-Expression directive.
		</p>
		<p> The first token of a directive is a dotted namespace name, each subspace and must start with a capital letter A-Z. Following the capital are any number of alphanumeric characters
		A-Z, a-z and 0-9. Names do not have to be unique, so you can have more than one directive with the same name. This convention for subspaces is known as Pascal
		case. We can define a <i>Pascal Namespace</i> as a sequence of Pascal case subspaces separated by single period characters (.). All subspaces must have at least 
		one character and the namespace must not have a leading period nor a trailing period. There must be at least one subspace, i.e empty namespaces are prohibited.
		</p><pre><code>
		/* Example: a SEXML file describing a couple of carts with four attributes:
			Weight, Length, Width and Depth, 
		   with the first cart having three subdirectives Apple, Pear, Banana
		   and the second card being empty
		*/
		(AntiSophocles.Cart
			(Weight 50kgs)
			(Length 1m)
			(Width 2m)
			(Depth 0.5m)
			:
			(Item.Apple 
				(Pips 4)
			)
			(Item.Pear
			)
			(Item.Banana
			)
		)
		(AntiSophocles.Cart
			(Weight 30kgs)
			(Length 1m)
			(Width 2m)
			(Depth 0.5m)
		)
		</code></pre><p>
	</div>
	<div>
		<h2>Attributes</h2>
	</div>
	<div>
		<p>	
		An attribute is a compound S-Expression that contains at least one unique attribute name, defined by an atomic expression. The name follows the same rules
		as for directives, a <i>Pascal Namespace</i>. Each attribute must be uniquely named within the parent directive.
		</p>
	</div>
	<div>
		<h3>Existential Attributes</h3>
	</div>
	<div>
		<p>	
		An attribute that is merely one atomic expression, a name, is deemed an <i>existential attribute</i>. It marks a directive of having a property - in mathematical logic, it is what we call a <i>predicate</i>. Absence
		of the attribute is deemed to mark the directive as being void of the property. Thus they can be interpreted as boolean properties.
		</p>
		</p><pre><code>
		/* Example: a SEXML file describing a public employee. All of the attributes are existential:
		*/
		(CivilServant.V1
			(Fistname John)
			(Surname Doe)
			(Invisible)
			(Useless)
			(Costly)
			(Smirking)
			// (Responsible)
		)
		</code></pre><p>
	</div>
	<div>
		<h3>Name-Value Pair Attributes</h3>
	</div>
	<div>
		<p>	
		An attribute that consists of two expressions is a name-value pair. The first giving the attribute name
		and the second the attribute value. The format is (<code>[name] [value]</code>). The value expression can be an 
		atomic expression or a string literal. String literals are required when values contain blank-space
		</p>
		</p><pre><code>
		/* Example: a SEXML file describing a public employee. All of the attributes are name-value pairs:
		*/
		(CivilServant.V2
			(Fistname John)
			(Surname "Doe Hargreaves")
			(Invisible 90%)
			(Useless true)
			(Costly true)
			(Smirking always)
			(Responsible never)
		)
		</code></pre><p>
	</div>
	<div>
		<h3>Type-Name-Value Attributes</h3>
	</div>
	<div>
		<p>	
		An attribute which has its first token a # character is typed. The type is determined by the whole of the first token, the name is the second token,
		and the number and type of successive tokens is dependent on the type.
		</p>
		<p>
		For typed values, parsers are expected to interpret integers, where expected, as 32-bit signed values. 
		Integers are either decimal or hexadecimal. In the latter case they are prefixed with the 0x characters. If no such prefix is found the expectation is 
		that the sequences are decimals. Floating point numbers are expected to be converted to 64-bit IEEE 754 numbers by any SEXML parser. Parsers may raise an error state
		in the event that arguments cannot be converted to these numeric types. The suffix of an integer expression will be skipped by numeric conversion, allowing physical units and other markings
		such as the percentage sign to trail the values.
		</p>
		<p>
		The format is (<code>[type] [name] ...</code>).
		</p>
		</p><pre><code>
		(Box
			// Define a box with span 10x5x2 units, #Vec3 is a type with 3 integer elements, X, Y and Z
			(#Vec3i span 10 5 2)
			
			// Define a ratio vector, with X and Y giving the ratio of padding to some containing object
			(#Vec2i padding 35% 25%)
		)
		</code></pre><p>
	</div>
	<div>
		<h3>Typed Attributes</h3>
	</div>
	<div>
		<table id="attribute_table">
			<tr>
				<td id="attribute_coldesc">Type</td>
				<td id="attribute_coldesc">Format</td>
				<td id="attribute_coldesc">Comment</td>
			</tr>
			<tr id="attribute_row">
				<td id="attribute_type">#Vec2</td>
				<td id="attribute_format">(#Vec2 [name] [X] [Y])</td>
				<td id="attribute_comment">X and Y are floating point numbers</td>
			</tr>
			<tr id="attribute_row">
				<td id="attribute_type">#Vec3</td>
				<td id="attribute_format">(#Vec3 [name] [X] [Y] [Z])</td>
				<td id="attribute_comment">X, Y and Z are floating point numbers</td>
			</tr>
			<tr id="attribute_row">
				<td id="attribute_type">#Vec4</td>
				<td id="attribute_format">(#Vec4 [name] [X] [Y] [Z] [W])</td>
				<td id="attribute_comment">X, Y, Z and W are floating point numbers</td>
			</tr>
			<tr id="attribute_row">
				<td id="attribute_type">#Quat</td>
				<td id="attribute_format">(#Quat [name] [Vx] [Vy] [Vz] [S])</td>
				<td id="attribute_comment">Vx, Vy, Vz and S are floating point numbers</td>
			</tr>
			<tr id="attribute_row">
				<td id="attribute_type">#Vec2i</td>
				<td id="attribute_format">(#Vec2i [name] [X] [Y])</td>
				<td id="attribute_comment">X and Y are 32-bit signed integers. Decimal or hexadecimal</td>
			</tr>
			<tr id="attribute_row">
				<td id="attribute_type">#Recti</td>
				<td id="attribute_format">(#Recti [name] [Left] [Top] [Right] [Bottom])</td>
				<td id="attribute_comment">Left, Top, Right and Bottom are 32-bit signed integers. Decimal or hexadecimal</td>
			</tr>
			<tr id="attribute_row">
				<td id="attribute_type">#List</td>
				<td id="attribute_format">(#List [name] ...)</td>
				<td id="attribute_comment">The value is a sequence of expressions, each of which can be atomic or string literals</td>
			</tr>
		</table>
	</div>
	<div>
		<h3>Array Attributes</h3>
	</div>
	<div>
		<p>	
		An attribute which has its first token [] is typed as an array of items. It is synonymous with using #List. Each element can be either an atomic 
		or string literal.
		</p>
		<pre><code>
		([] KnownItems 1 2 7 13 "Hello World" Casper!) // An attribute 'KnownItems' with 6 elements.
		</code></pre>
	</div>
		<h3>Raw Attributes</h3>
	</div>
	<div>
		<p>	
		An attribute which has its first token as a single quote is typed as a raw attribute. The format is (' [name] [-value-])
		where [name] is the dotted namespace name of the attribute, and value is any legal S-expression. Designers of SEXML should generally
		avoid using raw attributes, and instead represent complex data with other attributes and subdirectives. The main motivation for raw 
		attributes is to permit embedding S-Expression scripting code within a document. The converse is also true, SEXML may be embedded in
		any S-Expression scripting code that permits raw expressions. LISP programmers often say some such as 'With S-Expressions code-is-data and data-is-code.'
		</p>
		<pre><code>
		// Example:
		// An attribute 'OnClick' with a value of an S-Expression of 3 elements.
		(' OnClick ( (Int32 i = 1) (RegisterFriend i "John Paul" "Smith") (i += 1) )
		</code></pre>
	</div>
  </body>
 </html>