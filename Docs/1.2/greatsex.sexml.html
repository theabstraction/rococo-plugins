<html>
	<head>
		<title>GreatSex 1.0 Specification</title>
		<style>
			body {
				background-color: lightyellow;
				margin-left: 128px;
			}
			h1 {
				color: blue;
				text-align: center;
			}
			p {
				font-size: 18px;
				color: gray;
				max-width: 920
			}
			img {
				margin-top: 20px;
				margin-bottom: 80px;
			}
			#colour_coldesc
			{
				padding-right: 10px;
				border: 1px solid black;
			}
			#colour_name
			{
				padding-right: 20px;
				background-color: white;
				border: 1px solid black;
			}
			#colour_surface
			{
				padding-right: 20px;
				background-color: lightgray;
				border: 1px solid black;
			}
			#colour_comment
			{
				padding-right: 20px;
				background-color: white;
				border: 1px solid black;
			}
			#colour_table
			{
				border: 1px solid black;
				border-collapse: collapse;
				background-color: lightgreen;
			}
			#colour_row
			{
				border: 1px solid black;
			}
			#panel_coldesc
			{
				padding-right: 10px;
				border: 1px solid black;
			}
			#panel_name
			{
				width: 22%;
				background-color: white;
				border: 1px solid black;
			}
			#panel_comment
			{
				padding-right: 20px;
				background-color: white;
				border: 1px solid black;
			}
			#panel_table
			{
				border: 1px solid black;
				border-collapse: collapse;
				background-color: lightgreen;
			}
			#panel_row
			{
				border: 1px solid black;
			}
		</style>
	</head>
  <body>
	<h1>GreatSex SEXML 1.0 Specification</h1>
	<div>
		<h2>Introduction</h2>
	</div>
	<div>
		<p>
		GreatSex is the SEXML file-format for specifying the widget layout in the Rococo GUI system. Familiarity with the <a href="sexml.html">SEXML specification</a> is required. Widgets exist in a tree, with a root widget that has no parent. The root is always a
		Frame widget. Frame widgets have two sub-widgets, a toolbar, which is usually collapsed, but can be used to create a regular OS style UI toolbar for fullscreen mode, and a client-area where children widgets are placed. In GreatSex SEXML, top-level Widget directives
		append new children to the frame's client-area. The client-area matches the area of the frame less the area of the toolbar. So without a toolbar, the default for GreatSEX SEXML, client-area spans the entire frame.
		</p>		
		
		<p>
		Every widget has a number of colours used in its rendering (see the Colour Table at the bottom of this document), and if they are not explicitly defined, then the rendering algorithm will search ancestors for a definition, so this means you can set such
		colours in a parent widget, and have all the children use the scheme. If no widget explicitly defines a particular colour, then the rendering algorithm will look at the frame's scheme, which is set with the top-level <b>Scheme</b> directives. The particular scheme
		that will be that which matches the control state of the UI. The control state consists of 3 flags - <i>Hovered, Focused and Pressed</i>. <i>Hovered</i> means the UI cursor is within the bounds of the widget, while <i>Focused</i> means the keyboard sends
		default input to the widget and <i>Pressed</i> means the the widget is in some pressed state, such as with a button.
		</p>
	</div>
	<div>
		<h2>Top Level Directives</h2>
	</div>
	<div>
		<ul id="directive_list">
			<li id="directive_item">
				<h3>Insert</h3>	- analagous to a #include directive in C and C++.
				<ul id="attribute_types">
					<li id="attribute_type">
						<h4>Name-Value Attributes</h4>
						<ul id="attribute_list">
							<li id="attribute_item">
								<p>
								<b>Path</b> - the string argument gives the ping path to another SEXML script, 
									the expression tree of such is inserted into the SEXML expression
									tree at the corresponding point of definition of the Insert statement.
								</p>
								<p>
									<pre><code>Example: (Path "!tests/greatsex.scheme.sexml")</code></pre>
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li id="directive_item">
				<h3>Zoom</h3> - there may be a number of competing zoom directives. The directive which defines the highest minimum resolution defines GUI zoom levels			
				<ul id="attribute_types">
					<li id="attribute_type">
						<h4>Name-Value Attributes</h4>
						<ul id="attribute_list">
							<li id="attribute_item">
								<p>
								<b>MinWidth</b> - integer argument that defines the minimum horizontal pixel resolution for the zoom directive to apply.
								</p>
							</li>
							<li id="attribute_item">
								<p>
								<b>MinHeight</b> - integer argument that defines the minimum vertical pixel resolution for the zoom directive to apply.
								</p>
							</li>
						</ul>
					</li>
					<li id="attribute_type">
						<h4>Type-Name-Value Attributes</h4>
						<ul id="attribute_list">
							<li id="attribute_item">
								<p>
								<b>#List Levels ...</b> - with a floating point list that gives legal zoom scales. Range is 1.0 to 100.0. Values must increase left to right.
								</p>
								<p>
									<pre><code>Example: ([] Levels 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 2.1 2.2 2.3 2.4 2.5)</code></pre>
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li id="directive_item">
				<h3>Scheme</h3>	- defines a colour scheme that applies for a set of user-input states on a hierarchy of GUI widget panels		
				<ul id="attribute_types">
					<li id="attribute_type">
						<h4>Optional Subdirectives</h4>
						<ul id="attribute_list">
							<li id="attribute_item">
								<p>
								<b>ApplyTo</b> 
								</p>
								<ul>
									<li id="attribute_type">
										<h4>Type-Name-Value Attributes</h4>
										<ul id="attribute_list">
											<li id="attribute_item">
												<p>
												<b>#List RenderStates ...</b> - combination of boolean flags represented by strings 'pressed', 'focused', 'hovered'. If none apply use 'default'
												The combination determine whether the scheme applies for a given focus and cursor state.
												</p>
												<p>
													<pre><code>Example: (ApplyTo ([] RenderStates pressed focused))</code></pre>
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li id="attribute_item">
								<p>
								<b>{colour-name}</b> - where {colour-name} is any of the text items in the AttributeName coloum of the colour table below in this HTML
								</p>
								<ul>
									<li id="attribute_type">
										<h4>Name-Value Attributes</h4>
										<ul id="attribute_list">
											<li id="attribute_item">
												<p>
													<b>Red</b> - integer between 0 and 255, giving the red intensity of the colour
												</p>
											</li>
											<li id="attribute_item">
												<p>
													<b>Green</b> - integer between 0 and 255, giving the green intensity of the colour
												</p>
											</li>
											<li id="attribute_item">
												<p>
													<b>Blue</b> - integer between 0 and 255, giving the blue intensity of the colour
												</p>
											</li>
											<li id="attribute_item">
												<p>
													<b>Alpha</b> - integer between 0 and 255, giving the alpha intensity of the colour
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li id="directive_item">
				<h3>Colour</h3>	- defines a colour, keyed by its Id mandatory attribute
				<ul id="attribute_types">
					<li id="attribute_type">
						<h4>Attributes</h4>
						<ul id="attribute_list">
							<li id="attribute_item">
								<p>
								<b>Id [name]</b> - <i>mandatory attribute</i> - the string argument gives the unique name of the colour. Some widget directives can take such a name as a string attribute to determine which colours apply
								</p>
							</li>
							<li id="attribute_item">
								<p>
									<b>#List Unform.RGBA [red] [green] [blue] [alpha]</b> - <i>optional attribute</i> - arguments are 4 integers ranging 0-255, red, green, blue and alpha that apply for all GUI states. Note that if present, then subdirective <b>Spec</b> is superfluous													
								</p>
							</li>
						</ul>
					</li>
					<li id="attribute_type">
					<h4>Optional Subdirectives</h4>
						<ul id="attribute_list">
							<li id="attribute_item">
								<p>
								<b>Spec</b> - defines what colour applies and under what circumstances
								</p>
								<ul>
									<li id="attribute_type">
										<h4>Mandatory Name-Value Attributes</h4>
										<ul id="attribute_list">
											<li id="attribute_item">
												<p>
													<b>Red</b> - integer between 0 and 255, giving the red intensity of the colour
												</p>
											</li>
											<li id="attribute_item">
												<p>
													<b>Green</b> - integer between 0 and 255, giving the green intensity of the colour
												</p>
											</li>
											<li id="attribute_item">
												<p>
													<b>Blue</b> - integer between 0 and 255, giving the blue intensity of the colour
												</p>
											</li>
											<li id="attribute_item">
												<p>
													<b>Alpha</b> - integer between 0 and 255, giving the alpha intensity of the colour
												</p>
											</li>
										</ul>
									</li>
									<li id="attribute_type">
										<h4>Mandatory Type-Name-Value Attributes</h4>
										<ul id="attribute_list">
											<li id="attribute_item">
												<p>
													<b>#List For ...</b> - combination of boolean flags 'pressed', 'focused' and 'hovered' with 'default' meaning no flags													
												</p>
												<p>
													<pre><code>([] For pressed focused))</code></pre>
												</p>
											</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li id="directive_item">
				<h3>Font</h3>	- defines a font, keyed by its Id mandatory attribute
				<ul id="attribute_types">
					<li id="attribute_type">
						<h4>Mandatory Attributes</h4>
						<ul id="attribute_list">
							<li id="attribute_item">
								<p>
								<b>Id [name]</b>  - the string argument gives the unique name of the font. Some widget directives can take such a name as a string attribute to determine which font applies
								</p>
							</li>
							<li id="attribute_item">
								<p>
									<b>Family [family-name]</b> - the argument is a string that identifies the font-family.													
								</p>
							</li>
						</ul>
					</li>
					<li id="attribute_type">
						<h4>Optional Attributes</h4>
						<ul id="attribute_list">
							<li id="attribute_item">
								<p>
									<b>#List Mods ...</b> - list of boolean flags 'Bold' and 'Italic'.													
								</p>
								<p>
									<pre><code>Example: ([] Mods Bold Italic))</code></pre>
								</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li id="directive_item">
				<h3>Frame</h3>	- The frame element navigates up the owner branch until the frame is found and then sets the attributes specified in the sexml
				<ul id="attribute_types">
					<li id="attribute_type">
						<h4>Attributes and Subdirectives</h4>	
						- frames are Widgets, and have the all the base widget attributes and subdirectives. If no Frame element is included in the SEXML then a frame for the GUI still exists, but its attributes are not overriden by the SEXML.
					</li>
				</ul>
			</li>
			<li id="directive_item">
				<h3>Frame.ClientArea</h3> - The frame-client-area element navigates up the owner branch until the frame is found and then sets the attributes of the ClientArea specified in the sexml
				<ul id="attribute_types">
					<li id="attribute_type">
						<h4>Attributes and Subdirectives</h4>	
						- a frame's client area is a Division Widget, and has the all the attributes and subdirectives of such. If no client-area element is included in the SEXML then the client area for the GUI Frame still exists, but its attributes are not overriden by the SEXML.
					</li>
				</ul>
			</li>
		</ul>
	</div>	
	
	<div>
		<h2>Widget Directives</h2>
		<p> Widgets serve as parent containers to child widgets, and thus all widget directives are allowed an arbitrary number of widget directives in their subdirective list, with each such defining a child widget.</p>
		<p> Any widget may have any widget type as a child, the exception is the frame widget, which hosts the widget-tree. The frame widget's client area, may have children, but no widget may have a frame as a child. Frames are root widgets only.</p>
		<p> All widgets also have an arbirary list of panel and colour attributes. Panel attribute names begin with the subspace 'Panel'. Colour attribute names begin with the subspace 'Colour'. </p>
		<p> Colour attributes are all name-value pairs with the second argument being the colour id. The id must match the id of top-level-directive (Colour ...) defined in the SEXML or at an insert point.</p>
		<p> A list of all legal 'Colour' names is in the table at the bottom of this HTML document </p>
	</div>
	<div>
		<h2>Widget Factories</h2>
		<p>A widget directive other than Frame or Frame.ClientArea creates widgets. In addition to the panels and colours every widget can specify, every widget factory has its own custom set of attributes and subdirective types, so, for example, a Slider
		widget will have attributes and subdirectives that control the mapping between the slider and the underlying property bound to the slider. Here follows a comprehensive set of widget factories and their custom attributes and subdirectives.</p>
		
		<ul>
			<li>
				<h3>Button</h3>
					- Construct a ButtonWidget
				<ul>
					<li>
						<h3>Attributes</h3>
						<ul>
							<li>
								<p>Text [text]</p>
								<p> - Prevents image rendering if the [text] string is not blank and specifies that the button renders the text instead</p>
							</li>
							<li>
								<p>Meta [text]</p>
								<p> - Sets the button's metadata string to [text]</p>
							</li>
							<li>
								<p>FitTextH</p>
								<p> - Existential attribute that tells a button to shrink horizontally to fit its text string</p>
							</li>
							<li>
								<p>FitTextV</p>
								<p> - Existential attribute that tells a button to shrink vertically to fit its text string</p>
							</li>
							<li>
								<p>#Vec2i Text.Spacing [dx] [dy]</p>
								<p> - Defines the spacing between the button text and its bounding rectangle. Behaviour depends on text alignment.</p>
							</li>
							<li>
								<p>Text.Alignment [alignment]</p>
								<p> - Defines the text alignment. Must be one of Left|Right|Top|Bottom|TopLeft|TopRight|BottomLeft|BottomRight|Centre]</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<h3>Div</h3>
					- Construct a DivisionWidget, the <i>tabula rasa</i> of widgets, they exist to layout children and display a backround and little else. They have no unique attributes.
			</li>
			<li>
				<h3>Label</h3>
					- Create a TextWidget. They display a text string. Generally they are not expected to have children.
				<ul>
					<li>
						<h3>Attributes</h3>
						<ul>
							<li>
								<p>Text [text]</p>
								<p> - Specifies the [text] to render. It is centred horizontally and vertically.</p>
							</li>
							<li>
								<p>Font [id]</p>
								<p> - Specifies the [id] of the font to render. The font must have been defined by a top-level Font directive</p>
							</li>
							<li>
								<p>FitH [boolValue]</p>
								<p> - Specifies whether to shrink the widget to fit the text horizontally</p>
							</li>
							<li>
								<p>FitV [boolValue]</p>
								<p> -  Specifies whether to shrink the widget to fit the text vertically</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<h3>Portrait</h3>
				<p> - Typically defined as the first and only child of the Frame's child area, draws a background portrait that preserve's the texture's aspect ratio.
				
				<ul>
					<li>
						<h3>Attributes</h3>
						<ul>
							<li>
								<p>Image [pingPath]</p>
								<p> - Specifies the [pingPath] of the image to render. It is centred horizontally and vertically and anything outside the render area is drawn using the Colour.Portrait.Band for the panel</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<h3>HintBox</h3>
				<p> - Creates a box that receives notification when the keyboard focus changes to render a string from the focus widget panel's hint property</p>
				
				<ul>
					<li>
						<h3>Attributes</h3>
						<ul>
							<li>
								<p>#Vec2i Text.Spacing [dx] [dy]</p>
								<p> - Defines the spacing between the hint text and its bounding rectangle. Behaviour depends on text alignment.</p>
							</li>
							<li>
								<p>Text.Alignment [alignment]</p>
								<p> - Defines the text alignment. Must be one of Left|Right|Top|Bottom|TopLeft|TopRight|BottomLeft|BottomRight|Centre]</p>
							</li>
							<li>
								<p>Test.Font [id]</p>
								<p> - Defines the id of the font, which must have been defined in a top-level Font directive.</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<h3>GradientFill</h3>
				<ul>
					<li>
						<h3>Attributes</h3>
						<ul>
							<li>
								<p>TopLeft [colourId]</p>
								<p> - Defines the top left colour of the gradient zone. The colour must have been defined in a top-level Colour directive</p>
							</li>
							<li>
								<p>TopRight [colourId]</p>
								<p> - Defines the top right colour of the gradient zone. The colour must have been defined in a top-level Colour directive</p>
							</li>
							<li>
								<p>BottomLeft [colourId]</p>
								<p> - Defines the bottom left colour of the gradient zone. The colour must have been defined in a top-level Colour directive</p>
							</li>
							<li>
								<p>BottomRight [colourId]</p>
								<p> - Defines the bottom right colour of the gradient zone. The colour must have been defined in a top-level Colour directive</p>
							</li>
							<li>
								<p>Fill [fillType]</p>
								<p> - Defines the gradient fill type. Must be one of Banner|Smooth|Solid|Default. 
								<ul>
									<li>
										<b>Default|Solid</b> fill uses the top left colour for the entire fill.
									</li>
									<li>
										<b>Banner</b> creates a horizontally symmetrical fill.
									</li>
									<li>
										<b>Smooth</b> renders two triangles, split from top left to bottom right, using all four colour definitions.
									</li>
								</ul>
							</li>
							<li>
								<p>FitV FirstChild</p>
								<p> - Shrinks the gradient fill to match the height of the first child</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<h3>RadioButtons</h3>
				- defines a group of buttons in which activation of any one button deactivates the other. Keyboard and gamepad navigation between buttons is automatically handled.
				<ul>
					<li>
						<h3>Attributes</h3>
						<ul>
							<li>
								<p>#List Group ...</p>
								<p> - Specifies a list of button panel descriptions that identify which buttons are part of the radio collection. See Panel.Description</p>
							</li>
							<li>
								<p>Navigate [direction]</p>
								<p> - Specifies whether up-down or left-right gui events change the radio focus. [direction] must be one of H|V|Horizontal|Vertical.<br>H|Horizontal => left-right, V|Vertical => up-down</p>
							</li>
							<li>
								<p>Default [description]</p>
								<p> - Specifies the button by description that is considered the default button</p>
							</li>
						</ul>
					</li>
					<li>
						<h3>Subdirectives</h3>
						<ul>
							<li>
								<p>Tab</p>
								- specifies that a radio button toggles a widget panel's collapsed state, so that only one tab is visible at a time
								<h3>Attributes</h3>
								<ul>
									<li>
										<p>For [meta]</p>
										<p> - Specifies the Meta string of the radio-button that controls toggling of the target widget</p>
									</li>
									<li>
										<p>Toggles [description]</p>
										<p> - Specifies the Panel.Description of the target widget panel, the collapse state of which is to be toggled by the associated button</p>
									</li>
								</ul>	
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<h3>VerticalList</h3>
				- defines a top-down layout widget. Tab events automatically advance through the children. If the end of the children is reached tab returns focus to the top child if Panel.TabsCycle is defined. This widget factory has no unique
				attributes or subdirectives.
			</li>
			<li>
				<h3>Viewport</h3>
				- defines a vertically scrolling region and renders a vertical scroll bar if needs be.
				<ul>
					<li>
						<h3>Attributes</h3>
						<ul>
							<li>
								<p>Viewport.RectStyle.Scrollable [style]</p>
								<p> - Specifies the viewport panel rectangle style when a scroller in visible. [style] can be one of SHARP|ROUNDED|BLUR</p>
							</li>
							<li>
								<p>Viewport.Rectstyle.NotScrollable [style]</p>
								<p> - Specifies the viewport panel rectangle style when a scroller in hidden. [style] can be one of SHARP|ROUNDED|BLUR</p>
							</li>
							<li>
								<p>Viewport.SyncDomainToChildren</p>
								<p> - An existential attribute, when present sets the scroller domain height to the sum of the heights of the client area children.</p>
							</li>
						</ul>
						<h3>Subdirectives</h3>
						<ul>
							<li>
								<p>Viewport.ClientArea</p>
								<p> - Provides configuration for the viewport's client area panel attributes. It has no unique attributes nor subdirectives.</p>
							</li>
						</ul>
						<ul>
							<li>
								<p>Viewport.Offset</p>
								<p> - Provides configuration for the viewport's offset area panel attributes. It has no unique attributes nor subdirectives..</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<h3>ControlPrompt</h3>
				 - defines a widget that displays control prompts, either for Keyboard or an XBOX controller. The device responsible for input just before a render cycle determines which icon set is used.
				 <ul>
					<li>
						<h3>Attributes</h3>
						<ul>
							<li>
								<p>Font [id]</p>
								<p> - Specifies the font by id for rendering text prompts. The id must match a font that has been defined by a top-level Font directive.</p>
							</li>
							<li>
								<p>AlignRight</p>
								<p> - An existential attribute: if present, aligns the control prompts on the right hand side of the widget panel.</p>
							</li>
						</ul>
						<h3>Subdirectives</h3>
						<ul>
							<li>
								<p>DefIcon</p>
								<p> - defines an icon for a particular device and control</p>
								<h3>Attributes</h3>
								<ul>
									<li>
										<p>Icon [iconId]</p>
										<p> - gives a unique name to the icon. For use in the Prompt subdirective (see below)</p>
									</li>
									<li>
										<p>For [controlType]</p>
										<p> - One of Keyboard|XBOX. For keyboard, a mouse or keyboard event will activate this icon. For XBOX, then XBOX game controllers will activate the icon.</p>
									</li>
									<li>
										<p>Path [pingPath]</p>
										<p> - Ping path to the image file for the icon</p>
									</li>
									<li>
										<p>VPadding [vPadding]</p>
										<p> - vertical padding above and below image</p>
									</li>
								</ul>
							</li>
							<li>
								<p>Prompt</p>
								<p> - specifies which icon to use and the associated text. The order of prompt directives determines the order of icons in the control prompt</p>
								<h3>Attributes</h3>
								<ul>
									<li>
										<p>Icon [iconId]</p>
										<p> - gives a unique name to the icon. Must match one of the icon ids defined in the DefIcon's Icon subdirective (see above)</p>
									</li>
									<li>
										<p>Text [text]</p>
										<p> - gives a text message to display to the left of the icon</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<h3>Toolbar</h3>
				<p>- creates a widget with a layout optimized for displaying button image controls.</p> 
				<p>- experimental: there is a hidden toolbar in the root frame widget that is normally invisible for most GUI applications. While the toobar widget has been proven to work, 
					its usefulness in the context of a SEXML specified context is questionable - a division widget may be more flexible and serve much the same purpose.				
				</p>
				<ul>
					<li>
						<h3>Attributes</h3>
						<ul>
							<li>
								<p>Content.Padding.Cell [padding]</p>
								<p> - [padding] integer specifies the space between child widgets</p>
							</li>
							<li>
								<p>Content.Padding.Border [padding]</p>
								<p> - [padding] integer specifies the space between the border of the toolbar and the contentss</p>
							</li>
							<li>
								<p>ChildrenContent.Alignment [alignment]</p>
								<p> - where [alignment] is one of top|right|bottom|hcentre|vcentre</p>
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<h3>GameOptions</h3>
				 - This is the most complex of the widget directives and has its own <a href="game-options.html">Game Options Web Page.</a>
			</li>
		</ul>
	</div>
	<div>
		<h2>Panel Attributes</h2>
		
		<table id="panel_table">
			<tr>
				<td id="panel_coldesc"><b>Attribute Format</b></td>
				<td id="panel_coldesc"><b>Definition and Commentary</b></td>
			</tr>
			<tr>
				<td id="panel_name">#Vec2i Panel.Offset [dx] [dy]</td>
				<td id="panel_comment">The delta offset [dx,dy] from the parent's top left position to the panel's top left position</td>
			</tr>
			<tr>
				<td id="panel_name">#Vec2i Panel.Span [dx] [dy]</td>
				<td id="panel_comment">The constant span [dx,dy] of the widget panel</td>
			</tr>
			<tr>
				<td id="panel_name">Panel.FixedWidth [width]</td>
				<td id="panel_comment">[width] is an integer. If it ends with a % sign, specifies with as the fraction of the parent's x-span, otherwise specifies widget co-ordinate x-span</td>
			</tr>
			<tr>
				<td id="panel_name">Panel.FixedHeight [height]</td>
				<td id="panel_comment">[height] is an integer. If it ends with a % sign, specifies with as the fraction of the parent's y-span, otherwise specifies widget co-ordinate y-span</td>
			</tr>
			<tr>
				<td id="panel_name">Panel.Description [text]</td>
				<td id="panel_comment">At a minimum provides a debugging string for the widget, but also gives a key for navigation and other logic to identify a purpose for the widget</td>
			</tr>
			<tr>
				<td id="panel_name">Panel.TabsCycle [boolValue]</td>
				<td id="panel_comment">Pass true for [boolValue] to mark a panel to cycle tabs endlessly</td>
			</tr>
			<tr>
				<td id="panel_name">#Reci Panel.Padding [left] [top] [right] [bottom]</td>
				<td id="panel_comment">Set's the panel's padding on all four of its bounds. If any end with % symbol, the value specifies the faction of the parent's span across the appropriate axis. See ExpandH and ExpandV.</td>
			</tr>
			<tr>
				<td id="panel_name">Panel.Layout [layout]</td>
				<td id="panel_comment">Where layout is one of LeftToRight|RightToLeft|TopToBottom|BottomToTop|None. This determines the direction across which child widgets are laid out. 'None' is used when children geometries are micromanaged elsewhere </td>
			</tr>
			<tr>
				<td id="panel_name">Panel.ExpandH</td>
				<td id="panel_comment">An existential attribute that specifies that a widget to expand horizontally to match its parent geometry, and then shrink according to the Padding for the panel. See Panel.Padding</td>
			</tr>
			<tr>
				<td id="panel_name">Panel.ExpandV</td>
				<td id="panel_comment">An existential attribute that specifies that a widget to expand vertically to match its parent geometry, and then shrink according to the Padding for the panel. See Panel.Padding.</td>
			</tr>
			<tr>
				<td id="panel_name">#Recti Panel.ChildPadding [top] [left] [right] [bottom]</td>
				<td id="panel_comment">Behaviour dependendent on the layout algorithm - but specifies gaps between children when laid out by their parent</td>
			</tr>
			<tr>
				<td id="panel_name">#List Panel.Fit ... </td>
				<td id="panel_comment">Arguments can be any of H|Horizontal|V|Vertical. Prescence of H|Horizontal specifies a widget shrinks to fit its children horizontally; ditto - V|Vertical specifies vertically.</td>
			</tr>
			<tr>
				<td id="panel_name">Panel.RectStyle [style]</td>
				<td id="panel_comment">Where style is one of SHARP|ROUNDED|BLUR. Specifies the rectangle perimeter used to render the widget background. See Panel.CornerRadius</td>
			</tr>
			<tr>
				<td id="panel_name">Panel.CornerRadius</td>
				<td id="panel_comment">In the case of a ROUNDED rectangle style, specifies the radius of the corner arcs. Typically 1-10. See Panel.RectStyle</td>
			</tr>
			<tr>
				<td id="panel_name">Panel.AcceptFocus</td>
				<td id="panel_comment">An existential attribute that marks a panel as having the potential for keyboard focus</td>
			</tr>
			<tr>
				<td id="panel_name">#List Panel.Navigate ...</td>
				<td id="panel_comment">The items form a string list of Panel.Description text that is used to define a tabbed navigation sequence for the panel. The argument order specifies the navigation order.</td>
			</tr>
			<tr>
				<td id="panel_name">Panel.Hint [hint]</td>
				<td id="panel_comment">Specifies the [hint] that is registered when keyboard focus applies to the panel. The [hint] may appear in a hint widget.</td>
			</tr>
			<tr>
				<td id="panel_name">Panel.Collapsed</td>
				<td id="panel_comment">An existential attribute that marks a panel as being collapsed - invisible, disabled and taking up no span. All descendants are also invisible, disabled and take no span.</td>
			</tr>
			<tr>
				<td id="panel_name">Panel.NavLeft [desc]</td>
				<td id="panel_comment">Specifies the panel description for the panel that takes the next focus when a left action is taken (gamepad or cursor left). See Panel.Description</td>
			</tr>
			<tr>
				<td id="panel_name">Panel.NavRight</td>
				<td id="panel_comment">Specifies the panel description for the panel that takes the next focus when a right action is taken (gamepad or cursor right). See Panel.Description</td>
			</tr>
			<tr>
				<td id="panel_name">Panel.NavUp</td>
				<td id="panel_comment">Specifies the panel description for the panel that takes the next focus when an up action is taken (gamepad or cursor up). See Panel.Description</td>
			</tr>
			<tr>
				<td id="panel_name">Panel.NavDown</td>
				<td id="panel_comment">Specifies the panel description for the panel that takes the next focus when an up action is taken (gamepad or cursor down). See Panel.Description</td>
			</tr>
				<tr>
				<td id="panel_name">Panel.OcclusionSurface [boolValue]</td>
				<td id="panel_comment">The boolean value true|false determines whether a panel should be painted over with an occlusion surface in the rendering of an occluding GUI object (such as a popup menu). This creates
				a visual cue for the modality of a popup.</td>
			</tr>
		</table>
	</div>
	<div>
		<h2>Colour Attribute Names & Commentary</h2>
	</div>
	<div>
		<table id="colour_table">
			<tr>
				<td id="colour_coldesc"><b>Attribute Name</b></td>
				<td id="colour_coldesc"><b>EGRSchemeColourSurface</b></td>
				<td id="colour_coldesc"><b>Comment</b></td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Background</td>
				<td id = "colour_surface">BACKGROUND</td>
				<td id = "colour_comment">Background for the root frame widget and viewport widget</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Button</td>
				<td id = "colour_surface">BUTTON</td>
				<td id = "colour_comment">Background colour for buttons and slider bulbs</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Button.Edge.Top.Left</td>
				<td id = "colour_surface">BUTTON_EDGE_TOP_LEFT</td>
				<td id = "colour_comment">Edge colour for left and top of button rectangles</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Button.Edge.Bottom.Right</td>
				<td id = "colour_surface">BUTTON_EDGE_BOTTOM_RIGHT</td>
				<td id = "colour_comment">Edge colour for right and buttom of button rectangles</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Button.Image.Fog</td>
				<td id = "colour_surface">BUTTON_IMAGE_FOG</td>
				<td id = "colour_comment">For buttons with images, this is the translucent overlay colour</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Button.Shadow</td>
				<td id = "colour_surface">BUTTON_SHADOW</td>
				<td id = "colour_comment">Provides the shadow colour behind button text</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Button.Text</td>
				<td id = "colour_surface">BUTTON_TEXT</td>
				<td id = "colour_comment">Provides the colour of button text</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Menu.Button</td>
				<td id = "colour_surface">MENU_BUTTON</td>
				<td id = "colour_comment">In a menu item, determines the background colour</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Menu.Button.Edge.Top.Left</td>
				<td id = "colour_surface">MENU_BUTTON_EDGE_TOP_LEFT</td>
				<td id = "colour_comment">Edge colour for left and top of menu item rectangles</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Menu.Button.Edge.Bottom.Right</td>
				<td id = "colour_surface">MENU_BUTTON_EDGE_BOTTOM_RIGHT</td>
				<td id = "colour_comment">Edge colour for right and bottom of menu item rectangles</td>
			</tr>
			
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Container.Background</td>
				<td id = "colour_surface">CONTAINER_BACKGROUND</td>
				<td id = "colour_comment">Background colour of control-prompts, divisions, hintboxes, radio-button groups, toolbars and vertical lists</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Container.Top.Left</td>
				<td id = "colour_surface">CONTAINER_TOP_LEFT</td>
				<td id = "colour_comment">Top-left edge colour of control-prompts, game option controls, property editors, divisions, hintboxes, labels, radio-button groups, viewports, toolbars and vertical lists</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Container.Bottom.Right</td>
				<td id = "colour_surface">CONTAINER_BOTTOM_RIGHT</td>
				<td id = "colour_comment">Bottom-right edge colour of control-prompts, game option controls, property editors, divisions, hintboxes, labels, radio-button groups, viewports, toolbars and vertical lists</td>
			</tr>
			
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Scroller.Button.Background</td>
				<td id = "colour_surface">SCROLLER_BUTTON_BACKGROUND</td>
				<td id = "colour_comment">Background colour of vertical scroller buttons</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Scroller.Button.Top.Left</td>
				<td id = "colour_surface">SCROLLER_BUTTON_TOP_LEFT</td>
				<td id = "colour_comment">Top-left edge colour of vertical scroller buttons</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Scroller.Button.Bottom.Right</td>
				<td id = "colour_surface">SCROLLER_BUTTON_BOTTOM_RIGHT</td>
				<td id = "colour_comment">Bottom-right edge colour of vertical scroller buttons</td>
			</tr>
			
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Scroller.Bar.Background</td>
				<td id = "colour_surface">SCROLLER_BAR_BACKGROUND</td>
				<td id = "colour_comment">Background colour of scroller bars</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Scroller.Bar.Top.Left</td>
				<td id = "colour_surface">SCROLLER_BAR_TOP_LEFT</td>
				<td id = "colour_comment">Top-left edge colour of vertical scroller bar</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Scroller.Bar.Bottom.Right</td>
				<td id = "colour_surface">SCROLLER_BAR_BOTTOM_RIGHT</td>
				<td id = "colour_comment">Bottom-right edge colour of vertical scroller bar</td>
			</tr>
			
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Scroller.Slider.Background</td>
				<td id = "colour_surface">SCROLLER_SLIDER_BACKGROUND</td>
				<td id = "colour_comment">Background colour of scroller slider</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Scroller.Slider.Top.Left"</td>
				<td id = "colour_surface">SCROLLER_SLIDER_TOP_LEFT</td>
				<td id = "colour_comment">Top-left edge colour of vertical scroller slider</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Scroller.Slider.Bottom.Right</td>
				<td id = "colour_surface">SCROLLER_SLIDER_BOTTOM_RIGHT</td>
				<td id = "colour_comment">Bottom-right edge colour of vertical scroller slider</td>
			</tr>
			
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Editor</td>
				<td id = "colour_surface">EDITOR</td>
				<td id = "colour_comment">Background colour of an editor widget in edit mode</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Text</td>
				<td id = "colour_surface">TEXT</td>
				<td id = "colour_comment">Text colour for an editor in edit mode, a label, a game option control title, or property editor name-value widgets</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Focus</td>
				<td id = "colour_surface">FOCUS_RECTANGLE</td>
				<td id = "colour_comment">Comment</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.EditText</td>
				<td id = "colour_surface">FOCUS_RECTANGLE</td>
				<td id = "colour_comment">Focus widget highlight colour</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Label</td>
				<td id = "colour_surface">LABEL_BACKGROUND</td>
				<td id = "colour_comment">Background colour for editor widgets in read-only mode, labels, game option titles, and property editor titles</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Label.Shadow</td>
				<td id = "colour_surface">LABEL_SHADOW</td>
				<td id = "colour_comment">Text shadow colour for labels</td>
			</tr>
			
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Splitter.Background</td>
				<td id = "colour_surface">SPLITTER_BACKGROUND</td>
				<td id = "colour_comment">Background colour for splitter widget</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Splitter.Edge</td>
				<td id = "colour_surface">SPLITTER_EDGE</td>
				<td id = "colour_comment">Edge colour for splitter widget</td>
			</tr>
			
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Carousel.Text</td>
				<td id = "colour_surface">CAROUSEL_TEXT</td>
				<td id = "colour_comment">Text colour for carousel when not disabled</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Carousel.Background</td>
				<td id = "colour_surface">CAROUSEL_BACKGROUND</td>
				<td id = "colour_comment">Background colour for carousel when not disabled</td>
			</tr>			
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Carousel.Top.Left</td>
				<td id = "colour_surface">CAROUSEL_TOP_LEFT</td>
				<td id = "colour_comment">Top-left edge colour of carousel control</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Carousel.Bottom.Right</td>
				<td id = "colour_surface">CAROUSEL_BOTTOM_RIGHT</td>
				<td id = "colour_comment">Bottom-right edge colour of carousel control</td>
			</tr>
			
			<tr id = "colour_row">
				<td id = "colour_name">Colour.GameOption.Background</td>
				<td id = "colour_surface">GAME_OPTION_BACKGROUND</td>
				<td id = "colour_comment">Background colour for game option container if not disabled</td>
			</tr>			
			<tr id = "colour_row">
				<td id = "colour_name">Colour.GameOption.Disabled.Background</td>
				<td id = "colour_surface">GAME_OPTION_DISABLED_BACKGROUND</td>
				<td id = "colour_comment">Background colour for game option container if disabled</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.GameOption.Disabled.Text</td>
				<td id = "colour_surface">GAME_OPTION_DISABLED_TEXT</td>
				<td id = "colour_comment">Text colour for disabled option</td>
			</tr>
			
			<tr id = "colour_row">
				<td id = "colour_name">Colour.GameOption.Top.Left</td>
				<td id = "colour_surface">GAME_OPTION_TOP_LEFT</td>
				<td id = "colour_comment">Top-left edge colour of game option container</td>
			</tr>			
			<tr id = "colour_row">
				<td id = "colour_name">Colour.GameOption.Bottom.Right</td>
				<td id = "colour_surface">GAME_OPTION_BOTTOM_RIGHT</td>
				<td id = "colour_comment">Bottom-right edge colour of game option container</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.GameOption.ChildSpacer</td>
				<td id = "colour_surface">GAME_OPTION_CHILD_SPACER</td>
				<td id = "colour_comment">Colour of the line below a game option</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Carousel.DropDown</td>
				<td id = "colour_surface">CAROUSEL_DROP_DOWN_BACKGROUND</td>
				<td id = "colour_comment">Scrollable menu background colour for a carousel drop-down</td>
			</tr>			
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Carousel.DropDown.Text</td>
				<td id = "colour_surface">CAROUSEL_DROP_DOWN_TEXT</td>
				<td id = "colour_comment">Scrollable menu text colour for a carousel drop-down</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Portrait.Band</td>
				<td id = "colour_surface">PORTRAIT_BAND_COLOUR</td>
				<td id = "colour_comment">The colour of the bands that appear to the sides of the portrait widget when the aspect ratio of the panel does not match the image</td>
			</tr>
			
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Slider.Guage</td>
				<td id = "colour_surface">SLIDER_GUAGE</td>
				<td id = "colour_comment">Game option scalar background colour for slider guage</td>
			</tr>			
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Slider</td>
				<td id = "colour_surface">SLIDER_BACKGROUND</td>
				<td id = "colour_comment">Slider background colour</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Slider.Slot</td>
				<td id = "colour_surface">SLIDER_SLOT_BACKGROUND</td>
				<td id = "colour_comment">Slider slot background colour</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Slider.Slot.Edge.1</td>
				<td id = "colour_surface">SLIDER_SLOT_EDGE_1</td>
				<td id = "colour_comment">1st edge colour for the slider slot. Results depends on the slider rendering algorithm</td>
			</tr>			
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Slider.Slot.Edge.2</td>
				<td id = "colour_surface">SLIDER_SLOT_EDGE_2</td>
				<td id = "colour_comment">2nd edge colour for the slider slot. Results depends on the slider rendering algorithm</td>
			</tr>
			<tr id = "colour_row">
				<td id = "colour_name">Colour.Occlusion.Surface</td>
				<td id = "colour_surface">OCCLUSION_SURFACE</td>
				<td id = "colour_comment">The colour a scrollable menu uses to mask off the background panels</td>
			</tr>
		</table>
	</div>
  </body>
 </html>