// Copyright (c) 2025 Mark Anthony Taylor. All rights reserved. Email: mark.anthony.taylor@gmail.com.
// Bundle generated by Build.Rococo.GUI.cs on Oct 2025 UTC
// Copyright (c)2025 Mark Anthony Taylor (mark.anthony.taylor@gmail.com). All rights reserved.
// This software is open source, but not free. Check the rococo master branch for the latest Copyright rules that applies to this software

#include "rococo.UE5.cpp.h"

#ifdef _WIN32
# pragma warning(disable: 4458) // this is my coding style and I don't see many errors arising out of the choice of style
# pragma warning(disable: 4265) // virtualized destructors are irrelevant for these classes using the Free() pattern
#else
# pragma clang diagnostic push
# pragma clang diagnostic ignored "-Wshadow"
# pragma clang diagnostic ignored "-Wdelete-non-abstract-non-virtual-dtor"
# pragma clang diagnostic ignored "-Woverloaded-virtual"
# pragma clang diagnostic ignored "-Wmissing-braces"
#endif
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.button.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <rococo.strings.h>
#include <rococo.ui.h>
#include <rococo.vkeys.h>
#include <unordered_set>

using namespace Rococo;
using namespace Rococo::Gui;

namespace GRANON
{
	struct GRButton : IGRWidgetButton, IGRWidgetSupervisor, IGRWidgetLayout
	{
		IGRPanel& panel;
		EGRClickCriterion clickCriterion = EGRClickCriterion::OnDown;
		EGREventPolicy eventPolicy = EGREventPolicy::PublicEvent;

		bool isRaised = true;
		bool isMenu = false;
		bool forSubmenu = false;
		bool isEventHandlerCPPOnly = false;

		Strings::HString raisedImagePath;
		Strings::HString pressedImagePath;
		IGRImage* raisedImage = nullptr;
		IGRImage* pressedImage = nullptr;

		bool isStretched = false;

		bool triggersOnKeyUp = true;

		int spanPadding = 8;

		GRButton(IGRPanel& owningPanel) : panel(owningPanel)
		{
			alignment.Add(EGRAlignment::HCentre).Add(EGRAlignment::VCentre);
			panel.Add(EGRPanelFlags::AcceptsFocus);
		}

		virtual ~GRButton()
		{
		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		void TriggerOnKeyDown() override
		{
			triggersOnKeyUp = false;
		}

		void LayoutBeforeFit() override
		{
			SyncMinimalSpan();
		}

		void LayoutBeforeExpand() override
		{

		}

		void LayoutAfterExpand() override
		{

		}

		void Free() override
		{
			delete this;
		}

		GRButtonFlags ButtonFlags() const override
		{
			GRButtonFlags flags;
			flags.forSubMenu = forSubmenu;
			flags.isEnabled = true;
			flags.isMenu = isMenu;
			flags.isRaised = isRaised;
			return flags;
		}

		void FireEvent(Vec2i clickPosition)
		{
			int nTerminations = 0;

			for (auto* s : subscribers)
			{
				ButtonEvent ev{ EGRButtonEventType::ButtonClicked, *this, EGREventRouting::NextHandler };
				s->OnEvent(ev);
				if (ev.routing == EGREventRouting::Terminate)
				{
					nTerminations++;
				}
			}

			if (nTerminations > 0)
			{
				GetCustodian(panel).Log("GRButton::FireEvent(): subscriber terminated. [%lld] %s", panel.Id(), panel.Desc());
				return;
			}

			if (eventPolicy == EGREventPolicy::PublicEvent)
			{		
				// We cannot copy the meta data string, because it may be invalidated by the time the consumer comes to read it
				GRWidgetEvent asyncWidgetEvent{ EGRWidgetEventType::BUTTON_CLICK, panel.Id(), iMetadata, "", clickPosition, isEventHandlerCPPOnly };
				RouteEventToHandler(panel, asyncWidgetEvent);
				GetCustodian(panel).Log("GRButton::FireEvent(): PublicEvent routed async. [%lld] %s", panel.Id(), panel.Desc());
			}
			else if (eventPolicy == EGREventPolicy::NotifyAncestors)
			{
				GRWidgetEvent widgetEvent{ EGRWidgetEventType::BUTTON_CLICK, panel.Id(), iMetadata, sMetaData.c_str(), clickPosition, isEventHandlerCPPOnly };

				EGREventRouting routing = panel.NotifyAncestors(widgetEvent, *this);
				if (routing != EGREventRouting::Terminate)
				{
					// Nothing handled it
					RouteEventToHandler(panel, widgetEvent);
					GetCustodian(panel).Log("GRButton::FireEvent(): RouteEventToHandler handled. [%lld] %s", panel.Id(), panel.Desc());
				}
				else
				{
					GetCustodian(panel).Log("GRButton::FireEvent(): Ancestor handled. [%lld] %s", panel.Id(), panel.Desc());
				}
			}
			else
			{
				GetCustodian(panel).Log("GRButton::FireEvent(): Nothing handled it. [%lld] %s", panel.Id(), panel.Desc());
			}
		}

		EGREventRouting OnCursorClick(GRCursorEvent& ce) override
		{
			if (panel.HasFlag(EGRPanelFlags::AcceptsFocus))
			{
				panel.FocusAndNotifyAncestors();
			}

			if (ce.click.LeftButtonDown)
			{
				if (clickCriterion == EGRClickCriterion::OnDown)
				{
					if (isToggler)
					{
						isRaised = !isRaised;
					}
					else
					{
						isRaised = false;
					}

					SyncMinimalSpan();
					FireEvent(ce.position);
				}
				else if (clickCriterion == EGRClickCriterion::OnDownThenUp)
				{
					if (!isToggler)
					{
						isRaised = false;
					}
					SyncMinimalSpan();
					panel.CaptureCursor();
				}
				return EGREventRouting::Terminate;
			}
			else if (ce.click.LeftButtonUp)
			{
				if (clickCriterion == EGRClickCriterion::OnUp)
				{
					if (isToggler)
					{
						isRaised = !isRaised;
					}
					else
					{
						isRaised = true;
					}
					SyncMinimalSpan();
					FireEvent(ce.position);
				}
				else if (clickCriterion == EGRClickCriterion::OnDownThenUp)
				{
					bool flipped = true;

					if (isToggler)
					{
						isRaised = !isRaised;
					}
					else if (!isRaised)
					{
						isRaised = true;
					}
					else
					{
						flipped = false;
					}

					if (flipped)
					{
						SyncMinimalSpan();
						FireEvent(ce.position);
					}

					if (panel.Root().CapturedPanelId() == panel.Id())
					{
						panel.Root().ReleaseCursor();
					}
				}
				
				return EGREventRouting::Terminate;
			}

			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{
			if (!isToggler && !isRaised)
			{
				isRaised = true;
			}
		}

		EGREventRouting OnCursorMove(GRCursorEvent& ce) override
		{
			if (!IsPointInRect(ce.position, panel.AbsRect()) && panel.Root().CapturedPanelId() == panel.Id())
			{
				// The cursor has been moved outside the button, so capture should be lost
				panel.Root().ReleaseCursor();
				return EGREventRouting::NextHandler;
			}

			if (focusOnMouseMove)
			{
				if (panel.Root().GR().GetFocusId() != -1 && panel.HasFocus())
				{
					panel.FocusAndNotifyAncestors();
				}
			}

			return EGREventRouting::NextHandler;
		}

		bool keyboardPrepped = false;

		EGREventRouting OnKeyEvent(GRKeyEvent& key) override
		{
			if (!triggersOnKeyUp)
			{
				keyboardPrepped = true;
			}

			if (triggersOnKeyUp)
			{
				if (!key.osKeyEvent.IsUp())
				{
					switch (key.osKeyEvent.VKey)
					{
					case IO::VirtualKeys::VKCode_ENTER:
						keyboardPrepped = true;
						return EGREventRouting::Terminate;
					}
				}
				else
				{
					switch (key.osKeyEvent.VKey)
					{
					case IO::VirtualKeys::VKCode_ENTER:
						if (keyboardPrepped)
						{
							keyboardPrepped = false;

							SyncMinimalSpan();

							if (panel.Root().CapturedPanelId() == panel.Id())
							{
								panel.Root().ReleaseCursor();
							}

							if (isToggler)
							{
								isRaised = !isRaised;
							}
							else
							{
								isRaised = false;
							}

							FireEvent(Centre(panel.AbsRect()));
						}
						return EGREventRouting::Terminate;
					}
				}
			}
			else if (!key.osKeyEvent.IsUp())
			{
				switch (key.osKeyEvent.VKey)
				{
				case IO::VirtualKeys::VKCode_ENTER:
					SyncMinimalSpan();

					if (panel.Root().CapturedPanelId() == panel.Id())
					{
						panel.Root().ReleaseCursor();
					}

					FireEvent(Centre(panel.AbsRect()));
					return EGREventRouting::Terminate;
				}
			}

			return EGREventRouting::NextHandler;
		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		void Render(IGRRenderContext& g) override
		{
			if (isMenu)
			{
				GuiRect buttonRect = Expand(panel.AbsRect(), -2);
				GRWidgetRenderState rs(false, false, false);
				RGBAb colour = panel.GetColour(EGRSchemeColourSurface::MENU_BUTTON, rs);
				g.DrawRect(panel.AbsRect(), colour);
				DrawMenuButton(panel, buttonRect, false, isRaised, g);
			}
			else
			{
				DrawButton(panel, false, isRaised, g, backSurface);
			}

			bool isHovered = g.IsHovered(panel);

			bool imageRendered = false;

			IGRImage* image = isRaised ? raisedImage : pressedImage;

			GRWidgetRenderState rs(!isRaised, isHovered, false);

			if (image)
			{
				imageRendered = image->Render(panel, alignment, spacing, isStretched, g);

				GuiRect fogRect = panel.AbsRect();
				fogRect.left += 1;
				fogRect.right -= 1;
				fogRect.top += 1;
				fogRect.bottom -= 1;
				g.DrawRect(fogRect, panel.GetColour(EGRSchemeColourSurface::BUTTON_IMAGE_FOG, rs, RGBAb(0, 0, 0, 128)));
			}

			if (!imageRendered)
			{
				if (substituteBetterFontAccordingly)
				{
					alignment.Add(EGRAlignment::AutoFonts);
				}
				else
				{
					alignment.Remove(EGRAlignment::AutoFonts);
				}

				RGBAb shadowColour = isMenu ? RGBAb(0,0,0,0) : panel.GetColour(EGRSchemeColourSurface::BUTTON_SHADOW, rs);
				RGBAb colour = panel.GetColour(isMenu ? EGRSchemeColourSurface::MENU_BUTTON_TEXT : textSurface, rs);
				DrawButtonText(panel, alignment, spacing, title.to_fstring(), colour, shadowColour, fontId, g);
			}
		}

		GRAlignmentFlags alignment;
		Vec2i spacing { 0,0 };
		bool focusOnMouseMove = false;

		IGRWidgetButton& FocusOnMouseMove(bool focusOnMouseMove) override
		{
			this->focusOnMouseMove = focusOnMouseMove;
			return *this;
		}

		IGRWidgetButton& SetAlignment(GRAlignmentFlags alignment, Vec2i spacing) override
		{
			this->alignment = alignment;
			this->spacing = spacing;
			return *this;
		}

		IGRWidgetButton& SetImagePath(cstr imagePath) override
		{
			this->raisedImagePath = imagePath ? imagePath : "";
			this->pressedImagePath = imagePath ? imagePath : "";
			raisedImage = panel.Root().Custodian().CreateImageFromPath("raised button", this->raisedImagePath.c_str());
			pressedImage = panel.Root().Custodian().CreateImageFromPath("pressed button", this->pressedImagePath.c_str());
			SyncMinimalSpan();
			return *this;
		}

		IGRWidgetButton& SetPressedImagePath(cstr imagePath) override
		{
			this->pressedImagePath = imagePath ? imagePath : "";
			pressedImage = panel.Root().Custodian().CreateImageFromPath("pressed button", this->pressedImagePath.c_str());
			SyncMinimalSpan();
			return *this;
		}

		IGRWidgetButton& SetRaisedImagePath(cstr imagePath) override
		{
			this->raisedImagePath = imagePath ? imagePath : "";
			raisedImage = panel.Root().Custodian().CreateImageFromPath("raised button", this->raisedImagePath.c_str());
			SyncMinimalSpan();
			return *this;
		}

		Vec2i ImageSpan() const override
		{
			auto* image = pressedImage ? pressedImage : raisedImage;
			return image ? image->Span() : Vec2i{ spanPadding,spanPadding };
		}

		Vec2i MinimalSpan() const override
		{
			Vec2i textSpan = panel.Root().GR().Fonts().EvaluateMinimalSpan(fontId, title, Vec2i{ spanPadding,spanPadding });
			Vec2i imageSpan = ImageSpan();

			int dx = max(max(textSpan.x, imageSpan.x), spanPadding);
			int dy = max(max(textSpan.y, imageSpan.x), spanPadding);
			return { dx, dy };
		}

		EGRSchemeColourSurface backSurface = EGRSchemeColourSurface::BUTTON;

		IGRWidgetButton& SetBackSurface(EGRSchemeColourSurface backSurface) override
		{
			this->backSurface = backSurface;
			return *this;
		}

		EGRSchemeColourSurface textSurface = EGRSchemeColourSurface::BUTTON_TEXT;

		IGRWidgetButton& SetTextSurface(EGRSchemeColourSurface textSurface) override
		{
			this->textSurface = textSurface;
			return *this;
		}

		IGRWidgetButton& SetClickCriterion(EGRClickCriterion criterion) override
		{
			this->clickCriterion = criterion;
			return *this;
		}

		IGRWidgetButton& SetEventPolicy(EGREventPolicy policy) override
		{
			this->eventPolicy = policy;
			return *this;
		}

		int64 iMetadata = 0;
		Strings::HString sMetaData;

		IGRWidgetButton& SetMetaData(const GRControlMetaData& metaData, bool isCppOnly) override
		{
			iMetadata = metaData.intData;
			sMetaData = metaData.stringData ? metaData.stringData : "";
			isEventHandlerCPPOnly = isCppOnly;
			return *this;
		}

		GRControlMetaData MetaData() override
		{
			return GRControlMetaData { iMetadata, sMetaData.c_str() };
		}

		EGREventRouting OnChildEvent(GRWidgetEvent&, IGRWidget&) override
		{
			return EGREventRouting::NextHandler;
		}

		Strings::HString title;
		GRFontId fontId = GRFontId::NONE;

		IGRWidgetButton& SetTitle(cstr title) override
		{
			isDirty = true;
			this->title = title == nullptr ? "" : title;
			panel.SetDesc(title);
			SyncMinimalSpan();
			return *this;
		}

		bool substituteBetterFontAccordingly = false;

		IGRWidgetButton& SetPressedNoCallback(bool pressed) override
		{
			isRaised = !pressed;
			return *this;
		}

		IGRWidgetButton& SetFontId(GRFontId id, bool substituteBetterFontAccordingly) override
		{
			isDirty = true;
			fontId = id;
			this->substituteBetterFontAccordingly = substituteBetterFontAccordingly;
			return *this;
		}

		bool expandToFitTextX = false;
		bool expandToFitTextY = false;
		bool isDirty = true;

		void FitTextHorizontally() override
		{
			expandToFitTextX = true;
			isDirty = true;
			SyncMinimalSpan();
		}

		void FitTextVertically() override
		{
			expandToFitTextY = true;
			isDirty = true;
			SyncMinimalSpan();
		}

		size_t GetTitle(char* titleBuffer, size_t nBytes) const override
		{
			if (titleBuffer == nullptr || nBytes == 0)
			{
				return title.length();
			}

			Strings::CopyString(titleBuffer, nBytes, title, title.length());
			return title.length();
		}

		Vec2i EvaluateMinimalSpan() const
		{
			Vec2i extraSpan;

			extraSpan.x = panel.Padding().left + panel.Padding().right;
			extraSpan.y = panel.Padding().top + panel.Padding().bottom;

			const IGRImage* image = isRaised ? raisedImage : pressedImage;
			if (image)
			{
				return image->Span() + extraSpan;
			}

			if (title.length() == 0)
			{
				return Vec2i { spanPadding, spanPadding } + extraSpan;
			}

			return panel.Root().Custodian().EvaluateMinimalSpan(fontId, fstring{ title.c_str(), (int32)title.length() }, extraSpan);
		}

		void SyncMinimalSpan()
		{
			Vec2i minimalSpan = EvaluateMinimalSpan();

			if (expandToFitTextX)
			{
				panel.SetConstantWidth(minimalSpan.x);
			}

			if (expandToFitTextY)
			{
				panel.SetConstantHeight(minimalSpan.y);
			}
		}

		bool isToggler = false;

		void MakeToggleButton() override
		{
			isToggler = true;
		}

		void SetStretchImage(bool isStretched) override
		{
			this->isStretched = isStretched;
			isDirty = true;
		}

		void Toggle() override
		{
			if (!isToggler)
			{
				RaiseError(panel, EGRErrorCode::InvalidArg, __ROCOCO_FUNCTION__, "The button is not a toggler");
			}

			isRaised = !isRaised;

			FireEvent(Centre(panel.AbsRect()));
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			auto result = QueryForParticularInterface<IGRWidgetButton, GRButton>(this, ppOutputArg, interfaceId);
			if (result == EGRQueryInterfaceResult::SUCCESS)
			{
				return EGRQueryInterfaceResult::SUCCESS;
			}

			return QueryForParticularInterface<IGRWidgetLayout, GRButton>(this, ppOutputArg, interfaceId);
		}

		IGRWidget& Widget()
		{
			return *this;
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRButton";
		}

		std::unordered_set<IEventCallback<ButtonEvent>*> subscribers;

		void Subscribe(IEventCallback<ButtonEvent>& eventHandler) override
		{
			subscribers.insert(&eventHandler);
		}

		void Unsubscribe(IEventCallback<ButtonEvent>& eventHandler) override
		{
			subscribers.erase(&eventHandler);
		}
	};

	struct GRButtonFactory : IGRWidgetFactory
	{
		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			return *new GRButton(panel);
		}
	} s_ButtonFactory;
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetButton::InterfaceId()
	{
		return "IGRWidgetButton";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetButton& CreateButton(IGRWidget& parent)
	{
		auto& gr = parent.Panel().Root().GR();
		auto& widget = gr.AddWidget(parent.Panel(), GRANON::s_ButtonFactory);
		IGRWidgetButton* button = Cast<IGRWidgetButton>(widget);
		return *button;
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetButton& CreateMenuButton(IGRWidget& parent, bool forSubmenu)
	{
		auto& gr = parent.Panel().Root().GR();
		auto& button = static_cast<GRANON::GRButton&>(gr.AddWidget(parent.Panel(), GRANON::s_ButtonFactory));
		button.isMenu = true;
		button.forSubmenu = forSubmenu;
		return button;
	}

	ROCOCO_GUI_RETAINED_API void DrawButton(IGRPanel& panel, bool focused, bool raised, IGRRenderContext& g, EGRSchemeColourSurface backSurface)
	{
		DrawPanelBackgroundEx(panel, g, backSurface, EGRSchemeColourSurface::BUTTON_EDGE_TOP_LEFT, EGRSchemeColourSurface::BUTTON_EDGE_BOTTOM_RIGHT, 1.0f, raised, focused);
	}

	ROCOCO_GUI_RETAINED_API void DrawMenuButton(IGRPanel& panel, const GuiRect& rect, bool focused, bool raised, IGRRenderContext& g)
	{
		UNUSED(focused);

		bool hovered = g.IsHovered(panel);
		
		GRWidgetRenderState rs(!raised, hovered, false);
		RGBAb colour = panel.GetColour(EGRSchemeColourSurface::MENU_BUTTON, rs);
		g.DrawRect(rect, colour);

		RGBAb colour1 = panel.GetColour(EGRSchemeColourSurface::MENU_BUTTON_EDGE_TOP_LEFT, rs);
		RGBAb colour2 = panel.GetColour(EGRSchemeColourSurface::MENU_BUTTON_EDGE_BOTTOM_RIGHT, rs);
		g.DrawRectEdge(rect, colour1, colour2);
	}

	ROCOCO_GUI_RETAINED_API void DrawButtonText(IGRPanel& panel, GRAlignmentFlags alignment, Vec2i spacing, const fstring& text, RGBAb colour, RGBAb shadowColour, GRFontId fontId, IGRRenderContext& g, Vec2i shadowOffset)
	{
		if (text.length == 0) return;

		GuiRect targetRect = panel.AbsRect();

		if (targetRect.left > targetRect.right)
		{
			swap_args(targetRect.left, targetRect.right);
		}

		if (targetRect.bottom < targetRect.top)
		{
			swap_args(targetRect.top, targetRect.bottom);
		}

		if (shadowColour.alpha)
		{
			GuiRect shadowRect = targetRect;
			shadowRect.left += shadowOffset.x;
			shadowRect.right += shadowOffset.x;
			shadowRect.top += shadowOffset.y;
			shadowRect.bottom += shadowOffset.y;
			g.DrawText(fontId, shadowRect, alignment, spacing, text, shadowColour);
		}

		g.DrawText(fontId, targetRect, alignment, spacing, text, colour);
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.carousel.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <rococo.strings.h>
#include <math.h>
#include <vector>
#include <rococo.ui.h>
#include <rococo.vkeys.h>

using namespace Rococo;
using namespace Rococo::Gui;
using namespace Rococo::Strings;

namespace GRANON
{
	struct GRCarousel : IGRWidgetCarousel, IGRWidgetSupervisor, IGRWidgetLayout
	{
		struct Option
		{
			HString key;
			HString value;
		};

		IGRPanel& panel;

		std::vector<Option> options;

		int optionIndex = 1;

		// This gets overwritten by LayoutBeforeFit
		GRAnchorPadding optionPadding{ 4, 4, 16, 16 };

		IGRWidgetButton* leftButton = nullptr;
		IGRWidgetButton* rightButton = nullptr;
		IGRWidgetScrollableMenu* dropDown = nullptr;

		GRFontId fontId = GRFontId::NONE;
		
		GRCarousel(IGRPanel& owningPanel) : panel(owningPanel)
		{
			panel.SetLayoutDirection(ELayoutDirection::None);
		}

		virtual ~GRCarousel()
		{

		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		void Free() override
		{
			delete this;
		}

		void SetFont(GRFontId fontId) override
		{
			this->fontId = fontId;
		}

		void SetOptionPadding(GRAnchorPadding padding) override
		{
			this->optionPadding = padding;
		}

		void PostConstruct(cstr leftImagePathRaised, cstr rightImagePathRaised, cstr leftImagePathPressed, cstr rightImagePathPressed)
		{
			leftButton = &CreateButton(*this);
			rightButton = &CreateButton(*this);

			leftButton->SetRaisedImagePath(leftImagePathRaised);
			rightButton->SetRaisedImagePath(rightImagePathRaised);
			leftButton->SetPressedImagePath(leftImagePathPressed);
			rightButton->SetPressedImagePath(rightImagePathPressed);

			GRAlignmentFlags alignment;
			alignment.Add(EGRAlignment::HCentre).Add(EGRAlignment::Top);
			leftButton->SetAlignment(alignment, { 0,0 });
			leftButton->SetAlignment(alignment, { 0, 0 });

			leftButton->SetEventPolicy(EGREventPolicy::NotifyAncestors);
			rightButton->SetEventPolicy(EGREventPolicy::NotifyAncestors);
			leftButton->Panel().Remove(EGRPanelFlags::AcceptsFocus);
			rightButton->Panel().Remove(EGRPanelFlags::AcceptsFocus);

			MakeTransparent(leftButton->Panel(), EGRSchemeColourSurface::BUTTON_EDGE_TOP_LEFT);
			MakeTransparent(leftButton->Panel(), EGRSchemeColourSurface::BUTTON_EDGE_BOTTOM_RIGHT);
			MakeTransparent(leftButton->Panel(), EGRSchemeColourSurface::BUTTON);
			MakeTransparent(leftButton->Panel(), EGRSchemeColourSurface::BUTTON_IMAGE_FOG);

			MakeTransparent(rightButton->Panel(), EGRSchemeColourSurface::BUTTON_EDGE_TOP_LEFT);
			MakeTransparent(rightButton->Panel(), EGRSchemeColourSurface::BUTTON_EDGE_BOTTOM_RIGHT);
			MakeTransparent(rightButton->Panel(), EGRSchemeColourSurface::BUTTON);
			MakeTransparent(rightButton->Panel(), EGRSchemeColourSurface::BUTTON_IMAGE_FOG);

			dropDown = &CreateScrollableMenu(*this);
			dropDown->Panel().SetCollapsed(true);
			dropDown->Panel().SetRenderLast(true);
		}

		void AddOption(cstr name, cstr caption, cstr hint) override
		{
			options.push_back({ name, caption });
			dropDown->AddOption(name, caption, hint);
		}

		void Advance(int delta)
		{
			optionIndex += delta;
		}

		void FlipDropDown() override
		{
			if (dropDown->Panel().IsCollapsed())
			{
				ExpandDropDownAndNotify(Centre(panel.AbsRect()));
			}
			else
			{
				CollapseDropDownAndNotify(Centre(panel.AbsRect()));
			}
		}

		void SetActiveChoice(cstr name) override
		{
			for (size_t i = 0; i < options.size(); i++)
			{
				if (Eq(options[i].key, name))
				{
					optionIndex = (int)i;
					break;
				}
			}

			if (!dropDown->Panel().IsCollapsed())
			{
				CollapseDropDownAndNotify({ 0,0 });
			}
		}

		void CollapseDropDownAndNotify(Vec2i clickPosition)
		{
			dropDown->Panel().SetCollapsed(true);

			GRWidgetEvent we;
			we.clickPosition = clickPosition;
			we.eventType = EGRWidgetEventType::DROP_DOWN_COLLAPSED;
			we.iMetaData = 0;
			we.isCppOnly = true;
			we.panelId = panel.Id();
			we.sMetaData = "<carousel.dropdown>";
			panel.NotifyAncestors(we, *this);
		}

		void ExpandDropDownAndNotify(Vec2i clickPosition)
		{
			dropDown->Panel().SetCollapsed(false);
			dropDown->OnVisible();

			// Ensure this carousel is fully visible in the container viewport
			panel.FocusAndNotifyAncestors();

			// Then focus the dropdown
			auto* focusWidget = TrySetDeepFocus(dropDown->Panel());
			UNUSED(focusWidget);
			GRWidgetEvent we;
			we.clickPosition = clickPosition;
			we.eventType = EGRWidgetEventType::DROP_DOWN_EXPANDED;
			we.iMetaData = 0;
			we.isCppOnly = true;
			we.panelId = panel.Id();
			we.sMetaData = "<carousel.dropdown>";
			panel.NotifyAncestors(we, *this);
		}

		EGREventRouting OnCursorClick(GRCursorEvent& ce) override
		{
			if (ce.click.LeftButtonUp)
			{
				GuiRect edge = ComputeEdgeRect();
				if (IsPointInRect(ce.position, edge))
				{
					ExpandDropDownAndNotify(ce.position);
					return EGREventRouting::Terminate;
				}
			}
			return EGREventRouting::NextHandler;
		}

		IGRWidgetScrollableMenu& DropDown() override
		{
			return *dropDown;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{
		}

		void LayoutBeforeFit() override
		{
			Vec2i buttonSpan = leftButton->ImageSpan();

			const auto& rect = panel.AbsRect();

			int yPadding = (Height(rect) - buttonSpan.y) / 2;

			GuiRect edge = ComputeEdgeRect();
			Vec2i centre = Span(rect);
			centre.x /= 2;
			centre.y /= 2;

			Vec2i edgeSpan = Span(edge);

			Vec2i leftOffset{  optionPadding.left - buttonSpan.x - 2, yPadding + 1 };
			Vec2i rightOffset{ Width(rect) - optionPadding.right + 2, yPadding + 1 };

			leftButton->Panel().SetParentOffset(leftOffset).SetConstantSpan(buttonSpan);
			rightButton->Panel().SetParentOffset(rightOffset).SetConstantSpan(buttonSpan);

			if (!dropDown->Panel().IsCollapsed())
			{
				int domainHeight = max(dropDown->ComputeDomainHeight(), 20);
				int dropDownHeight = domainHeight;

				bool isRenderedUnderneathEdge = true;

				Vec2i screenSpan = panel.Root().ScreenDimensions();
				Vec2i panelCentre = Centre(rect);
				if (panelCentre.y + domainHeight > screenSpan.y)
				{
					if (panelCentre.y > screenSpan.y / 2)
					{
						isRenderedUnderneathEdge = false;

						if (rect.top - domainHeight < 0)
						{
							dropDownHeight = rect.top;
						}
					}
					else
					{
						dropDownHeight = screenSpan.y - rect.bottom;
					}
				}

				int cellHeight = dropDown->LastComputedButtonSpan().y;


				// Hack in cosmetic height range (So that cells can be rendered fully and not partially more frequently)
				if (dropDownHeight > cellHeight)
				{
					// Some arbitrary sanitization range
					if (cellHeight >= 10 && cellHeight < 200)
					{
						int nCells = dropDownHeight / cellHeight;
						int newDropDownHeight = (dropDownHeight / cellHeight) * cellHeight;
						if (newDropDownHeight < cellHeight)
						{
							newDropDownHeight = cellHeight;
						}

						if (newDropDownHeight > 5 * cellHeight)
						{
							// Odd number of cells. We need to make even so that we can have a page size that does not break cell bounds
							if ((nCells & 1) != 0)
							{
								newDropDownHeight -= cellHeight;
							}
						}

						dropDownHeight = newDropDownHeight;
					}
				}

				if (isCarouselDisabledWhenDropDownVisible)
				{
					leftButton->Panel().SetCollapsed(true);
					rightButton->Panel().SetCollapsed(true);
				}

				dropDown->Panel().SetConstantWidth(edgeSpan.x);
				dropDown->Panel().SetConstantHeight(dropDownHeight);
				dropDown->Viewport().SetDomainHeight(domainHeight);
				dropDown->Panel().SetParentOffset({ centre.x - (edgeSpan.x / 2), isRenderedUnderneathEdge ? edge.bottom - rect.top : edge.top - rect.top - dropDownHeight });
			}
			else
			{
				leftButton->Panel().SetCollapsed(false);
				rightButton->Panel().SetCollapsed(false);
			}
		}

		void LayoutBeforeExpand() override
		{

		}

		void LayoutAfterExpand() override
		{

		}

		void NotifyAncestorChange()
		{
			optionIndex = ModulateOptionIndexToArrayIndex(optionIndex);
			dropDown->SignalButtonClick(optionIndex);
		}

		EGREventRouting OnChildEvent(GRWidgetEvent& we, IGRWidget& source) override
		{
			if (source == leftButton->Widget())
			{
				if (we.eventType == EGRWidgetEventType::BUTTON_CLICK)
				{
					optionIndex--;
					NotifyAncestorChange();
					NotifySelectionChanged(panel, EGRSelectionChangeOrigin::CarouselLRArrows);
				}

				return EGREventRouting::Terminate;
			}

			if (source == rightButton->Widget())
			{
				if (we.eventType == EGRWidgetEventType::BUTTON_CLICK)
				{
					optionIndex++;
					NotifyAncestorChange();
					NotifySelectionChanged(panel, EGRSelectionChangeOrigin::CarouselLRArrows);
				}

				return EGREventRouting::Terminate;
			}

			if (source == dropDown->Widget())
			{
				if (we.eventType == EGRWidgetEventType::BUTTON_CLICK_OUTSIDE)
				{
					CollapseDropDownAndNotify(we.clickPosition);
					return EGREventRouting::Terminate;
				}
			}

			if (we.eventType == EGRWidgetEventType::BUTTON_KEYPRESS_UP)
			{
				if (source.Panel().HasFocus())
				{
					switch (static_cast<IO::VirtualKeys::VKCode>(we.iMetaData))
					{
					case IO::VirtualKeys::VKCode_ESCAPE:
						CollapseDropDownAndNotify(Centre(panel.AbsRect()));
						panel.Parent()->FocusAndNotifyAncestors();
						return EGREventRouting::Terminate;
					}
				}
			}

			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnCursorMove(GRCursorEvent&) override
		{
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnKeyEvent(GRKeyEvent& ke) override
		{
			switch (ke.osKeyEvent.VKey)
			{
			case IO::VirtualKeys::VKCode_ESCAPE:
				if (ke.osKeyEvent.IsUp())
				{
					CollapseDropDownAndNotify({ 0,0 });
				}
				return EGREventRouting::Terminate;
			}

			return EGREventRouting::NextHandler;
		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		bool isCarouselDisabledWhenDropDownVisible = false;

		void SetDisableCarouselWhenDropDownVisible(bool isDisabledAccordingly) override
		{
			isCarouselDisabledWhenDropDownVisible = isDisabledAccordingly;
		}

		int ModulateOptionIndexToArrayIndex(int index)
		{
			int iOptionsSize = (int)options.size();

			while (index < 0)
			{
				index += iOptionsSize;
			}

			while (index >= iOptionsSize)
			{
				index -= iOptionsSize;
			}

			return index;
		}

		// The edge rect gives the rectangle that contains the carousel button text up to the 3D border, but not including the buttons either side
		GuiRect ComputeEdgeRect() const
		{
			GuiRect optionRect = panel.AbsRect();
			optionRect.left += optionPadding.left;
			optionRect.right -= optionPadding.right;
			optionRect.top += optionPadding.top;
			optionRect.bottom -= optionPadding.bottom;
			return optionRect;
		}

		void Render(IGRRenderContext& g) override
		{
			if (options.empty())
			{
				GRAlignmentFlags optionTextAlignment;
				optionTextAlignment.Add(EGRAlignment::HCentre).Add(EGRAlignment::VCentre);

				RGBAb colour = panel.GetColour(EGRSchemeColourSurface::CAROUSEL_TEXT, GRWidgetRenderState(0, 0, 0));
				g.DrawText(fontId, panel.AbsRect(), optionTextAlignment, { 0,0 }, "<no options>"_fstring, colour);
				return;
			}

			optionIndex = ModulateOptionIndexToArrayIndex(optionIndex);

			GuiRect edge = ComputeEdgeRect();
			
			auto& option = options[optionIndex];

			GRAlignmentFlags optionTextAlignment;
			optionTextAlignment.Add(EGRAlignment::HCentre).Add(EGRAlignment::VCentre).Add(EGRAlignment::AutoFonts);

			bool isDisabled = isCarouselDisabledWhenDropDownVisible && !dropDown->Panel().IsCollapsed();
			bool isHovered = IsPointInRect(g.CursorHoverPoint(), edge) && !isDisabled;
			GRWidgetRenderState rs(false, isHovered, false);

			bool obscured = DoesAncestorObscure(panel);

			RGBAb backColour = panel.GetColour(obscured ? EGRSchemeColourSurface::GAME_OPTION_DISABLED_BACKGROUND : EGRSchemeColourSurface::CAROUSEL_BACKGROUND, rs);
			g.DrawRect(edge, backColour, panel.RectStyle(), panel.CornerRadius());

			RGBAb colour = panel.GetColour(obscured ? EGRSchemeColourSurface::GAME_OPTION_DISABLED_TEXT : EGRSchemeColourSurface::CAROUSEL_TEXT, rs);
			g.DrawText(fontId, edge, optionTextAlignment, { 0,0 }, to_fstring(option.value), colour);

			if (!obscured)
			{
				RGBAb topLeftColour = panel.GetColour(EGRSchemeColourSurface::CAROUSEL_TOP_LEFT, rs);
				RGBAb bottomRightColour = panel.GetColour(EGRSchemeColourSurface::CAROUSEL_BOTTOM_RIGHT, rs);
				g.DrawRectEdge(edge, topLeftColour, bottomRightColour, panel.RectStyle(), panel.CornerRadius());
			}
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			auto result = Gui::QueryForParticularInterface<IGRWidgetLayout>(this, ppOutputArg, interfaceId);
			if (result == EGRQueryInterfaceResult::SUCCESS)
			{
				return result;
			}

			return Gui::QueryForParticularInterface<IGRWidgetCarousel, GRCarousel>(this, ppOutputArg, interfaceId);
		}

		IGRWidget& Widget()
		{
			return *this;
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRCarousel";
		}
	};

	struct GRCarouselFactory : IGRWidgetFactory
	{
		cstr leftImageRaised = nullptr;
		cstr rightImageRaised = nullptr;
		cstr leftImagePressed = nullptr;
		cstr rightImagePressed = nullptr;
		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			AutoFree<GRCarousel> newCarousel = new GRCarousel(panel);
			newCarousel->PostConstruct(leftImageRaised, rightImageRaised, leftImagePressed, rightImagePressed);
			return *newCarousel.Detach();
		}
	};
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetCarousel::InterfaceId()
	{
		return "IGRWidgetCarousel";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetCarousel& CreateCarousel(IGRWidget& parent, cstr leftImageRaised, cstr rightImageRaised, cstr leftImagePressed, cstr rightImagePressed)
	{
		auto& gr = parent.Panel().Root().GR();
		GRANON::GRCarouselFactory factory;
		factory.leftImageRaised = leftImageRaised;
		factory.rightImageRaised = rightImageRaised;
		factory.leftImagePressed = leftImagePressed;
		factory.rightImagePressed = rightImagePressed;
		auto& widget = gr.AddWidget(parent.Panel(), factory);
		auto* carousel = Cast<IGRWidgetCarousel>(widget);
		return *carousel;
	}

	ROCOCO_GUI_RETAINED_API bool DoesAncestorObscure(IGRPanel& descendant)
	{
		GRWidgetEvent ev;
		ev.clickPosition = { 0,0 };
		ev.eventType = EGRWidgetEventType::ARE_DESCENDANTS_OBSCURED;
		ev.iMetaData = 0; // ancestors will increment this if they need descendants to be obscured
		ev.isCppOnly = true;
		ev.panelId = descendant.Id();
		ev.sMetaData = nullptr;
		descendant.NotifyAncestors(ev, descendant.Widget());
		return ev.iMetaData > 0;
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.collapser.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>

#define ROCOCO_USE_SAFE_V_FORMAT
#include <rococo.strings.h>

#include <rococo.ui.h>
#include <rococo.vkeys.h>

using namespace Rococo;
using namespace Rococo::Gui;
using namespace Rococo::Strings;

namespace GRANON
{
	static const char* const defaultExpandPath = "$(COLLAPSER_EXPAND)";
	static const char* const defaultInlinePath = "$(COLLAPSER_COLLAPSE)";

	enum { TITLE_BAR_HEIGHT = 30 };

	struct GRCollapser : IGRWidgetCollapser, IGRWidgetSupervisor
	{
		IGRPanel& panel;
		IGRWidgetCollapserEvents& eventHandler;
		IGRWidgetButton* collapseButton = nullptr;
		IGRWidgetDivision* titleBar = nullptr;
		IGRWidgetDivision* clientArea = nullptr;
		IGRWidgetDivision* leftSpacer = nullptr;
		HString collapserExpandPath = defaultExpandPath;
		HString collapserInlinePath = defaultInlinePath;

		GRCollapser(IGRPanel& owningPanel, IGRWidgetCollapserEvents& _eventHandler) : panel(owningPanel), eventHandler(_eventHandler)
		{
			
		}

		virtual ~GRCollapser()
		{

		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		bool IsCollapsed() const override
		{
			return collapseButton ? !collapseButton->ButtonFlags().isRaised : false;
		}

		void SetExpandClientAreaImagePath(cstr path) override
		{
			if (path == nullptr || *path == 0)
			{
				collapserExpandPath = defaultExpandPath;
			}
			else
			{
				collapserExpandPath = path;
			}

			collapseButton->SetRaisedImagePath(collapserExpandPath);
		}

		void SetCollapsedToInlineImagePath(cstr path) override
		{
			if (path == nullptr || *path == 0)
			{
				collapserInlinePath = defaultInlinePath;
			}
			else
			{
				collapserInlinePath = path;
			}

			collapseButton->SetPressedImagePath(collapserInlinePath);
		}

		IGRWidgetDivision& ClientArea() override
		{
			return *clientArea;
		}

		IGRWidgetDivision& TitleBar() override
		{
			return *titleBar;
		}

		IGRWidgetDivision& LeftSpacer() override
		{
			return *leftSpacer;
		}

		IGRWidgetButton& CollapseButton() override
		{
			return *collapseButton;
		}

		void PostConstruct()
		{
			panel.SetLayoutDirection(ELayoutDirection::TopToBottom);

			titleBar = &CreateDivision(*this);
			titleBar->Panel().SetExpandToParentHorizontally();
			titleBar->Panel().SetConstantHeight(TITLE_BAR_HEIGHT);
			titleBar->Panel().SetLayoutDirection(ELayoutDirection::LeftToRight);
			titleBar->Panel().Set(GRAnchorPadding{ 0, 1, 0, 1 });

			clientArea = &CreateDivision(*this);
			clientArea->Panel().SetExpandToParentHorizontally();
			clientArea->Panel().SetExpandToParentVertically();

			leftSpacer = &CreateDivision(titleBar->Widget());
			leftSpacer->Panel().SetConstantWidth(0);
			leftSpacer->Panel().SetExpandToParentVertically();

			collapseButton = &CreateButton(titleBar->Widget());
			collapseButton->Widget().Panel().SetExpandToParentVertically();
			collapseButton->Widget().Panel().SetConstantWidth(TITLE_BAR_HEIGHT - 4);
			collapseButton->SetRaisedImagePath(collapserExpandPath);
			collapseButton->SetPressedImagePath(collapserInlinePath);
			collapseButton->SetEventPolicy(EGREventPolicy::NotifyAncestors);
			collapseButton->MakeToggleButton();
			collapseButton->SetStretchImage(true);
		}

		void Free() override
		{
			delete this;
		}

		EGREventRouting OnCursorClick(GRCursorEvent& ce) override
		{
			if (ce.click.LeftButtonUp)
			{
				panel.FocusAndNotifyAncestors();
				return EGREventRouting::Terminate;
			}
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnCursorMove(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{

		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		void Render(IGRRenderContext&) override
		{
		}

		void SyncCollapseStateToButton()
		{
			if (IsCollapsed())
			{
				eventHandler.OnCollapserInlined(*this);
			}
			else
			{
				eventHandler.OnCollapserExpanded(*this);
			}
		}

		EGREventRouting OnChildEvent(GRWidgetEvent&, IGRWidget& sourceWidget)
		{
			if (sourceWidget.Panel().Id() == collapseButton->Widget().Panel().Id())
			{
				SyncCollapseStateToButton();
				return EGREventRouting::Terminate;
			}
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnKeyEvent(GRKeyEvent& keyEvent) override
		{
			switch (keyEvent.osKeyEvent.VKey)
			{
			case IO::VirtualKeys::VKCode_ENTER:
				if (keyEvent.osKeyEvent.IsUp())
				{
					if (panel.HasFocus())
					{
						auto* child = clientArea->Panel().GetChild(0);
						TrySetDeepFocus(*child);
					}
				}
				return EGREventRouting::Terminate;
			case IO::VirtualKeys::VKCode_SPACEBAR:
				if (keyEvent.osKeyEvent.IsUp())
				{
					if (panel.HasFocus())
					{
						collapseButton->Toggle();
						SyncCollapseStateToButton();
					}
				}				
				return EGREventRouting::Terminate;				
			}
			return collapseButton->Widget().Manager().OnKeyEvent(keyEvent);
		}

		IGRWidget& Widget()
		{
			return *this;
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			GRCollapser* instance = (GRCollapser*)this;
			return Gui::QueryForParticularInterface<IGRWidgetCollapser, GRCollapser>(instance, ppOutputArg, interfaceId);
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRCollapser";
		}
	};

	struct GRCollapserFactory : IGRWidgetFactory
	{
		IGRWidgetCollapserEvents& eventHandler;

		GRCollapserFactory(IGRWidgetCollapserEvents& _eventHandler): eventHandler(_eventHandler)
		{

		}

		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			return *new GRCollapser(panel, eventHandler);
		}
	};
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetCollapser::InterfaceId()
	{
		return "IGRWidgetCollapser";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetCollapser& CreateCollapser(IGRWidget& parent, IGRWidgetCollapserEvents& eventHandler)
	{
		auto& gr = parent.Panel().Root().GR();

		GRANON::GRCollapserFactory factory(eventHandler);
		auto& collapser = static_cast<GRANON::GRCollapser&>(gr.AddWidget(parent.Panel(), factory));
		collapser.PostConstruct();
		return collapser;
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.control-prompt.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <rococo.strings.h>
#include <rococo.hashtable.h>
#include <vector>

using namespace Rococo;
using namespace Rococo::Gui;
using namespace Rococo::Strings;

namespace GRANON
{
	struct GRControlPrompt : IGRWidgetControlPrompt, IGRWidgetSupervisor
	{
		IGRPanel& panel;

		float transparency = 1.0f;

		GRControlPrompt(IGRPanel& owningPanel) : panel(owningPanel)
		{
			alignment.Add(EGRAlignment::Left).Add(EGRAlignment::VCentre);
		}

		virtual ~GRControlPrompt()
		{

		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		IGRWidget& Widget() override
		{
			return *this;
		}

		void SetTransparency(float f) override
		{
			transparency = clamp(f, 0.0f, 1.0f);
		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		void Free() override
		{
			delete this;
		}

		EGREventRouting OnCursorClick(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnCursorMove(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{

		}

		GRFontId fontId = GRFontId::NONE;
		GRAnchorPadding padding{ 2,2,2,2 };
		int cellPadding = 2;

		int EvaluateRenderWidth(IGRRenderContext& g)
		{
			cstr controlType = GetCustodian(panel).GetLastKnownControlType();

			GuiRect textRect = panel.AbsRect();

			for (auto& p : prompts)
			{
				char fqKey[128];
				SafeFormat(fqKey, "%s.%s", p.iconId.c_str(), controlType);
				auto i = pathToImage.find(fqKey);
				if (i != pathToImage.end())
				{
					auto* image = i->second.image;
					if (image)
					{
						Vec2i imageSpan = image->Span();
						double aspectRatio = imageSpan.y != 0 ? imageSpan.x / (double)imageSpan.y : 0;

						GuiRect imageRect = textRect;
						imageRect.top += i->second.vPadding;
						imageRect.bottom -= i->second.vPadding;
						imageRect.right = imageRect.left + (int)aspectRatio * Height(imageRect);
						textRect.left = imageRect.right;

						Vec2i textSpan = g.Fonts().EvaluateMinimalSpan(fontId, p.text.to_fstring(), { 0,0 });
						textRect.left += cellPadding;
						textRect.right = textRect.left + textSpan.x;
						textRect.left = textRect.right;
					}
				}
			}

			return textRect.right - panel.AbsRect().left;
		}

		void RenderPrompts(IGRRenderContext& g, int leftPos)
		{
			cstr controlType = GetCustodian(panel).GetLastKnownControlType();

			GuiRect textRect = panel.AbsRect();

			textRect.left = leftPos;

			for (auto& p : prompts)
			{
				char fqKey[128];
				SafeFormat(fqKey, "%s.%s", p.iconId.c_str(), controlType);
				auto i = pathToImage.find(fqKey);
				if (i != pathToImage.end())
				{
					auto* image = i->second.image;
					if (image)
					{
						Vec2i imageSpan = image->Span();
						double aspectRatio = imageSpan.y != 0 ? imageSpan.x / (double)imageSpan.y : 0;

						GuiRect imageRect = textRect;
						imageRect.top += i->second.vPadding;
						imageRect.bottom -= i->second.vPadding;
						imageRect.right = imageRect.left + (int)aspectRatio * Height(imageRect);
						g.DrawImageStretched(*image, imageRect);
						textRect.left = imageRect.right;

						Vec2i textSpan = g.Fonts().EvaluateMinimalSpan(fontId, p.text.to_fstring(), {0,0});
						textRect.left += cellPadding;
						textRect.right = textRect.left + textSpan.x;
						
						GuiRect shadowRect = { textRect.left + 1, textRect.top + 1, textRect.right + 1, textRect.bottom + 1 };
						g.DrawText(fontId, shadowRect, alignment, { 0,0 }, p.text.to_fstring(), RGBAb(0, 0, 0));
						g.DrawText(fontId, textRect, alignment, { 0,0 }, p.text.to_fstring(), RGBAb(255, 255, 255));
						textRect.left = textRect.right;
					}
				}
			}
		}

		void Render(IGRRenderContext& g) override
		{
			DrawPanelBackgroundEx(
				panel,
				g, 
				EGRSchemeColourSurface::CONTAINER_BACKGROUND,
				EGRSchemeColourSurface::CONTAINER_TOP_LEFT,
				EGRSchemeColourSurface::CONTAINER_BOTTOM_RIGHT,
				transparency
			);

			if (alignment.HasSomeFlags(EGRAlignment::Left) && !alignment.HasSomeFlags(EGRAlignment::Right))
			{
				RenderPrompts(g, panel.AbsRect().left);
			}
			else if (!alignment.HasSomeFlags(EGRAlignment::Left) && alignment.HasSomeFlags(EGRAlignment::Right))
			{
				int renderWidth = EvaluateRenderWidth(g);
				RenderPrompts(g, panel.AbsRect().right - renderWidth);
			}
		}

		EGREventRouting OnChildEvent(GRWidgetEvent&, IGRWidget&)
		{
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnKeyEvent(GRKeyEvent&) override
		{
			return EGREventRouting::NextHandler;
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			return QueryForParticularInterface<IGRWidgetControlPrompt>(this, ppOutputArg, interfaceId);
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRControlPrompt";
		}

		struct Prompt
		{
			HString iconId;
			HString text;
		};

		struct ImageInfo
		{
			HString imagePath;
			IGRImage* image = nullptr;
			int vPadding = 0;
		};

		stringmap<ImageInfo> pathToImage;

		std::vector<Prompt> prompts;

		void AddIcon(cstr iconId, cstr controlType, int vpadding, cstr imagePath) override
		{
			char fqKey[128];
			SafeFormat(fqKey, "%s.%s", iconId, controlType);

			ImageInfo img;
			img.imagePath = imagePath;
			img.image = GetCustodian(panel).CreateImageFromPath(fqKey, imagePath);
			img.vPadding = vpadding;
			pathToImage[fqKey] = img;
		}

		void AddPrompt(cstr iconId, cstr text) override
		{
			prompts.emplace_back(Prompt { iconId, text });
		}

		GRAlignmentFlags alignment;

		void SetAlignment(GRAlignmentFlags alignment) override
		{
			this->alignment = alignment;
		}

		void SetFont(GRFontId fontId) override
		{
			this->fontId = fontId;
		}
	};

	struct GRPromptFactory : IGRWidgetFactory
	{
		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			return *new GRControlPrompt(panel);
		}
	};
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetControlPrompt::InterfaceId()
	{
		return "IGRWidgetControlPrompt";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetControlPrompt& CreateControlPrompt(IGRWidget& parent)
	{
		auto& gr = parent.Panel().Root().GR();
		GRANON::GRPromptFactory factory;
		auto& div = static_cast<GRANON::GRControlPrompt&>(gr.AddWidget(parent.Panel(), factory));
		return div;
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.division.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <rococo.strings.h>

using namespace Rococo;
using namespace Rococo::Gui;
using namespace Rococo::Strings;

namespace GRANON
{
	struct GRDivision : IGRWidgetDivision, IGRWidgetSupervisor
	{
		IGRPanel& panel;

		float transparency = 1.0f;

		GRDivision(IGRPanel& owningPanel) : panel(owningPanel)
		{
		}

		virtual ~GRDivision()
		{

		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		IGRWidget& Widget() override
		{
			return *this;
		}

		void SetTransparency(float f) override
		{
			transparency = clamp(f, 0.0f, 1.0f);
		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		void Free() override
		{
			delete this;
		}

		EGREventRouting OnCursorClick(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnCursorMove(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{

		}

		void Render(IGRRenderContext& g) override
		{
			DrawPanelBackgroundEx(
				panel,
				g, 
				EGRSchemeColourSurface::CONTAINER_BACKGROUND,
				EGRSchemeColourSurface::CONTAINER_TOP_LEFT,
				EGRSchemeColourSurface::CONTAINER_BOTTOM_RIGHT,
				transparency
			);
		}

		EGREventRouting OnChildEvent(GRWidgetEvent&, IGRWidget&)
		{
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnKeyEvent(GRKeyEvent&) override
		{
			return EGREventRouting::NextHandler;
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			return QueryForParticularInterface<IGRWidgetDivision>(this, ppOutputArg, interfaceId);
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRDivision";
		}
	};

	struct GRDivFactory : IGRWidgetFactory
	{
		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			return *new GRDivision(panel);
		}
	} s_DivFactory;
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetDivision::InterfaceId()
	{
		return "IGRWidgetDivision";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetDivision& CreateDivision(IGRWidget& parent)
	{
		auto& gr = parent.Panel().Root().GR();
		auto& div = static_cast<GRANON::GRDivision&>(gr.AddWidget(parent.Panel(), GRANON::s_DivFactory));
		return div;
	}

	RGBAb Modulate(RGBAb colour, float alphaScale)
	{
		float alpha = clamp(alphaScale * (float)colour.alpha, 0.0f, 255.0f);
		return RGBAb(colour.red, colour.green, colour.blue, (uint8)alpha);
	}

	ROCOCO_GUI_RETAINED_API void DrawPanelBackgroundEx(
		IGRPanel& panel, 
		IGRRenderContext& g,
		EGRSchemeColourSurface back, 
		EGRSchemeColourSurface leftEdge,
		EGRSchemeColourSurface rightEdge, 
		float alphaScale,
		bool isRaised,
		bool isFocused)
	{
		auto rect = panel.AbsRect();

		GRWidgetRenderState rs(!isRaised, g.IsHovered(panel), isFocused);

		RGBAb backColour = panel.GetColour(back, rs);
		g.DrawRect(rect, Modulate(backColour, alphaScale), panel.RectStyle(), panel.CornerRadius());

		RGBAb edge1Colour = panel.GetColour(leftEdge, rs);
		RGBAb edge2Colour = panel.GetColour(rightEdge, rs);
		g.DrawRectEdge(rect, Modulate(edge1Colour, alphaScale), Modulate(edge2Colour, alphaScale), panel.RectStyle(), panel.CornerRadius());
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.editbox.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <vector>
#include <rococo.strings.h>

#include <rococo.os.h> // For clipboard functions
#include <rococo.ui.h>
#include <rococo.vkeys.h>

using namespace Rococo;
using namespace Rococo::Gui;
using namespace Rococo::Strings;

namespace GRANON
{
	struct GREditBox : IGRWidgetEditBox, IGREditorMicromanager, IGRWidgetSupervisor
	{
		IGRPanel& panel;
		std::vector<char> text;
		GRFontId fontId;
		GRAlignmentFlags alignment;
		Vec2i spacing{ 0,0 };
		int32 caretPos = 0;
		int32 updateLock = 0;
		IGREditFilter* filter;
		bool skipTab = false;

		struct UpdateLock
		{
			GREditBox* This;

			UpdateLock(GREditBox* _This) : This(_This)
			{
				This->updateLock++;
			}

			~UpdateLock()
			{
				This->updateLock--;
			}
		};

		GREditBox(IGRPanel& owningPanel, IGREditFilter* _filter, int32 capacity, GRFontId _fontId) : panel(owningPanel), fontId(_fontId), filter(_filter)
		{
			text.reserve(capacity);
			owningPanel.Add(EGRPanelFlags::AcceptsFocus);
		}

		virtual ~GREditBox()
		{
		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		void Free() override
		{
			delete this;
		}

		int32 CaretPos() const override
		{
			return caretPos;
		}

		void OnUpdate(EGREditorEventType editorEventType)
		{
			if (updateLock > 0)
			{
				// Prevent recursion
				return;
			}

			if (filter) filter->OnUpdate(*this, *this);

			UpdateLock lock(this);

			GRWidgetEvent_EditorUpdated we;
			we.eventType = EGRWidgetEventType::EDITOR_UPDATED;
			we.iMetaData = iMetaData;
			we.sMetaData = sMetaData.c_str();
			we.panelId = panel.Id();	
			we.editor = this;
			we.manager = this;
			we.caretPos = caretPos;
			we.editorEventType = editorEventType;
			we.clickPosition = { 0,0 };

			panel.RouteToParent(we);
		}

		bool preppingSelect = false;

		EGREventRouting OnCursorClick(GRCursorEvent& ce) override
		{
			if (ce.click.LeftButtonDown)
			{
				preppingSelect = true;
				return EGREventRouting::Terminate;
			}
			else if (ce.click.LeftButtonUp && preppingSelect)
			{
				if (panel.Root().GR().GetFocusId() == panel.Id())
				{
					panel.Root().GR().SetFocus(-1);
					OnUpdate(EGREditorEventType::LostFocus);
				}
				else
				{
					panel.FocusAndNotifyAncestors();

					if (!isReadOnly)
					{
						OnUpdate(EGREditorEventType::ClickFocused);
					}
				}
				return EGREventRouting::Terminate;
			}

			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnCursorMove(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{
			preppingSelect = false;
		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		void AddToCaretPos(int32 delta) override
		{
			caretPos = clamp(caretPos + delta, 0, (int32) (text.size() - 1));
		}

		void AppendCharAtCaret(char c) override
		{
			if (text.size() < text.capacity())
			{
				if (caretPos >= text.size() - 1)
				{
					text.back() = c;
					text.push_back(0);
				}
				else
				{
					auto i = text.begin();
					std::advance(i, caretPos);
					text.insert(i, c);
				}

				caretPos++;

				OnUpdate(EGREditorEventType::CharAppended);
			}
		}

		void BackspaceAtCaret() override
		{
			if (caretPos > 0 && text.size() > 1)
			{
				if (caretPos >= text.size() - 1)
				{
					text.pop_back();
					text.back() = 0;
				}
				else
				{
					auto i = text.begin();
					std::advance(i, caretPos-1);
					text.erase(i);
				}

				caretPos--;		

				OnUpdate(EGREditorEventType::CharBackspaced);
			}
		}

		void DeleteAtCaret() override
		{
			if (text.size() > 1)
			{
				if (caretPos >= text.size() - 1)
				{
					return;
				}
				else
				{
					auto i = text.begin();
					std::advance(i, caretPos);
					text.erase(i);

					OnUpdate(EGREditorEventType::CharDeleted);
				}
			}
		}

		bool prepReturn = false;

		void Return() override
		{
			prepReturn = true;
		}

		void Render(IGRRenderContext& g) override
		{
			auto rect = panel.AbsRect();

			GRWidgetRenderState rs(false, g.IsHovered(panel), panel.Id() == panel.Root().GR().GetFocusId());

			RGBAb editorColour = panel.GetColour(isReadOnly ? EGRSchemeColourSurface::LABEL_BACKGROUND : EGRSchemeColourSurface::EDITOR, rs, RGBAb(0, 0, 0, 225));

			g.DrawRect(rect, editorColour);
			g.DrawRectEdge(rect, panel.GetColour(EGRSchemeColourSurface::CONTAINER_TOP_LEFT, rs, RGBAb(0, 0, 0, 225)), panel.GetColour(EGRSchemeColourSurface::CONTAINER_BOTTOM_RIGHT, rs, RGBAb(0, 0, 0, 225)));

			if (!rs.value.bitValues.focused || isReadOnly)
			{
				if (text.size() > 0)
				{
					EGRSchemeColourSurface surface = isReadOnly ? EGRSchemeColourSurface::READ_ONLY_TEXT : EGRSchemeColourSurface::TEXT;
					g.DrawText(fontId, rect, alignment, spacing, { text.data(), (int32)text.size() - 1 }, panel.GetColour(surface, rs));
				}
			}
			else
			{
				RGBAb textColour = panel.GetColour(EGRSchemeColourSurface::EDIT_TEXT, rs);

				CaretSpec caret;
				caret.IsInserting = true;
				caret.CaretPos = caretPos;
				caret.BlinksPerSecond = 2;
				caret.CaretColour1 = textColour;
				caret.CaretColour2 = editorColour;

				int height = panel.Root().GR().Fonts().GetFontHeight(fontId);
				if (height > 20)
				{
					caret.LineThickness = 3;
				}

				g.DrawEditableText(fontId, rect, alignment, spacing, { text.data(), (int32)text.size() - 1 }, textColour, caret);
			}
		}

		EGREventRouting OnChildEvent(GRWidgetEvent&, IGRWidget&)
		{
			return EGREventRouting::NextHandler;
		}

		bool MoveFocusToNextTargetOrNextSiblingOrAncestorThatAcceptsFocus(IGRWidget& focusWidget)
		{
			auto* targetPanel = panel.Navigate(EGRNavigationDirection::Down);
			if (targetPanel && TrySetDeepFocus(*targetPanel))
			{
				return true;
			}

			auto* parent = focusWidget.Panel().Parent();
			if (!parent)
			{
				// No siblings
				return false;
			}

			int i = 0;
			for (;;)
			{
				auto* sibling = parent->GetChild(i);
				if (!sibling)
				{
					// Unexpected - we expect the parent to have at least 1 child - this widget
					break;
				}

				if (sibling == &focusWidget.Panel())
				{
					auto* nextSibling = parent->GetChild(i + 1);
					if (nextSibling)
					{
						if (TrySetDeepFocus(*nextSibling))
						{
							return true;
						}
					}
					else
					{
						break;
					}
				}
				i++;
			}

			for (auto* candidate = parent; candidate != nullptr; candidate = candidate->Parent())
			{
				if (candidate->HasFlag(EGRPanelFlags::AcceptsFocus))
				{
					candidate->FocusAndNotifyAncestors();
					return true;
				}
			}

			auto* frame = FindOwner(parent->Widget());

			// Last ditch attempt to preserve a focus
			auto* newFocus = TrySetDeepFocus(frame->Panel());

			return newFocus != nullptr;
		}

		EGREventRouting OnKeyEvent(GRKeyEvent& keyEvent) override		
		{
			if (panel.HasFocus())
			{
				if (keyEvent.osKeyEvent.IsUp())
				{
					switch (keyEvent.osKeyEvent.VKey)
					{
					case IO::VirtualKeys::VKCode_ENTER:
						if (prepReturn)
						{
							prepReturn = false;

							MoveFocusToNextTargetOrNextSiblingOrAncestorThatAcceptsFocus(*this);

							if (!panel.HasFocus())
							{
								OnUpdate(EGREditorEventType::LostFocus);
							}

							return EGREventRouting::Terminate;
						}
					}
				}
				else
				{
					switch (keyEvent.osKeyEvent.VKey)
					{
					case IO::VirtualKeys::VKCode_TAB:
						if (skipTab)
						{
							return EGREventRouting::NextHandler;
						}
					}
				}
			}

			if (!isReadOnly)
			{
				return panel.Root().Custodian().TranslateToEditor(keyEvent, *this);
			}
			else
			{
				if (keyEvent.osKeyEvent.VKey == IO::VirtualKeys::VKCode_ENTER && !keyEvent.osKeyEvent.IsUp())
				{
					Return();
					return EGREventRouting::NextHandler;
				}
			}
			return EGREventRouting::NextHandler;
		}

		IGRWidgetEditBox& SetAlignment(GRAlignmentFlags alignment, Vec2i spacing) override
		{
			this->alignment = alignment;
			this->spacing = spacing;
			return *this;
		}

		IGRWidgetEditBox& SetFont(GRFontId fontId) override
		{
			this->fontId = fontId;
			return *this;
		}

		int64 iMetaData = 0;
		HString sMetaData;

		IGRWidgetEditBox& SetMetaData(const GRControlMetaData& metaData)
		{
			if (updateLock > 0)
			{
				RaiseError(panel, EGRErrorCode::RecursionLocked, __ROCOCO_FUNCTION__, "It is forbidden to set meta data of an edit box in the context of an update to the edit box");
				return *this;
			}

			iMetaData = metaData.intData;
			sMetaData = metaData.stringData ? metaData.stringData : "";
			return *this;
		}

		void SetText(cstr argText) override
		{
			if (argText == nullptr)
			{
				argText = "";
			}

			size_t len = strlen(argText);

			size_t newSize = min(len + 1, text.capacity());
			text.resize(newSize);

			SafeFormat(text.data(), text.capacity(), "%s", argText);

			caretPos = (int32) len;

			OnUpdate(EGREditorEventType::SetText);
		}

		size_t Capacity() const override
		{
			return (int32) text.capacity();
		}

		bool isReadOnly = false;

		int32 GetTextAndLength(char* buffer, int32 capacity) const override
		{
			if (buffer != nullptr && capacity > 0)
			{
				SafeFormat(buffer, capacity, "%s", text.data());
			}

			return (int32) text.size();
		}

		bool IsEditing() const
		{
			return panel.HasFocus() && !isReadOnly;
		}

		IGRWidgetEditBox& SetReadOnly(bool isReadOnly) override
		{
			this->isReadOnly = isReadOnly;
			return *this;
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			return Gui::QueryForParticularInterface<IGRWidgetEditBox>(this, ppOutputArg, interfaceId);
		}

		IGRWidget& Widget() override
		{
			return *this;
		}

		cstr GetImplementationTypeName() const override
		{
			return "GREditBox";
		}
	};

	struct GREditBoxFactory : IGRWidgetFactory
	{
		IGREditFilter* filter;
		int32 capacity;
		GRFontId fontId;

		GREditBoxFactory(IGREditFilter* _filter, int32 _capacity, GRFontId _fontId): filter(_filter), capacity(_capacity), fontId(_fontId)
		{

		}

		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			return *new GREditBox(panel, filter, capacity, fontId);
		}
	};
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetEditBox::InterfaceId()
	{
		return "IGRWidgetEditBox";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetEditBox& CreateEditBox(IGRWidget& parent, IGREditFilter* filter, int32 capacity, GRFontId fontId)
	{
		if (capacity <= 2)
		{
			RaiseError(parent.Panel(), EGRErrorCode::InvalidArg, __ROCOCO_FUNCTION__, "Capacity should be >= 2");
		}
		else
		{
			capacity = (int32) EGRPaths::MAX_FULL_PATH_LENGTH;
		}

		if (capacity > 1024_megabytes)
		{
			RaiseError(parent.Panel(), EGRErrorCode::InvalidArg, __ROCOCO_FUNCTION__, "Capacity should be <= 1 gigabyte");
			capacity = (int32) 1024_megabytes;
		}

		GRANON::GREditBoxFactory factory(filter, capacity, fontId);

		auto& gr = parent.Panel().Root().GR();
		auto* editor = Cast<IGRWidgetEditBox>(gr.AddWidget(parent.Panel(), factory));
		return *editor;
	}

	ROCOCO_GUI_RETAINED_API IGREditFilter& GetF32Filter()
	{
		struct F32Filter : IGREditFilter
		{
			std::vector<char> scratchBuffer;

			F32Filter()
			{
				scratchBuffer.reserve(12);
			}

			void Free() override
			{

			}

			void OnUpdate(IGRWidgetEditBox& editor, IGREditorMicromanager& manager)
			{
				scratchBuffer.clear();

				char buffer[12];
				int32 len = editor.GetTextAndLength(buffer, sizeof(buffer));

				int32 originalLength = len;

				if (len >= 12)
				{
					len = 11;
					buffer[11] = 0;
				}

				int32 caretPos = manager.CaretPos();

				bool hasPoint = false;

				if (len > 0)
				{
					switch (buffer[0])
					{
					case '-':
					case '+':
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						scratchBuffer.push_back(buffer[0]);
						break;
					case '.':
						hasPoint = true;
						scratchBuffer.push_back('.');
						break;
					}
				}

				for (int32 i = 1; i < len; ++i)
				{
					char c = buffer[i];
					if (c >= '0' && c <= '9')
					{
						scratchBuffer.push_back(buffer[i]);
					}
					else if (!hasPoint && c == '.')
					{
						scratchBuffer.push_back('.');
						hasPoint = true;
					}
				}

				scratchBuffer.push_back(0);

				int32 newLength = (int32)scratchBuffer.size();

				int32 lengthDelta = originalLength - newLength;

				if (lengthDelta != 0)
				{
					// This sets the caret pos to the null char
					editor.SetText(scratchBuffer.data());

					// Now the caret position is set to zero
					manager.AddToCaretPos(-10000);

					manager.AddToCaretPos(caretPos - lengthDelta);
				}
			}
		};

		static F32Filter s_F32Editor;
		return s_F32Editor;
	}

	ROCOCO_GUI_RETAINED_API IGREditFilter& GetF64Filter()
	{
		struct F64Filter : IGREditFilter
		{
			std::vector<char> scratchBuffer;

			F64Filter()
			{
				scratchBuffer.reserve(24);
			}

			void Free() override
			{

			}

			void OnUpdate(IGRWidgetEditBox& editor, IGREditorMicromanager& manager)
			{
				scratchBuffer.clear();

				char buffer[24];
				int32 len = editor.GetTextAndLength(buffer, sizeof(buffer));

				int32 originalLength = len;

				if (len >= 24)
				{
					len = 23;
					buffer[23] = 0;
				}

				int32 caretPos = manager.CaretPos();

				bool hasPoint = false;

				if (len > 0)
				{
					switch (buffer[0])
					{
					case '-':
					case '+':
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						scratchBuffer.push_back(buffer[0]);
						break;
					case '.':
						hasPoint = true;
						scratchBuffer.push_back('.');
						break;
					}
				}

				for (int32 i = 1; i < len; ++i)
				{
					char c = buffer[i];
					if (c >= '0' && c <= '9')
					{
						scratchBuffer.push_back(buffer[i]);
					}
					else if (!hasPoint && c == '.')
					{
						scratchBuffer.push_back('.');
						hasPoint = true;
					}
				}

				scratchBuffer.push_back(0);

				int32 newLength = (int32)scratchBuffer.size();

				int32 lengthDelta = originalLength - newLength;

				if (lengthDelta != 0)
				{
					// This sets the caret pos to the null char
					editor.SetText(scratchBuffer.data());

					// Now the caret position is set to zero
					manager.AddToCaretPos(-10000);

					manager.AddToCaretPos(caretPos - lengthDelta);
				}
			}
		};

		static F64Filter s_F64Editor;
		return s_F64Editor;
	}

	ROCOCO_GUI_RETAINED_API IGREditFilter& GetI32Filter()
	{
		struct I32Filter : IGREditFilter
		{
			std::vector<char> scratchBuffer;

			I32Filter()
			{
				scratchBuffer.reserve(12);
			}

			void Free() override
			{

			}

			void OnUpdate(IGRWidgetEditBox& editor, IGREditorMicromanager& manager)
			{
				scratchBuffer.clear();

				char buffer[16];
				int32 len = editor.GetTextAndLength(buffer, sizeof(buffer));

				int32 originalLength = len;

				if (len >= 15)
				{
					len = 14;
					buffer[14] = 0;
				}

				if (len > 0)
				{
					switch (buffer[0])
					{
					case '-':
					case '+':
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						scratchBuffer.push_back(buffer[0]);
						break;
					}
				}

				for (int32 i = 1; i < len; ++i)
				{
					char c = buffer[i];
					if (c == ',' && !editor.IsEditing())
					{ 
						scratchBuffer.push_back(',');
					}
					else if (c >= '0' && c <= '9')
					{
						scratchBuffer.push_back(buffer[i]);
					}
				}

				scratchBuffer.push_back(0);

				int32 caretPos = manager.CaretPos();

				int32 newLength = (int32)scratchBuffer.size();

				int32 lengthDelta = originalLength - newLength;

				if (lengthDelta != 0)
				{
					// This sets the caret pos to the null char
					editor.SetText(scratchBuffer.data());

					// Now the caret position is set to zero
					manager.AddToCaretPos(-10000);

					manager.AddToCaretPos(caretPos - lengthDelta);
				}
			}
		};
		
		static I32Filter s_I32Editor;
		return s_I32Editor;
	}

	ROCOCO_GUI_RETAINED_API IGREditFilter& GetI64Filter()
	{
		struct I64Filter : IGREditFilter
		{
			std::vector<char> scratchBuffer;

			I64Filter()
			{
				scratchBuffer.reserve(24);
			}

			void Free() override
			{

			}

			void OnUpdate(IGRWidgetEditBox& editor, IGREditorMicromanager& manager)
			{
				scratchBuffer.clear();

				char buffer[24];
				int32 len = editor.GetTextAndLength(buffer, sizeof(buffer));

				int32 originalLength = len;

				if (len >= 24)
				{
					len = 23;
					buffer[23] = 0;
				}

				if (len > 0)
				{
					switch (buffer[0])
					{
					case '-':
					case '+':
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						scratchBuffer.push_back(buffer[0]);
						break;
					}
				}

				for (int32 i = 1; i < len; ++i)
				{
					char c = buffer[i];
					if (c >= '0' && c <= '9')
					{
						scratchBuffer.push_back(buffer[i]);
					}
				}

				scratchBuffer.push_back(0);

				int32 caretPos = manager.CaretPos();

				int32 newLength = (int32)scratchBuffer.size();

				int32 lengthDelta = originalLength - newLength;

				if (lengthDelta != 0)
				{
					// This sets the caret pos to the null char
					editor.SetText(scratchBuffer.data());

					// Now the caret position is set to zero
					manager.AddToCaretPos(-10000);

					manager.AddToCaretPos(caretPos - lengthDelta);
				}
			}
		};

		static I64Filter s_I64Editor;
		return s_I64Editor;
	}

	ROCOCO_GUI_RETAINED_API IGREditFilter& GetUnsignedFilter()
	{
		struct UnsignedFilter : IGREditFilter
		{
			std::vector<char> scratchBuffer;

			UnsignedFilter()
			{
				scratchBuffer.reserve(24);
			}

			void Free() override
			{

			}

			void OnUpdate(IGRWidgetEditBox& editor, IGREditorMicromanager& manager)
			{
				scratchBuffer.clear();

				char buffer[24];
				int32 len = editor.GetTextAndLength(buffer, sizeof(buffer));

				int32 originalLength = len;

				if (len >= 24)
				{
					len = 23;
					buffer[23] = 0;
				}

				for (int32 i = 0; i < len; ++i)
				{
					char c = buffer[i];
					if (c >= '0' && c <= '9')
					{
						scratchBuffer.push_back(buffer[i]);
					}
				}

				scratchBuffer.push_back(0);

				int32 caretPos = manager.CaretPos();

				int32 newLength = (int32)scratchBuffer.size();

				int32 lengthDelta = originalLength - newLength;

				if (lengthDelta != 0)
				{
					// This sets the caret pos to the null char
					editor.SetText(scratchBuffer.data());

					// Now the caret position is set to zero
					manager.AddToCaretPos(-10000);

					manager.AddToCaretPos(caretPos - lengthDelta);
				}
			}
		};

		static UnsignedFilter s_UnsignedFilter;
		return s_UnsignedFilter;
	}

	ROCOCO_GUI_RETAINED_API EGREventRouting TranslateToEditor(Windows::IWindow& ownerWindow, const GRKeyEvent& keyEvent, IGREditorMicromanager& manager, ICharBuilder& builder)
	{
		if (!keyEvent.osKeyEvent.IsUp())
		{
			switch (keyEvent.osKeyEvent.VKey)
			{
			case IO::VirtualKeys::VKCode_BACKSPACE:
				manager.BackspaceAtCaret();
				return EGREventRouting::Terminate;
			case IO::VirtualKeys::VKCode_DELETE:
				manager.DeleteAtCaret();
				return EGREventRouting::Terminate;
			case IO::VirtualKeys::VKCode_ENTER:
				manager.Return();
				return EGREventRouting::Terminate;
			case IO::VirtualKeys::VKCode_LEFT:
				manager.AddToCaretPos(-1);
				return EGREventRouting::Terminate;
			case IO::VirtualKeys::VKCode_RIGHT:
				manager.AddToCaretPos(1);
				return EGREventRouting::Terminate;
			case IO::VirtualKeys::VKCode_HOME:
				manager.AddToCaretPos(-100'000'000);
				return EGREventRouting::Terminate;
			case IO::VirtualKeys::VKCode_END:
				manager.AddToCaretPos(100'000'000);
				return EGREventRouting::Terminate;
			case IO::VirtualKeys::VKCode_C:
				if (keyEvent.context.isCtrlHeld)
				{
					// Note that GetTextAndLength is guaranteed to be at least one character, and if so, the one character is the nul terminating the string
					builder.Resize(manager.GetTextAndLength(nullptr, 0));
					manager.GetTextAndLength(builder.WriteBuffer(), (int32)builder.Size());
					Rococo::OS::SaveClipBoardText(builder.c_str(), ownerWindow);
					builder.Clear();
					return EGREventRouting::Terminate;
				}
				else
				{
					break;
				}
			case IO::VirtualKeys::VKCode_V:
				if (keyEvent.context.isCtrlHeld)
				{
					manager.GetTextAndLength(builder.WriteBuffer(), (int32)builder.Size());

					struct : Strings::IStringPopulator
					{
						IGREditorMicromanager* manager = nullptr;
						void Populate(cstr text) override
						{
							for (cstr p = text; *p != 0; p++)
							{
								manager->AppendCharAtCaret(*p);
							}
						}
					} cb;
					cb.manager = &manager;
					Rococo::OS::PasteStringFromClipboard(cb);
					return EGREventRouting::Terminate;
				}
				else
				{
					break;
				}
			}

			if (keyEvent.osKeyEvent.unicode >= 32 && keyEvent.osKeyEvent.unicode <= 127)
			{
				manager.AppendCharAtCaret((char)keyEvent.osKeyEvent.unicode);
				return EGREventRouting::Terminate;
			}
		}

		return EGREventRouting::NextHandler;
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.game-options.bool.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <rococo.game.options.h>
#include <rococo.strings.h>
#include <rococo.ui.h>
#include <rococo.vkeys.h>

using namespace Rococo;
using namespace Rococo::Gui;
using namespace Rococo::Game::Options;
using namespace Rococo::Strings;

namespace GRANON
{
	struct GRGameOptionsBoolWidget : IGRWidgetGameOptionsBool, IGRWidgetSupervisor, IBoolInquiry, IGRWidgetLayout
	{
		IGRPanel& panel;
		IGRWidgetText* title = nullptr;
		IGRWidgetButton* button = nullptr;

		GameOptionConfig config;

		GRGameOptionsBoolWidget(IGRPanel& _panel) : panel(_panel)
		{
			_panel.SetLayoutDirection(ELayoutDirection::TopToBottom);
			_panel.Add(EGRPanelFlags::AcceptsFocus);
			if (_panel.Parent() == nullptr)
			{
				// We require a parent so that we can anchor to its dimensions
				RaiseError(_panel, EGRErrorCode::InvalidArg, __ROCOCO_FUNCTION__, "Panel parent was null");
				return;
			}

			panel.SetExpandToParentHorizontally();
			panel.Set(GRAnchorPadding{ 1, 1, 1, 1 });
		}

		virtual ~GRGameOptionsBoolWidget()
		{

		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		void PostConstruct(const GameOptionConfig& config)
		{
			this->config = config;

			title = &AddGameOptionTitleWidget(*this, config);
			
			if (config.TitlesOnLeft)
			{
				panel.SetLayoutDirection(ELayoutDirection::LeftToRight);
			}

			button = &Gui::CreateButton(*this);
			button->Widget().Panel().SetExpandToParentHorizontally();
			button->Widget().Panel().SetExpandToParentVertically();
			button->SetEventPolicy(EGREventPolicy::NotifyAncestors);
			button->MakeToggleButton();
			button->SetPressedImagePath("!textures/toolbars/3rd-party/www.aha-soft.com/Yes.tiff");
			button->SetRaisedImagePath("!textures/toolbars/3rd-party/www.aha-soft.com/No.tiff");
			button->Panel().Remove(EGRPanelFlags::AcceptsFocus);
			
			MakeTransparent(button->Widget().Panel(), EGRSchemeColourSurface::BUTTON);
			MakeTransparent(button->Widget().Panel(), EGRSchemeColourSurface::BUTTON_IMAGE_FOG);
			MakeTransparent(button->Widget().Panel(), EGRSchemeColourSurface::BUTTON_EDGE_TOP_LEFT);
			MakeTransparent(button->Widget().Panel(), EGRSchemeColourSurface::BUTTON_EDGE_BOTTOM_RIGHT);
		}

		void LayoutBeforeFit() override
		{

		}

		void LayoutBeforeExpand() override
		{
			int height = (int)(config.FontHeightToOptionHeightMultiplier * GetCustodian(panel).Fonts().GetFontHeight(config.TitleFontId));
			panel.SetConstantHeight(height);
		}

		void LayoutAfterExpand() override
		{

		}

		void Free() override
		{
			delete this;
		}

		EGREventRouting OnCursorClick(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnCursorMove(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{

		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		void Render(IGRRenderContext& rc) override
		{
			DrawGameOptionBackground(*title, panel, rc);
		}

		EGREventRouting OnChildEvent(GRWidgetEvent& widgetEvent, IGRWidget& sourceWidget)
		{
			if (widgetEvent.eventType == EGRWidgetEventType::BUTTON_CLICK && sourceWidget == button->Widget())
			{
				GRWidgetEvent optionBool{ EGRWidgetEventType::BOOL_CHANGED, panel.Id(), !button->ButtonFlags().isRaised, "", widgetEvent.clickPosition, true };
				Gui::NotifySelectionChanged(panel, EGRSelectionChangeOrigin::ButtonClick);
				return panel.NotifyAncestors(optionBool, *this);
			}
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnKeyEvent(GRKeyEvent& ke) override
		{
			if (ke.osKeyEvent.IsUp())
			{
				return EGREventRouting::NextHandler;
			}

			switch (ke.osKeyEvent.VKey)
			{
			case IO::VirtualKeys::VKCode_LEFT:
			case IO::VirtualKeys::VKCode_RIGHT:
			case IO::VirtualKeys::VKCode_PGUP:
			case IO::VirtualKeys::VKCode_PGDOWN:
			case IO::VirtualKeys::VKCode_HOME:
			case IO::VirtualKeys::VKCode_END:
			case IO::VirtualKeys::VKCode_SPACEBAR:
			case IO::VirtualKeys::VKCode_ENTER:
				button->Toggle();
			break;
			case IO::VirtualKeys::VKCode_UP:
				if (panel.HasFocus())
				{
					RotateFocusToNextSibling(Widget(), false);
				}
				break;
			case IO::VirtualKeys::VKCode_DOWN:
				if (panel.HasFocus())
				{
					RotateFocusToNextSibling(Widget(), true);
				}
				break;
			default:
				return EGREventRouting::NextHandler;
			}
			return EGREventRouting::Terminate;
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			auto result = QueryForParticularInterface<IGRWidgetLayout>(this, ppOutputArg, interfaceId);
			if (result == EGRQueryInterfaceResult::SUCCESS)
			{
				return result;
			}
			return Gui::QueryForParticularInterface<IGRWidgetGameOptionsBool>(this, ppOutputArg, interfaceId);
		}

		IGRWidget& Widget()
		{
			return *this;
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRGameOptionsBoolWidget";
		}

		void SetTitle(cstr text) override
		{
			title->SetText(text);
		}

		IBoolInquiry& Inquiry() override
		{
			return *this;
		}

		void SetActiveValue(bool boolValue) override
		{
			button->SetPressedNoCallback(boolValue);
		}

		void SetHint(cstr text) override
		{
			panel.SetHint(text);
		}
	};

	struct GRGameOptionsBoolFactory : IGRWidgetFactory
	{
		GRGameOptionsBoolFactory()
		{

		}

		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			return *new GRGameOptionsBoolWidget(panel);
		}
	};
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetGameOptionsBool::InterfaceId()
	{
		return "IGRWidgetGameOptionsBool";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetGameOptionsBool& CreateGameOptionsBool(IGRWidget& parent, const GameOptionConfig& config)
	{
		auto& gr = parent.Panel().Root().GR();

		GRANON::GRGameOptionsBoolFactory factory;
		auto& l = static_cast<GRANON::GRGameOptionsBoolWidget&>(gr.AddWidget(parent.Panel(), factory));
		l.PostConstruct(config);
		return l;
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.game-options.choice.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <rococo.game.options.h>
#include <rococo.strings.h>
#include <rococo.ui.h>
#include <rococo.vkeys.h>

using namespace Rococo;
using namespace Rococo::Gui;
using namespace Rococo::Game::Options;
using namespace Rococo::Strings;

namespace GRANON
{
	struct GRGameOptionChoiceWidget : IGRWidgetGameOptionsChoice, IGRWidgetSupervisor, IChoiceInquiry, IGRWidgetLayout
	{
		IGRPanel& panel;
		IGRWidgetText* title = nullptr;
		IGRWidgetCarousel* carousel = nullptr;
		GameOptionConfig config;

		GRGameOptionChoiceWidget(IGRPanel& _panel) : panel(_panel)
		{
			_panel.SetLayoutDirection(ELayoutDirection::TopToBottom);
			_panel.Add(EGRPanelFlags::AcceptsFocus);
			if (_panel.Parent() == nullptr)
			{
				// We require a parent so that we can anchor to its dimensions
				RaiseError(_panel, EGRErrorCode::InvalidArg, __ROCOCO_FUNCTION__, "Panel parent was null");
				return;
			}

			panel.SetExpandToParentHorizontally();
			panel.Set(GRAnchorPadding{ 1, 1, 1, 1 });
		}

		virtual ~GRGameOptionChoiceWidget()
		{

		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		void PostConstruct(const GameOptionConfig& config)
		{
			this->config = config;

			if (config.TitlesOnLeft)
			{
				panel.SetLayoutDirection(ELayoutDirection::LeftToRight);
			}

			title = &AddGameOptionTitleWidget(*this, config);

			carousel = &Gui::CreateCarousel(*this, config.LeftImageRaised, config.RightImageRaised, config.LeftImagePressed, config.RightImagePressed);
			carousel->Panel().SetExpandToParentHorizontally();
			carousel->Panel().SetExpandToParentVertically();
			carousel->SetDisableCarouselWhenDropDownVisible(true);
			carousel->SetOptionPadding(config.CarouselPadding);
			carousel->SetFont(config.CarouselFontId);
			carousel->DropDown().SetOptionFont(config.CarouselButtonFontId);
			carousel->DropDown().SetOptionPadding(config.CarouselButtonPadding);
		}

		void LayoutBeforeFit() override
		{

		}

		void LayoutBeforeExpand() override
		{
			int height = (int)(config.FontHeightToOptionHeightMultiplier * GetCustodian(panel).Fonts().GetFontHeight(config.TitleFontId));
			panel.SetConstantHeight(height);
		}

		void LayoutAfterExpand() override
		{

		}

		void Free() override
		{
			delete this;
		}

		EGREventRouting OnCursorClick(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnCursorMove(GRCursorEvent& ce) override
		{
			IGRWidgetButton* button = carousel->DropDown().GetButtonUnderPoint(ce.position);
			if (button)
			{
				cstr hint = button->Panel().Hint();
				if (hint)
				{
					GRWidgetEvent evRouteHoverHint;
					evRouteHoverHint.clickPosition = ce.position;
					evRouteHoverHint.eventType = EGRWidgetEventType::ON_HINT_HOVER;
					evRouteHoverHint.iMetaData = button->Panel().Id();
					evRouteHoverHint.isCppOnly = true;
					evRouteHoverHint.panelId = panel.Id();
					evRouteHoverHint.sMetaData = hint;
					static_cast<IGRPanelSupervisor&>(panel).RouteToParent(evRouteHoverHint);
				}
			}
			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{

		}

		IGRWidgetCarousel& Carousel() override
		{
			return *carousel;
		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		void Render(IGRRenderContext& rc) override
		{
			auto& parentPanel = *panel.Parent();

			carousel->Panel().SetCornerRadius(parentPanel.CornerRadius());
			carousel->Panel().SetRectStyle(parentPanel.RectStyle());

			DrawGameOptionBackground(*title, panel, rc);
		}

		EGREventRouting OnButtonClick(IGRWidget& sourceWidget, Vec2i clickPosition)
		{
			auto* button = Cast<IGRWidgetButton>(sourceWidget);
			if (button)
			{
				cstr choice = button->MetaData().stringData;

				GRWidgetEvent choiceMade;
				choiceMade.clickPosition = clickPosition;
				choiceMade.eventType = EGRWidgetEventType::CHOICE_MADE;
				choiceMade.iMetaData = 0;
				choiceMade.isCppOnly = true;
				choiceMade.panelId = panel.Id();
				choiceMade.sMetaData = choice;

				carousel->SetActiveChoice(choice);

				return panel.NotifyAncestors(choiceMade, *this);
			}
			else
			{
				return EGREventRouting::NextHandler;
			}
		}

		EGREventRouting OnChildEvent(GRWidgetEvent& widgetEvent, IGRWidget& sourceWidget)
		{
			switch (widgetEvent.eventType)
			{
			case EGRWidgetEventType::BUTTON_CLICK:
				return OnButtonClick(sourceWidget, widgetEvent.clickPosition);
			}

			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnKeyEvent(GRKeyEvent& ke) override
		{
			if (ke.osKeyEvent.IsUp())
			{
				return EGREventRouting::NextHandler;
			}

			switch (ke.osKeyEvent.VKey)
			{
			case IO::VirtualKeys::VKCode_LEFT:
				carousel->Advance(-1);
				break;
			case IO::VirtualKeys::VKCode_RIGHT:
				carousel->Advance(1);
				break;
			case IO::VirtualKeys::VKCode_UP:
				if (panel.HasFocus())
				{
					RotateFocusToNextSibling(Widget(), false);
				}
				break;
			case IO::VirtualKeys::VKCode_DOWN:
				if (panel.HasFocus())
				{
					RotateFocusToNextSibling(Widget(), true);
				}
				break;
			case IO::VirtualKeys::VKCode_ENTER:
				carousel->FlipDropDown();
				panel.FocusAndNotifyAncestors();
				MoveFocusIntoChildren(panel);
				break;
			default:
				return EGREventRouting::NextHandler;
			}
			return EGREventRouting::Terminate;
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			auto result = QueryForParticularInterface<IGRWidgetLayout>(this, ppOutputArg, interfaceId);
			if (result == EGRQueryInterfaceResult::SUCCESS)
			{
				return result;
			}
			return Gui::QueryForParticularInterface<IGRWidgetGameOptionsChoice>(this, ppOutputArg, interfaceId);
		}

		IGRWidget& Widget()
		{
			return *this;
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRGameOptionChoiceWidget";
		}

		void SetTitle(cstr text) override
		{
			title->SetText(text);
		}

		IChoiceInquiry& Inquiry() override
		{
			return *this;
		}

		bool ignoreAdditions = false;

		void IgnoreAdditions(bool shouldIgnore) override
		{
			ignoreAdditions = shouldIgnore;
		}

		void AddChoice(cstr choiceName, cstr choiceText, cstr hint) override
		{
			if (!ignoreAdditions)
			{
				carousel->AddOption(choiceName, choiceText, hint);
			}
		}

		void SetActiveChoice(cstr choiceName) override
		{
			carousel->SetActiveChoice(choiceName);
		}

		void SetHint(cstr text) override
		{
			panel.SetHint(text);
		}
	};

	struct GRGameOptionsChoiceFactory : IGRWidgetFactory
	{
		GRGameOptionsChoiceFactory()
		{

		}

		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			return *new GRGameOptionChoiceWidget(panel);
		}
	};
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetGameOptionsChoice::InterfaceId()
	{
		return "IGRWidgetGameOptionsChoice";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetGameOptionsChoice& CreateGameOptionsChoice(IGRWidget& parent, const GameOptionConfig& config)
	{
		auto& gr = parent.Panel().Root().GR();

		GRANON::GRGameOptionsChoiceFactory factory;
		auto& l = static_cast<GRANON::GRGameOptionChoiceWidget&>(gr.AddWidget(parent.Panel(), factory));
		l.PostConstruct(config);
		return l;
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetText& AddGameOptionTitleWidget(IGRWidget& parentWidget, const GameOptionConfig& config)
	{
		auto* title = &Gui::CreateText(parentWidget);
		title->Widget().Panel().SetExpandToParentHorizontally();
		title->Widget().Panel().SetExpandToParentVertically();
		title->SetFont(config.TitleFontId);

		int fontHeight = GetCustodian(parentWidget).Fonts().GetFontHeight(config.TitleFontId);

		Vec2i spacing{ 0,0 };
		spacing.x = (int) (fontHeight * config.TitleXSpacingMultiplier);

		title->SetTextColourSurface(EGRSchemeColourSurface::GAME_OPTION_TEXT);
		title->SetBackColourSurface(EGRSchemeColourSurface::LABEL_BACKGROUND);
		title->SetAlignment(config.TitleAlignment, spacing);

		MakeTransparent(title->Widget().Panel(), EGRSchemeColourSurface::CONTAINER_TOP_LEFT);
		MakeTransparent(title->Widget().Panel(), EGRSchemeColourSurface::CONTAINER_BOTTOM_RIGHT);

		return *title;
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.game-options.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#define ROCOCO_USE_SAFE_V_FORMAT
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <rococo.game.options.h>
#include <rococo.hashtable.h>
#include <rococo.strings.h>

using namespace Rococo;
using namespace Rococo::Gui;
using namespace Rococo::Game::Options;
using namespace Rococo::Strings;

namespace GRANON
{
	struct GRGameOptionsList : IGRWidgetGameOptions, IGRWidgetSupervisor, IGameOptionsBuilder, IGRWidgetInitializer, IEventCallback<ButtonEvent>, IGameOptionChangeNotifier
	{
		IGRPanel& panel;
		IGameOptions& options;
		stringmap<IGRWidgetGameOptionsChoice*> mapNameToChoiceControl;
		stringmap<IGRWidgetGameOptionsBool*> mapNameToBoolControl;
		stringmap<IGRWidgetGameOptionsScalar*> mapNameToScalarControl;
		stringmap<IGRWidgetGameOptionsString*> mapNameToStringControl;

		GameOptionConfig config;

		GRGameOptionsList(IGRPanel& _panel, IGameOptions& _options, const GameOptionConfig& _config) : panel(_panel), options(_options), config(_config)
		{
			panel.SetLayoutDirection(ELayoutDirection::TopToBottom);
			panel.SetExpandToParentHorizontally();
			panel.SetExpandToParentVertically();
			if (panel.Parent() == nullptr)
			{
				// We require a parent so that we can anchor to its dimensions
				RaiseError(panel, EGRErrorCode::InvalidArg, __ROCOCO_FUNCTION__, "Panel parent was null");
				return;
			}

			panel.Set(GRAnchorPadding{ 4,4,4,4 });
			panel.SetChildPadding(1);
		}

		virtual ~GRGameOptionsList()
		{
		}

		void OnSupervenientOptionChanged(IGameOptions&) override
		{
			options.Refresh(*this);
		}

		void OnTick(float dt) override
		{
			options.OnTick(dt, *this);
		}

		IGameOptions& Options() override
		{
			return options;
		}

		const GameOptionConfig& Config() const override
		{
			return config;
		}

		void PostConstruct()
		{
			options.AddOptions(*this);
		}

		void Free() override
		{
			delete this;
		}

		EGREventRouting OnCursorClick(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnCursorMove(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{

		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		void Render(IGRRenderContext& rc) override
		{
			CopyAllColours(panel, panel, EGRSchemeColourSurface::GAME_OPTION_TEXT, EGRSchemeColourSurface::TEXT);
			CopyAllColours(panel, panel, EGRSchemeColourSurface::GAME_OPTION_BACKGROUND, EGRSchemeColourSurface::BACKGROUND);

			DrawPanelBackground(panel, rc);

			dropDownCount = 0;

			for (auto& i : mapNameToChoiceControl)
			{
				if (!i.second->Carousel().DropDown().Panel().IsCollapsed())
				{
					dropDownCount++;
				}
			}

			int nChildren = panel.EnumerateChildren(nullptr);

			if (nChildren > 0)
			{
				auto* lastChild = panel.GetChild(nChildren - 1);
				int domainHeight = lastChild->ParentOffset().y + lastChild->Span().y + panel.ChildPadding() + panel.Padding().bottom;

				GRWidgetEvent updatedDomainHeight;
				updatedDomainHeight.eventType = EGRWidgetEventType::UPDATED_CLIENTAREA_HEIGHT;
				updatedDomainHeight.clickPosition = Centre(panel.AbsRect());
				updatedDomainHeight.iMetaData = domainHeight;
				updatedDomainHeight.isCppOnly = true;
				updatedDomainHeight.panelId = panel.Id();
				updatedDomainHeight.sMetaData = GetImplementationTypeName();
				panel.NotifyAncestors(updatedDomainHeight, *this);
			}
		}

		EGREventRouting OnDropDownCollapsed(IGRWidget& sourceWidget)
		{
			auto* carousel = Cast<IGRWidgetCarousel>(sourceWidget);
			if (carousel)
			{
				auto& dropDown = carousel->DropDown();
				if (panel.Root().GR().GetFocusId() >= 0)
				{
					carousel->Panel().Parent()->FocusAndNotifyAncestors();
				}

				dropDown.Panel().Root().ReleaseCursor();
				dropDown.Panel().SetRenderLast(false);
				return EGREventRouting::Terminate;
			}
			
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnDropDownExpanded(IGRWidget& sourceWidget)
		{
			auto* carousel = Cast<IGRWidgetCarousel>(sourceWidget);
			if (carousel)
			{
				auto& dropDown = carousel->DropDown();
				dropDown.Panel().CaptureCursor();
				dropDown.Panel().SetRenderLast(true);
				return EGREventRouting::Terminate;
			}

			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnChoiceMade(const GRWidgetEvent& choice, IGRWidget& sourceWidget)
		{
			auto* choiceSelector = Cast<IGRWidgetGameOptionsChoice>(sourceWidget);
			if (!choiceSelector)
			{
				return EGREventRouting::NextHandler;
			}

			for (auto& i : mapNameToChoiceControl)
			{
				if (i.second == choiceSelector)
				{
					cstr optionName = i.first;
					cstr optionValue = choice.sMetaData;

					options.DB().Invoke(optionName, optionValue, *this);
				}
			}
			return EGREventRouting::Terminate;
		}

		EGREventRouting OnScrollerReleased(GRWidgetEvent&, IGRWidget& sourceWidget)
		{
			// If the scroller is part of the scrollable drop down menu, return return focus and cursor capture to the menu

			for (IGRPanel* ancestor = sourceWidget.Panel().Parent(); ancestor != nullptr; ancestor = ancestor->Parent())
			{
				auto* dropDown = Cast<IGRWidgetScrollableMenu>(ancestor->Widget());
				if (dropDown)
				{
					auto ddId = dropDown->Panel().Id();
					SetFocusWithNoCallback(dropDown->Panel());
					auto* notifier = Cast<IGRFocusNotifier>(dropDown->Viewport().Widget());
					auto result = notifier->OnDeepChildFocusSet(ddId);
					UNUSED(result);
					dropDown->Panel().CaptureCursor();
					break;
				}
			}

			return EGREventRouting::Terminate;
		}

		EGREventRouting OnBoolSelected(bool isTrue, IGRWidget& sourceWidget)
		{
			for (auto& i : mapNameToBoolControl)
			{
				if (sourceWidget == i.second->Widget())
				{
					options.DB().Invoke(i.first, isTrue, *this);
					break;
				}
			}
			return EGREventRouting::Terminate;
		}

		EGREventRouting OnSliderMoved(IGRWidget& sourceWidget)
		{
			auto* slider = Cast<IGRWidgetSlider>(sourceWidget);
			if (slider)
			{
				for (auto& i : mapNameToScalarControl)
				{
					if (slider == &i.second->Slider())
					{
						options.DB().Invoke(i.first, slider->Position(), *this);
						break;
					}
				}
			}

			return EGREventRouting::Terminate;
		}

		int dropDownCount = 0;

		EGREventRouting OnChildEvent(GRWidgetEvent& widgetEvent, IGRWidget& sourceWidget)
		{
			switch (widgetEvent.eventType)
			{
			case EGRWidgetEventType::DROP_DOWN_COLLAPSED:
				return OnDropDownCollapsed(sourceWidget);
			case EGRWidgetEventType::DROP_DOWN_EXPANDED:
				return OnDropDownExpanded(sourceWidget);
			case EGRWidgetEventType::CHOICE_MADE:
				return OnChoiceMade(widgetEvent, sourceWidget);
			case EGRWidgetEventType::SCROLLER_RELEASED:
				return OnScrollerReleased(widgetEvent, sourceWidget);
			case EGRWidgetEventType::BOOL_CHANGED:
				return OnBoolSelected(widgetEvent.iMetaData != 0, sourceWidget);
			case EGRWidgetEventType::SLIDER_NEW_POS:
				return OnSliderMoved(sourceWidget);
			case EGRWidgetEventType::ARE_DESCENDANTS_OBSCURED:
				// If there is at least one visible drop down, we increment the meta data and so obscure the descendants
				widgetEvent.iMetaData += dropDownCount;
				return EGREventRouting::Terminate;
			}

			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnKeyEvent(GRKeyEvent&) override
		{
			return EGREventRouting::NextHandler;
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			auto result = QueryForParticularInterface<IGRWidgetInitializer>(this, ppOutputArg, interfaceId);
			if (result == EGRQueryInterfaceResult::SUCCESS)
			{
				return result;
			}

			return QueryForParticularInterface<IGRWidgetGameOptions>(this, ppOutputArg, interfaceId);
		}

		IGRWidget& Widget()
		{
			return *this;
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRGameOptionsList";
		}

		template<class T>
		void GuaranteeUnique(T& t, cstr name)
		{
			auto i = t.find(name);
			if (i != t.end())
			{
				RaiseError(panel, EGRErrorCode::InvalidArg, __ROCOCO_FUNCTION__, "GameOption<%s> already defined. GRGameOptionsList does not support duplicate names", name);
			}
		}

		IChoiceInquiry& AddChoice(cstr name) override
		{
			GuaranteeUnique(mapNameToChoiceControl, name);
			IGRWidgetGameOptionsChoice& choiceWidget = CreateGameOptionsChoice(*this, config);

			// Prevent a carousel selected menu item from scrolling the main options when the drop down is selected.
			choiceWidget.Carousel().DropDown().Viewport().PropagateFocusChangesToParent(false);
			mapNameToChoiceControl.insert(name, &choiceWidget);
			return choiceWidget.Inquiry();
		}

		IBoolInquiry& AddBool(cstr name) override
		{
			GuaranteeUnique(mapNameToBoolControl, name);
			IGRWidgetGameOptionsBool& boolWidget = CreateGameOptionsBool(*this, config);
			mapNameToBoolControl.insert(name, &boolWidget);
			return boolWidget.Inquiry();
		}

		IScalarInquiry& AddScalar(cstr name) override
		{
			GuaranteeUnique(mapNameToScalarControl, name);
			IGRWidgetGameOptionsScalar& scalarWidget = CreateGameOptionsScalar(*this, config);
			mapNameToScalarControl.insert(name, &scalarWidget);
			scalarWidget.Slider().SetRenderFunction(config.SliderRenderFunction, nullptr);
			return scalarWidget.Inquiry();
		}

		IStringInquiry& AddString(cstr name, int maxCharacters) override
		{
			if (maxCharacters <= 0 || maxCharacters > 4096)
			{
				RaiseError(panel, EGRErrorCode::InvalidArg, __ROCOCO_FUNCTION__, "maxCharacters needs to be positive and not more than 4096");
			}
			GuaranteeUnique(mapNameToStringControl, name);
			IGRWidgetGameOptionsString& stringWidget = CreateGameOptionsString(*this, config, maxCharacters);
			mapNameToStringControl.insert(name, &stringWidget);
			return stringWidget.Inquiry();
		}

		IChoiceInquiry& GetChoice(cstr name) override
		{
			auto i = mapNameToChoiceControl.find(name);
			if (i == mapNameToChoiceControl.end())
			{
				RaiseError(panel, EGRErrorCode::InvalidArg, __FUNCTION__, "Bad name");
			}

			i->second->IgnoreAdditions(true);
			return i->second->Inquiry();
		}

		IBoolInquiry& GetBool(cstr name) override
		{
			auto i = mapNameToBoolControl.find(name);
			if (i == mapNameToBoolControl.end())
			{
				RaiseError(panel, EGRErrorCode::InvalidArg, __FUNCTION__, "Bad name");
			}

			return i->second->Inquiry();
		}

		IScalarInquiry& GetScalar(cstr name) override
		{
			auto i = mapNameToScalarControl.find(name);
			if (i == mapNameToScalarControl.end())
			{
				RaiseError(panel, EGRErrorCode::InvalidArg, __FUNCTION__, "Bad name");
			}

			return i->second->Inquiry();
		}

		IStringInquiry& GetString(cstr name) override
		{
			auto i = mapNameToStringControl.find(name);
			if (i == mapNameToStringControl.end())
			{
				RaiseError(panel, EGRErrorCode::InvalidArg, __FUNCTION__, "Bad name");
			}

			return i->second->Inquiry();
		}

		void OnEvent(ButtonEvent& ev) override
		{
			cstr desc = ev.button.Panel().Desc();
			if (Eq("ButtonAccept", desc))
			{
				options.Accept(*this);
			}
			else if (Eq("ButtonRevert", desc))
			{
				options.Revert(*this);
			}
		}

		bool subscribeToCommitButtons = false;

		void SubscribeToCommitButtons() override
		{
			subscribeToCommitButtons = true;
		}

		void SubscribeToButtonRecursive(IGRWidget& widget)
		{
			auto* button = Cast<IGRWidgetButton>(widget);
			if (button)
			{
				if (Eq("ButtonAccept", button->Panel().Desc()))
				{
					button->Subscribe(*this);
				}
				else if (Eq("ButtonRevert", button->Panel().Desc()))
				{
					button->Subscribe(*this);
				}
				
				return;
			}

			int nChildren = widget.Panel().EnumerateChildren(nullptr);
			for (int i = 0; i < nChildren; i++)
			{
				auto* child = widget.Panel().GetChild(i);
				SubscribeToButtonRecursive(child->Widget());
			}
		}

		void Prep() override
		{
			if (subscribeToCommitButtons)
			{
				auto* frame = FindOwner(*this);
				SubscribeToButtonRecursive(frame->Widget());
			}
		}
	};

	struct GRGameOptionsFactory : IGRWidgetFactory
	{
		IGameOptions& options;
		const GameOptionConfig& config;

		GRGameOptionsFactory(IGameOptions& _options, const GameOptionConfig& _config): options(_options), config(_config)
		{

		}

		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			return *new GRGameOptionsList(panel, options, config);
		}
	};
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetGameOptions::InterfaceId()
	{
		return "IGRWidgetGameOptions";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetGameOptions& CreateGameOptionsList(IGRWidget& parent, IGameOptions& options, const GameOptionConfig& config)
	{
		auto& gr = parent.Panel().Root().GR();

		GRANON::GRGameOptionsFactory factory(options, config);
		auto& l = static_cast<GRANON::GRGameOptionsList&>(gr.AddWidget(parent.Panel(), factory));
		l.PostConstruct();
		return l;
	}

}

// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.game-options.scalar.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <rococo.game.options.h>
#include <rococo.strings.h>
#include <rococo.ui.h>
#include <rococo.vkeys.h>

using namespace Rococo;
using namespace Rococo::Gui;
using namespace Rococo::Game::Options;
using namespace Rococo::Strings;

namespace GRANON
{
	struct GRGameOptionScalarWidget : IGRWidgetGameOptionsScalar, IGRWidgetSupervisor, IScalarInquiry, IGRWidgetLayout
	{
		IGRPanel& panel;
		IGRWidgetText* title = nullptr;
		IGRWidgetSlider* slider = nullptr;
		GameOptionConfig config;

		GRGameOptionScalarWidget(IGRPanel& _panel) : panel(_panel)
		{
			_panel.SetLayoutDirection(ELayoutDirection::TopToBottom);
			_panel.Add(EGRPanelFlags::AcceptsFocus);
			if (_panel.Parent() == nullptr)
			{
				// We require a parent so that we can anchor to its dimensions
				RaiseError(_panel, EGRErrorCode::InvalidArg, __ROCOCO_FUNCTION__, "Panel parent was null");
				return;
			}

			panel.SetExpandToParentHorizontally();
			panel.Set(GRAnchorPadding{ 1, 1, 1, 1 });
		}

		virtual ~GRGameOptionScalarWidget()
		{

		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		void PostConstruct(const GameOptionConfig& config)
		{
			this->config = config;

			if (config.TitlesOnLeft)
			{
				panel.SetLayoutDirection(ELayoutDirection::LeftToRight);
			}

			title = &AddGameOptionTitleWidget(*this, config);

			MakeTransparent(title->Widget().Panel(), EGRSchemeColourSurface::CONTAINER_TOP_LEFT);
			MakeTransparent(title->Widget().Panel(), EGRSchemeColourSurface::CONTAINER_BOTTOM_RIGHT);

			slider = &Gui::CreateSlider(*this);
			slider->Widget().Panel().SetExpandToParentHorizontally();
			slider->Widget().Panel().SetExpandToParentVertically();

			slider->SetRaisedImagePath(config.ScalarKnobRaised);
			slider->SetPressedImagePath(config.ScalarKnobPressed);

			slider->SetGuageAlignment(config.ScalarGuageAlignment, config.ScalarGuageSpacing);
			slider->SetSlotPadding(config.ScalarSlotPadding);

			slider->SetGuage(config.SliderFontId, 2, EGRSchemeColourSurface::SLIDER_GUAGE);

			slider->SetRenderingMetrics(config.sliderBulbCount, config.sliderVGap, config.sliderHGap);

			MakeTransparent(slider->Widget().Panel(), EGRSchemeColourSurface::SLIDER_BACKGROUND);
		}

		void SetDecimalPlaces(int nPlaces) override
		{
			slider->SetGuage(config.SliderFontId, nPlaces, EGRSchemeColourSurface::SLIDER_GUAGE);
		}

		void LayoutBeforeFit() override
		{

		}

		void LayoutBeforeExpand() override
		{
			int height = (int)(config.FontHeightToOptionHeightMultiplier * GetCustodian(panel).Fonts().GetFontHeight(config.TitleFontId));
			panel.SetConstantHeight(height);
		}

		void LayoutAfterExpand() override
		{

		}

		void Free() override
		{
			delete this;
		}

		EGREventRouting OnCursorClick(GRCursorEvent& we) override
		{
			if (panel.HasFocus() && we.wheelDelta != 0)
			{
				int acceleration = we.context.isCtrlHeld ? 10 : 1;

				if (we.wheelDelta % 120 == 0)
				{
					// Assume Win32 behaviour with 120 units per click
					slider->Advance(acceleration * (we.wheelDelta / 120));
				}
				else
				{
					slider->Advance(acceleration * we.wheelDelta);
				}
				return EGREventRouting::Terminate;
			}
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnCursorMove(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{

		}

		IGRWidgetSlider& Slider() override
		{
			return *slider;
		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		void Render(IGRRenderContext& rc) override
		{
			DrawGameOptionBackground(*title, panel, rc);
		}

		EGREventRouting OnChildEvent(GRWidgetEvent& widgetEvent, IGRWidget& sourceWidget)
		{
			if (slider->Widget() == sourceWidget)
			{
				switch (widgetEvent.eventType)
				{
				case EGRWidgetEventType::SCROLLER_RELEASED:
					return EGREventRouting::Terminate;
				case EGRWidgetEventType::SLIDER_HELD:
					panel.FocusAndNotifyAncestors();
					return EGREventRouting::Terminate;
				}
			}

			UNUSED(sourceWidget);
			return EGREventRouting::NextHandler;
		}

		int speed = 0;

		EGREventRouting OnKeyEvent(GRKeyEvent& ke) override
		{
			if (ke.osKeyEvent.IsUp())
			{
				speed = 0;
				return EGREventRouting::NextHandler;
			}

			speed += 1;

			switch (ke.osKeyEvent.VKey)
			{
			case IO::VirtualKeys::VKCode_PGUP:
				slider->Advance(-10 * speed);
				break;
			case IO::VirtualKeys::VKCode_PGDOWN:
				slider->Advance(10 * speed);
				break;
			case IO::VirtualKeys::VKCode_LEFT:
				slider->Advance(-1 * speed);
				break;
			case IO::VirtualKeys::VKCode_RIGHT:
				slider->Advance(1 * speed);
				break;
			case IO::VirtualKeys::VKCode_HOME:
				slider->SetPosition(slider->Min());
				break;
			case IO::VirtualKeys::VKCode_END:
				slider->SetPosition(slider->Max());
				break;
			case IO::VirtualKeys::VKCode_UP:
				if (panel.HasFocus())
				{
					RotateFocusToNextSibling(Widget(), false);
				}
				break;
			case IO::VirtualKeys::VKCode_DOWN:
				if (panel.HasFocus())
				{
					RotateFocusToNextSibling(Widget(), true);
				}
				break;
			case IO::VirtualKeys::VKCode_SPACEBAR:
			{
				double midPt = (slider->Max() + slider->Min()) / 2.0;
				if (slider->Position() <= midPt)
				{
					slider->SetPosition(slider->Max());
				}
				else
				{
					slider->SetPosition(slider->Min());
				}

				NotifySelectionChanged(panel, EGRSelectionChangeOrigin::ScalarChangeKey);
			}
				break;
			default:
				return EGREventRouting::NextHandler;
			}
			return EGREventRouting::Terminate;
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			auto result = QueryForParticularInterface<IGRWidgetLayout>(this, ppOutputArg, interfaceId);
			if (result == EGRQueryInterfaceResult::SUCCESS)
			{
				return result;
			}
			return Gui::QueryForParticularInterface<IGRWidgetGameOptionsScalar>(this, ppOutputArg, interfaceId);
		}

		IGRWidget& Widget()
		{
			return *this;
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRGameOptionScalarWidget";
		}

		void SetTitle(cstr text) override
		{
			title->SetText(text);
		}

		IScalarInquiry& Inquiry() override
		{
			return *this;
		}

		void SetRange(double minValue, double maxValue, double quantumDelta) override
		{
			slider->SetRange(minValue, maxValue);
			slider->SetQuantum(quantumDelta);
		}

		void SetActiveValue(double scalarValue) override
		{
			slider->SetPosition(scalarValue);
		}

		void SetHint(cstr text) override
		{
			panel.SetHint(text);
		}

		void HideBackgroundWhenPopulated(bool value) override
		{
			slider->HideBackgroundWhenPartFilled(value);
		}
	};

	struct GRGameOptionsScalarFactory : IGRWidgetFactory
	{
		GRGameOptionsScalarFactory()
		{

		}

		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			return *new GRGameOptionScalarWidget(panel);
		}
	};
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetGameOptionsScalar::InterfaceId()
	{
		return "IGRWidgetGameOptionsScalar";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetGameOptionsScalar& CreateGameOptionsScalar(IGRWidget& parent, const GameOptionConfig& config)
	{
		auto& gr = parent.Panel().Root().GR();

		GRANON::GRGameOptionsScalarFactory factory;
		auto& l = static_cast<GRANON::GRGameOptionScalarWidget&>(gr.AddWidget(parent.Panel(), factory));
		l.PostConstruct(config);
		return l;
	}

	ROCOCO_GUI_RETAINED_API void DrawGameOptionBackground(IGRWidgetText& title, IGRPanel& panel, IGRRenderContext& rc)
	{
		DrawEdge(EGRSchemeColourSurface::GAME_OPTION_TOP_LEFT, EGRSchemeColourSurface::GAME_OPTION_BOTTOM_RIGHT, panel, rc);

		if (title.IsObscure())
		{
			title.SetTextColourSurface(EGRSchemeColourSurface::GAME_OPTION_DISABLED_TEXT).SetBackColourSurface(EGRSchemeColourSurface::GAME_OPTION_DISABLED_BACKGROUND);
		}
		else
		{
			title.SetTextColourSurface(EGRSchemeColourSurface::GAME_OPTION_TEXT).SetBackColourSurface(EGRSchemeColourSurface::LABEL_BACKGROUND);
		}

		RGBAb colour = panel.GetColour(EGRSchemeColourSurface::GAME_OPTION_CHILD_SPACER, GRWidgetRenderState{ false, false, false });
		if (colour.alpha > 0)
		{
			Vec2i bottomLeft = BottomLeft(panel.AbsRect());
			bottomLeft.y -= 1;

			Vec2i bottomRight = BottomRight(panel.AbsRect());
			bottomRight.y -= 1;
			rc.DrawLine(bottomLeft, bottomRight, colour);
		}
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.game-options.string.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <rococo.game.options.h>
#include <rococo.strings.h>
#include <rococo.ui.h>
#include <rococo.vkeys.h>

using namespace Rococo;
using namespace Rococo::Gui;
using namespace Rococo::Game::Options;
using namespace Rococo::Strings;

namespace GRANON
{
	struct GRGameOptionStringWidget : IGRWidgetGameOptionsString, IGRWidgetSupervisor, IStringInquiry, IGREditFilter, IGRWidgetLayout
	{
		IGRPanel& panel;
		IGRWidgetText* title = nullptr;
		IGRWidgetEditBox* editor = nullptr;
		IGRWidgetDivision* editorDiv = nullptr;

		GameOptionConfig config;

		GRGameOptionStringWidget(IGRPanel& _panel) : panel(_panel)
		{
			_panel.SetLayoutDirection(ELayoutDirection::TopToBottom);
			_panel.Add(EGRPanelFlags::AcceptsFocus);
			if (_panel.Parent() == nullptr)
			{
				// We require a parent so that we can anchor to its dimensions
				RaiseError(_panel, EGRErrorCode::InvalidArg, __ROCOCO_FUNCTION__, "Panel parent was null");
				return;
			}

			panel.SetExpandToParentHorizontally();
			panel.Set(GRAnchorPadding{ 0, 0, 0, 0 });
		}

		virtual ~GRGameOptionStringWidget()
		{

		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		void PostConstruct(const GameOptionConfig& config, int maxCharacters)
		{
			this->config = config;

			if (config.TitlesOnLeft)
			{
				panel.SetLayoutDirection(ELayoutDirection::LeftToRight);
			}

			title = &AddGameOptionTitleWidget(*this, config);

			MakeTransparent(title->Panel(), EGRSchemeColourSurface::CONTAINER_TOP_LEFT);
			MakeTransparent(title->Panel(), EGRSchemeColourSurface::CONTAINER_BOTTOM_RIGHT);

			int height = (int)(config.FontHeightToOptionHeightMultiplier * GetCustodian(panel).Fonts().GetFontHeight(config.TitleFontId));
			panel.SetConstantHeight(height);

			editorDiv = &CreateDivision(*this);
			editorDiv->Panel().
				SetExpandToParentHorizontally().
				SetExpandToParentVertically().
				Set(config.StringSlotPadding);

			editor = &CreateEditBox(editorDiv->Widget(), this, maxCharacters, config.CarouselButtonFontId);

			editor->Panel().
				SetExpandToParentHorizontally().
				SetExpandToParentVertically();

			GRAlignmentFlags alignment;
			alignment.Add(EGRAlignment::HCentre);
			editor->SetAlignment(alignment, config.EditorPadding);

			CopyAllColours(panel, editor->Panel(), EGRSchemeColourSurface::CAROUSEL_TOP_LEFT, EGRSchemeColourSurface::CONTAINER_TOP_LEFT);
			CopyAllColours(panel, editor->Panel(), EGRSchemeColourSurface::CAROUSEL_BOTTOM_RIGHT, EGRSchemeColourSurface::CONTAINER_BOTTOM_RIGHT);
			CopyAllColours(panel, editor->Panel(), EGRSchemeColourSurface::CAROUSEL_TEXT, EGRSchemeColourSurface::TEXT);
			CopyAllColours(panel, editor->Panel(), EGRSchemeColourSurface::CAROUSEL_TEXT, EGRSchemeColourSurface::EDIT_TEXT);
		}

		void LayoutBeforeFit() override
		{

		}

		void LayoutBeforeExpand() override
		{
			int height = (int)(config.FontHeightToOptionHeightMultiplier * GetCustodian(panel).Fonts().GetFontHeight(config.TitleFontId));
			panel.SetConstantHeight(height);
		}

		void LayoutAfterExpand() override
		{

		}

		void OnUpdate(IGRWidgetEditBox& editor, IGREditorMicromanager& manager) override
		{
			if (filter)
			{
				filter->OnUpdate(editor, manager);
			}
		}

		void Free() override
		{
			delete this;
		}

		EGREventRouting OnCursorClick(GRCursorEvent& we) override
		{
			UNUSED(we);
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnCursorMove(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{

		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		void Render(IGRRenderContext& rc) override
		{
			DrawGameOptionBackground(*title, panel, rc);
		}

		EGREventRouting OnChildEvent(GRWidgetEvent& widgetEvent, IGRWidget& sourceWidget)
		{
			UNUSED(widgetEvent);
			UNUSED(sourceWidget);
			return EGREventRouting::NextHandler;
		}

		int speed = 0;

		EGREventRouting OnKeyEvent(GRKeyEvent& ke) override
		{
			if (ke.osKeyEvent.IsUp())
			{
				return EGREventRouting::NextHandler;
			}

			switch (ke.osKeyEvent.VKey)
			{
			case IO::VirtualKeys::VKCode_UP:
				if (panel.HasFocus())
				{
					RotateFocusToNextSibling(Widget(), false);
				}
				break;
			case IO::VirtualKeys::VKCode_DOWN:
				if (panel.HasFocus())
				{
					RotateFocusToNextSibling(Widget(), true);
				}
				break;
			default:
				return EGREventRouting::NextHandler;
			}
			return EGREventRouting::Terminate;
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			auto result = QueryForParticularInterface<IGRWidgetLayout>(this, ppOutputArg, interfaceId);
			if (result == EGRQueryInterfaceResult::SUCCESS)
			{
				return result;
			}
			return QueryForParticularInterface<IGRWidgetGameOptionsString>(this, ppOutputArg, interfaceId);
		}

		IGRWidget& Widget()
		{
			return *this;
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRGameOptionStringWidget";
		}

		void SetTitle(cstr text) override
		{
			title->SetText(text);
		}

		IStringInquiry& Inquiry() override
		{
			return *this;
		}

		void SetActiveValue(cstr textValue) override
		{
			editor->SetText(textValue);
		}

		void SetHint(cstr text) override
		{
			panel.SetHint(text);
		}

		IGREditFilter* filter = nullptr;

		void SetFilter(IGREditFilter* filter) override
		{
			this->filter = filter;
		}
	};

	struct GRGameOptionsStringFactory : IGRWidgetFactory
	{
		GRGameOptionsStringFactory()
		{

		}

		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			return *new GRGameOptionStringWidget(panel);
		}
	};
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetGameOptionsString::InterfaceId()
	{
		return "IGRWidgetGameOptionsString";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetGameOptionsString& CreateGameOptionsString(IGRWidget& parent, const GameOptionConfig& config, int maxCharacters)
	{
		auto& gr = parent.Panel().Root().GR();

		GRANON::GRGameOptionsStringFactory factory;
		auto& l = static_cast<GRANON::GRGameOptionStringWidget&>(gr.AddWidget(parent.Panel(), factory));
		l.PostConstruct(config, maxCharacters);
		return l;
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.gradient-fill.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <rococo.strings.h>

using namespace Rococo;
using namespace Rococo::Gui;
using namespace Rococo::Strings;

namespace GRANON
{
	struct GRGradientFill : IGRWidgetGradientFill, IGRWidgetSupervisor, IGRWidgetLayout
	{
		IGRPanel& panel;
		
		IGRImage* image = nullptr;
		HString imagePath;

		GRGradientFill(IGRPanel& owningPanel) : panel(owningPanel)
		{
		}

		struct RGBAbQuad
		{
			RGBAb topLeft = {0,0,0,0};;
			RGBAb topRight = { 0,0,0,0 };;
			RGBAb bottomLeft = { 0,0,0,0 };;
			RGBAb bottomRight = { 0,0,0,0 };;
		} mainQuad;

		virtual ~GRGradientFill()
		{

		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		void Free() override
		{
			delete this;
		}

		void LayoutBeforeFit() override
		{

		}

		void LayoutBeforeExpand() override
		{
			if (fitRule == EGRFitRule::FirstChild)
			{
				auto* child0 = panel.GetChild(0);
				if (!child0)
				{				
					panel.SetConstantHeight(2);
					return;
				}

				panel.SetConstantHeight(child0->Span().y);
			}
		}

		void LayoutAfterExpand() override
		{

		}

		void SetBottomLeft(RGBAb c) override
		{
			mainQuad.bottomLeft = c;
		}

		void SetBottomRight(RGBAb c) override
		{
			mainQuad.bottomRight = c;
		}

		void SetTopLeft(RGBAb c) override
		{
			mainQuad.topLeft = c;
		}

		void SetTopRight(RGBAb c) override
		{
			mainQuad.topRight = c;
		}

		EGRFitRule fitRule = EGRFitRule::None;

		void SetFitVertical(EGRFitRule fitRule) override
		{
			this->fitRule = fitRule;
		}

		EGREventRouting OnCursorClick(GRCursorEvent&) override
		{
			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{
		}

		EGREventRouting OnCursorMove(GRCursorEvent&) override
		{
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnKeyEvent(GRKeyEvent&) override
		{
			return EGREventRouting::NextHandler;
		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		void BannerShade(const GuiRect& rect, IGRRenderContext& g)
		{
			Vec2i centre = Centre(rect);
			GuiRect leftRect(rect.left, rect.top, centre.x, rect.bottom);
			GuiRect rightRect(centre.x, rect.top, rect.right, rect.bottom);

			const RGBAbQuad& leftQuad = mainQuad;
			RGBAbQuad rightQuad { mainQuad.topRight, mainQuad.topLeft, mainQuad.bottomRight, mainQuad.bottomLeft };

			SmoothShade(leftRect, leftQuad, g);
			SmoothShade(rightRect, rightQuad, g);
		}

		void SmoothShade(const GuiRect& rect, const RGBAbQuad& quad, IGRRenderContext& g)
		{
			GRTriangle t[2];
			t[0].a = { TopLeft(rect), quad.topLeft };
			t[0].b = { TopRight(rect), quad.topRight };
			t[0].c = { BottomRight(rect), quad.bottomRight };
			t[1].a = { BottomRight(rect), quad.bottomRight };
			t[1].b = { BottomLeft(rect), quad.bottomLeft };
			t[1].c = { TopLeft(rect), quad.topLeft };

			g.DrawTriangles(t, 2);
		}

		void Render(IGRRenderContext& g) override
		{
			auto fillStyle = panel.FillStyle();
			const auto& rect = panel.AbsRect();

			switch (fillStyle)
			{
			case EGRFillStyle::SMOOTH:
				SmoothShade(rect, mainQuad, g);
				break;
			case EGRFillStyle::BANNER:
				BannerShade(rect, g);
				break;
			case EGRFillStyle::SOLID:
			default:
				g.DrawRect(panel.AbsRect(), mainQuad.topLeft);
				break;
			}
		}

		EGREventRouting OnChildEvent(GRWidgetEvent&, IGRWidget&) override
		{
			return EGREventRouting::NextHandler;
		}

		Vec2i EvaluateMinimalSpan() const
		{
			Vec2i extraSpan;
			extraSpan.x = panel.Padding().left + panel.Padding().right;
			extraSpan.y = panel.Padding().top + panel.Padding().bottom;
			return image ? image->Span() + extraSpan : extraSpan;
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			auto result = QueryForParticularInterface<IGRWidgetLayout>(this, ppOutputArg, interfaceId);
			if (result == EGRQueryInterfaceResult::SUCCESS)
			{
				return result;
			}
			return QueryForParticularInterface<IGRWidgetGradientFill, GRGradientFill>(this, ppOutputArg, interfaceId);
		}

		IGRWidget& Widget()
		{
			return *this;
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRGradientFill";
		}
	};

	struct GRGradientFillFactory : IGRWidgetFactory
	{
		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			return *new GRGradientFill(panel);
		}
	};
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetGradientFill::InterfaceId()
	{
		return "IGRWidgetGradientFill";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetGradientFill& CreateGradientFill(IGRWidget& parent)
	{
		GRANON::GRGradientFillFactory factory;
		auto& gr = parent.Panel().Root().GR();
		auto& widget = gr.AddWidget(parent.Panel(), factory);
		IGRWidgetGradientFill* g = Cast<IGRWidgetGradientFill>(widget);
		return *g;
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.hintbox.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <rococo.strings.h>

using namespace Rococo;
using namespace Rococo::Gui;

namespace GRANON
{
	struct GRHintBox : IGRWidgetDivisionWithText, IGRWidgetSupervisor
	{
		IGRPanel& panel;

		float transparency = 1.0f;
		GRAlignmentFlags alignment;

		GRHintBox(IGRPanel& owningPanel) : panel(owningPanel)
		{
			alignment.Add(EGRAlignment::HCentre).Add(EGRAlignment::VCentre);
		}

		virtual ~GRHintBox()
		{

		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		IGRWidget& Widget() override
		{
			return *this;
		}

		void SetTransparency(float f) override
		{
			transparency = clamp(f, 0.0f, 1.0f);
		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		void Free() override
		{
			delete this;
		}

		EGREventRouting OnCursorClick(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnCursorMove(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{

		}

		void DrawTextWithShadow(IGRRenderContext& g, const GuiRect& targetRect, const fstring& text)
		{
			GuiRect shadowRect = targetRect;
			shadowRect.left += 1;
			shadowRect.top += 1;
			shadowRect.right += 1;
			shadowRect.bottom += 1;
			g.DrawParagraph(fontId, shadowRect, alignment, spacing, text, RGBAb(0, 0, 0, 255));
			g.DrawParagraph(fontId, targetRect, alignment, spacing, text, RGBAb(255, 255, 255, 255));
		}

		void Render(IGRRenderContext& g) override
		{
			DrawPanelBackgroundEx(
				panel,
				g, 
				EGRSchemeColourSurface::CONTAINER_BACKGROUND,
				EGRSchemeColourSurface::CONTAINER_TOP_LEFT,
				EGRSchemeColourSurface::CONTAINER_BOTTOM_RIGHT,
				transparency
			);

			GRWidgetEvent evGetHoverHint;
			evGetHoverHint.clickPosition = { 0,0 };
			evGetHoverHint.eventType = EGRWidgetEventType::GET_HINT_HOVER;
			evGetHoverHint.iMetaData = 0;
			evGetHoverHint.isCppOnly = true;
			evGetHoverHint.panelId = panel.Id();
			evGetHoverHint.sMetaData = nullptr;
			static_cast<IGRPanelSupervisor&>(panel).RouteToParent(evGetHoverHint);
			cstr hint = evGetHoverHint.sMetaData;

			if (hint != nullptr && *hint != 0)
			{
				DrawTextWithShadow(g, panel.AbsRect(), to_fstring(hint));
			}
			else
			{
				auto* focusWidget = panel.Root().GR().FindFocusWidget();
				if (focusWidget)
				{
					hint = focusWidget->Panel().Hint();
					if (*hint != 0)
					{
						DrawTextWithShadow(g, panel.AbsRect(), to_fstring(hint));
					}
				}
			}
		}

		GRFontId fontId = GRFontId::NONE;
		Vec2i spacing{ 0,0 };

		void SetAlignment(GRAlignmentFlags flags) override
		{
			alignment = flags;
		}

		void SetFont(GRFontId fontId) override
		{
			this->fontId = fontId;
		}

		void SetSpacing(Vec2i spacing) override
		{
			this->spacing = spacing;
		}

		EGREventRouting OnChildEvent(GRWidgetEvent&, IGRWidget&) override
		{
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnKeyEvent(GRKeyEvent&) override
		{
			return EGREventRouting::NextHandler;
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			return QueryForParticularInterface<IGRWidgetDivisionWithText>(this, ppOutputArg, interfaceId);
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRHintBox";
		}
	};

	struct GRHintFactory : IGRWidgetFactory
	{
		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			return *new GRHintBox(panel);
		}
	} s_HintFactory;
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API IGRWidgetDivisionWithText& CreateHintBox(IGRWidget& parent)
	{
		auto& gr = parent.Panel().Root().GR();
		auto& hintBox = static_cast<GRANON::GRHintBox&>(gr.AddWidget(parent.Panel(), GRANON::s_HintFactory));
		return hintBox;
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.icon.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <rococo.strings.h>

using namespace Rococo;
using namespace Rococo::Gui;
using namespace Rococo::Strings;

namespace GRANON
{
	struct GRIcon : IGRWidgetIcon, IGRWidgetLayout, IGRWidgetSupervisor
	{
		IGRPanel& panel;
		
		IGRImage* image = nullptr;
		HString imagePath;

		GRIcon(IGRPanel& owningPanel) : panel(owningPanel)
		{
		}

		virtual ~GRIcon()
		{

		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		void Free() override
		{
			delete this;
		}

		void LayoutBeforeFit() override
		{

		}

		void LayoutBeforeExpand() override
		{

		}

		double ImgAspectRatio() const
		{
			Vec2i span = ImageSpan();
			return span.y == 0 ? 0 : (double)span.x / (double)span.y;
		}


		void LayoutAfterExpand() override
		{
			int height = panel.Span().y;
			int width = 0;

			switch (presentation)
			{
			case EGRIconPresentation::ScaleAgainstFixedHeight:
				width = (int) (height * ImgAspectRatio());
				panel.SetConstantWidth(width);
				break;
			}
		}

		EGREventRouting OnCursorClick(GRCursorEvent&) override
		{
			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{
		}

		EGREventRouting OnCursorMove(GRCursorEvent&) override
		{
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnKeyEvent(GRKeyEvent&) override
		{
			return EGREventRouting::NextHandler;
		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		void Render(IGRRenderContext& g) override
		{
			GRAlignmentFlags alignment;

			if (!image)
			{
				return;
			}

			Vec2i span = image->Span();
			if (span.x == 0 || span.y == 0)
			{
				return;
			}

			GuiRect innerRect = panel.AbsRect();
			innerRect.left += imagePadding.left;
			innerRect.right -= imagePadding.right;
			innerRect.top += imagePadding.top;
			innerRect.bottom -= imagePadding.bottom;
			g.DrawImageStretched(*image, innerRect);
		}

		IGRWidgetIcon& SetImagePath(cstr imagePath) override
		{
			this->imagePath = imagePath ? imagePath : "";
			image = this->imagePath.length() == 0 ? nullptr : panel.Root().Custodian().CreateImageFromPath("portrait", imagePath);
			return *this;
		}

		Vec2i ImageSpan() const override
		{
			return image ? image->Span() : Vec2i{ 0,0 };
		}

		EGRIconPresentation presentation = EGRIconPresentation::ScaleAgainstFixedHeight;

		void SetPresentation(EGRIconPresentation presentation) override
		{
			presentation = EGRIconPresentation::ScaleAgainstFixedHeight;
		}

		GRAnchorPadding imagePadding{ 0,0,0,0 };

		void SetImagePadding(const GRAnchorPadding& padding) override
		{
			imagePadding = padding;
		}

		EGREventRouting OnChildEvent(GRWidgetEvent&, IGRWidget&) override
		{
			return EGREventRouting::NextHandler;
		}

		Vec2i EvaluateMinimalSpan() const
		{
			Vec2i extraSpan;
			extraSpan.x = panel.Padding().left + panel.Padding().right;
			extraSpan.y = panel.Padding().top + panel.Padding().bottom;
			return image ? image->Span() + extraSpan : extraSpan;
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			auto result = QueryForParticularInterface<IGRWidgetLayout, GRIcon>(this, ppOutputArg, interfaceId);
			if (result == EGRQueryInterfaceResult::SUCCESS)
			{
				return EGRQueryInterfaceResult::SUCCESS;
			}
			
			return QueryForParticularInterface<IGRWidgetIcon, GRIcon>(this, ppOutputArg, interfaceId);
		}

		IGRWidget& Widget()
		{
			return *this;
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRIcon";
		}
	};

	struct GRIconFactory : IGRWidgetFactory
	{
		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			return *new GRIcon(panel);
		}
	};
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetIcon::InterfaceId()
	{
		return "IGRWidgetIcon";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetIcon& CreateIcon(IGRWidget& parent)
	{
		GRANON::GRIconFactory factory;
		auto& gr = parent.Panel().Root().GR();
		auto& widget = gr.AddWidget(parent.Panel(), factory);
		IGRWidgetIcon* icon = Cast<IGRWidgetIcon>(widget);
		return *icon;
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.label-text.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <string>

using namespace Rococo;
using namespace Rococo::Gui;

namespace GRANON
{
	struct GRText : IGRWidgetText, IGRWidgetSupervisor, IGRWidgetLayout
	{
		IGRPanel& panel;
		std::string text;
		GRFontId fontId = GRFontId::NONE;
		GRAlignmentFlags alignment;
		Vec2i spacing { 0,0 };
		EGRSchemeColourSurface labelSurface = EGRSchemeColourSurface::TEXT;
		EGRSchemeColourSurface backSurface = EGRSchemeColourSurface::LABEL_BACKGROUND;
		EGRSchemeColourSurface shadowSurface = EGRSchemeColourSurface::LABEL_SHADOW;

		enum { MAX_LENGTH = 128 };

		GRText(IGRPanel& owningPanel) : panel(owningPanel)
		{
		}

		virtual ~GRText()
		{

		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		void Free() override
		{
			delete this;
		}

		bool expandToFitTextH = false;
		bool expandToFitTextV = false;

		void FitTextH() override
		{
			expandToFitTextH = true;
		}

		void FitTextV() override
		{
			expandToFitTextV = true;
		}

		void LayoutBeforeFit() override
		{
			Vec2i fit = ComputeFit();
			fit.x += panel.Padding().left + panel.Padding().right;
			fit.y += panel.Padding().top + panel.Padding().bottom;
			
			if (expandToFitTextV)
			{
				panel.SetConstantHeight(fit.y);
			}

			if (expandToFitTextH)
			{
				panel.SetConstantWidth(fit.x);
			}
		}

		void LayoutBeforeExpand() override
		{

		}

		void LayoutAfterExpand() override
		{

		}

		Vec2i ComputeFit() const
		{
			return panel.Root().Custodian().EvaluateMinimalSpan(fontId, fstring{ text.c_str(), (int32)text.length() }, {0,0});
		}


		int TextWidth() const override
		{
			return ComputeFit().x;
		}

		EGREventRouting OnCursorClick(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnCursorMove(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{

		}

		EGREventRouting OnKeyEvent(GRKeyEvent&) override
		{
			return EGREventRouting::NextHandler;
		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		void Render(IGRRenderContext& g) override
		{
			auto rect = panel.AbsRect();
			bool isHovered = g.IsHovered(panel);

			GRWidgetRenderState rs(false, isHovered, false);

			RGBAb backColour = panel.GetColour(backSurface, rs);
			g.DrawRect(rect, backColour);

			RGBAb edge1Colour = panel.GetColour(EGRSchemeColourSurface::CONTAINER_TOP_LEFT, rs);
			RGBAb edge2Colour = panel.GetColour(EGRSchemeColourSurface::CONTAINER_BOTTOM_RIGHT, rs);
			g.DrawRectEdge(rect, edge1Colour, edge2Colour);

			GuiRect shadowRect{ rect.left + 1, rect.top + 1, rect.right + 1, rect.bottom + 1 };
			g.DrawText(fontId, shadowRect, alignment, spacing, { text.c_str(), (int32)text.length() }, panel.GetColour(shadowSurface, rs));
			g.DrawText(fontId, rect, alignment, spacing, { text.c_str(), (int32)text.length() }, panel.GetColour(labelSurface, rs));
		}

		EGREventRouting OnChildEvent(GRWidgetEvent&, IGRWidget&)
		{
			return EGREventRouting::NextHandler;
		}

		IGRWidgetText& SetAlignment(GRAlignmentFlags alignment, Vec2i spacing) override
		{
			this->alignment = alignment;
			this->spacing = spacing;
			return *this;
		}

		IGRWidgetText& SetFont(GRFontId fontId) override
		{
			this->fontId = fontId;
			return *this;
		}

		IGRWidgetText& SetText(cstr text) override
		{
			if (strlen(text) > MAX_LENGTH)
			{
				this->text = std::string(text, MAX_LENGTH);
			}
			else
			{
				this->text = text;
			}
			return *this;
		}

		IGRWidgetText& SetTextColourSurface(EGRSchemeColourSurface surface) override
		{
			labelSurface = surface;
			return *this;
		}

		IGRWidgetText& SetTextColourShadowSurface(EGRSchemeColourSurface surface) override
		{
			shadowSurface = surface;
			return *this;
		}

		IGRWidgetText& SetBackColourSurface(EGRSchemeColourSurface surface) override
		{
			backSurface = surface;
			return *this;
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			if (Gui::QueryForParticularInterface<IGRWidgetLayout>(this, ppOutputArg, interfaceId) == EGRQueryInterfaceResult::SUCCESS)
			{
				return  EGRQueryInterfaceResult::SUCCESS;
			}
			
			return Gui::QueryForParticularInterface<IGRWidgetText>(this, ppOutputArg, interfaceId);
		}

		IGRWidget& Widget()
		{
			return *this;
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRText";
		}

		bool IsObscure() const override
		{
			return DoesAncestorObscure(panel);
		}
	};

	struct GRTextFactory : Rococo::Gui::IGRWidgetFactory
	{
		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			return *new GRText(panel);
		}
	} s_TextFactory;
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetText::InterfaceId()
	{
		return "IGRWidgetText";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetText& CreateText(IGRWidget& parent)
	{
		auto& gr = parent.Panel().Root().GR();
		auto* t = Cast<IGRWidgetText>(gr.AddWidget(parent.Panel(), GRANON::s_TextFactory));
		return *t;
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.layout.fullscreen.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.h>
#include <rococo.maths.i32.h>

namespace ANON
{
	using namespace Rococo;
	using namespace Rococo::Gui;

	struct GRLayoutSystem_Fullscreen: IGRLayoutSupervisor
	{
		void Free() override
		{
			delete this;
		}

		void Layout(IGRPanel& panel, const GuiRect& screenRect)
		{
			panel.Resize(Span(screenRect));
		}
	};
}

namespace Rococo::Gui
{
	IGRLayoutSupervisor* CreateFullScreenLayout()
	{
		return new ANON::GRLayoutSystem_Fullscreen();
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.mainframe.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <rococo.ui.h>
#include <rococo.vkeys.h>
#include <rococo.strings.h>

#include <vector>
#include <algorithm>

namespace GRANON
{
	using namespace Rococo;
	using namespace Rococo::Gui;
	using namespace Rococo::Strings;

	struct GRMainFrame: IGRWidgetMainFrameSupervisor, IGRWidgetSupervisor, IGRWidgetLayout, IGRFocusNotifier
	{
		cstr name;
		IGRPanel& panel;
		IGRWidgetDivision* titleBar = nullptr;
		IGRWidgetMenuBar* menuBar = nullptr;
		IGRWidgetToolbar* rhsTools = nullptr;
		IGRWidgetDivision* clientArea = nullptr;

		GRMainFrame(cstr _name, IGRPanel& _panel) : name(_name), panel(_panel)
		{
			_panel.SetLayoutDirection(ELayoutDirection::None);
		}

		virtual ~GRMainFrame()
		{
		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		void LayoutBeforeFit() override
		{
			MakeTitleBar();
			int titleHeight = titleBar->Widget().Panel().Span().y;
			titleBar->Panel().SetParentOffset({ 0,0 });
			clientArea->Panel().SetParentOffset({ 0, titleHeight });
			clientArea->Panel().SetConstantHeight(panel.Span().y - titleHeight);
			clientArea->Panel().SetConstantWidth(panel.Span().x);
		}

		void LayoutBeforeExpand() override
		{

		}

		Vec2i lastComputedSpan{ 0,0 };

		void LayoutAfterExpand() override
		{
			if (panel.Span().x > 0 && panel.Span().y > 0)
			{
				if (lastComputedSpan != panel.Span())
				{
					lastComputedSpan = panel.Span();
					SyncToBestZoomLevel();
				}
			}
		}

		void PostConstruct()
		{
			// We construct the client area first, then the title bar to ensure the title bar and menus are rendered after the client area, causing the menus to be on top

			if (!clientArea)
			{
				clientArea = &CreateDivision(*this);
				clientArea->Panel().SetConstantWidth(0);
				clientArea->Panel().SetConstantHeight(0);
				clientArea->Panel().SetDesc("Frame.Client");
			}

			MakeTitleBar();
		}

		void Render(IGRRenderContext& g)
		{
			DrawPanelBackground(panel, g);
		}

		void Free() override
		{
			delete this;
		}

		struct ZoomScenario
		{
			int minScreenWidth = 0;
			int minScreenHeight = 0;

			std::vector<float> zoomLevels;
		};

		std::vector<ZoomScenario> zoomScenarios;

		void AddZoomScenario(int minScreenWidth, int minScreenHeight, const IValueTypeVectorReader<float>& levels) override
		{
			for (auto& target : zoomScenarios)
			{
				if (target.minScreenHeight == minScreenHeight && target.minScreenWidth == minScreenWidth)
				{
					RaiseError(panel, EGRErrorCode::InvalidArg, __ROCOCO_FUNCTION__, "Duplicate zoom target span (%d, %d)", minScreenWidth, minScreenHeight);
				}

				if ((target.minScreenWidth > minScreenWidth && target.minScreenHeight < minScreenHeight)
					|| (target.minScreenHeight > minScreenHeight && target.minScreenWidth < minScreenWidth)
					)
				{
					RaiseError(panel, EGRErrorCode::InvalidArg, __ROCOCO_FUNCTION__, "Conflicting zoom target span (%d, %d) vs (%d,%d). Width and Height must be both >= or <= other zoom targets", target.minScreenWidth, target.minScreenHeight, minScreenWidth, minScreenHeight);
				}
			}

			size_t nElements = levels.Count();
			if (nElements < 1)
			{
				Throw(0, "No levels specified for ZoomScenario(%d, %d)", minScreenWidth, minScreenHeight);
			}

			ZoomScenario newScenario;
			newScenario.minScreenWidth = minScreenWidth;
			newScenario.minScreenHeight = minScreenHeight;
			newScenario.zoomLevels.resize(nElements);

			for (size_t i = 0; i < nElements; i++)
			{
				newScenario.zoomLevels[i] = levels[i];
			}

			float level0 = newScenario.zoomLevels[0];

			if (level0 < 1.0 || level0 > 100.0f)
			{
				Throw(0, "Level 0 must lie between 1.0 and 100.0");
			}

			float levelIMinus1 = level0;

			for (size_t i = 1; i < nElements; i++)
			{
				float levelI = newScenario.zoomLevels[i];

				if (levelI <= levelIMinus1)
				{
					Throw(0, "Level #d (= %f) must be >= %f, the predecessor", i, levelI, levelIMinus1);
				}

				if (levelI > 100.0)
				{
					Throw(0, "Level #d (= %f) must be <= 100.0", i, levelI);
				}

				levelI = levelIMinus1;
			}

			zoomScenarios.push_back(newScenario);

			// Sort by largest screen ascending
			std::sort(zoomScenarios.begin(), zoomScenarios.end(),
				[](const ZoomScenario& a, const ZoomScenario& b)
				{
					if (a.minScreenWidth < b.minScreenWidth)
					{
						return true;
					}

					if (a.minScreenWidth > b.minScreenWidth)
					{
						return false;
					}

					return a.minScreenHeight < b.minScreenHeight;
				}
			);
		}

		void ClearZoomsScenarios() override
		{
			zoomScenarios.clear();
		}

		const ZoomScenario* GetBestZoomScenario() const
		{
			Vec2i frameSpan = panel.Span();

			if (zoomScenarios.empty())
			{
				return nullptr;
			}

			auto& z0 = zoomScenarios[0];
			if (frameSpan.x < z0.minScreenWidth || frameSpan.y < z0.minScreenHeight)
			{
				return nullptr;
			}

			for (size_t i = 1; i < zoomScenarios.size(); i++)
			{
				auto& z = zoomScenarios[i];
				if (frameSpan.x < z.minScreenWidth || frameSpan.y < z.minScreenHeight)
				{
					return &zoomScenarios[i-1];
				}
			}

			return &zoomScenarios[zoomScenarios.size() - 1];
		}

		void SyncToBestZoomLevel()
		{
			const ZoomScenario* bestScenario = GetBestZoomScenario();
			if (!bestScenario || bestScenario->zoomLevels.empty())
			{
				panel.Root().Custodian().SetUIZoom(1.0f);
				return;
			}

			float zoomLevel = panel.Root().Custodian().ZoomLevel();

			float maxSupportedZoomLevel = bestScenario->zoomLevels.back();

			if (zoomLevel > maxSupportedZoomLevel)
			{
				panel.Root().Custodian().SetUIZoom(zoomLevel);
			}
		}

		EGREventRouting OnCursorClick(GRCursorEvent& ce) override
		{
			if (ce.click.MouseVWheel && ce.context.isShiftHeld)
			{
				const ZoomScenario* bestScenario = GetBestZoomScenario();

				if (bestScenario)
				{
					auto& zoomLevels = bestScenario->zoomLevels;

					float zoomLevel = panel.Root().Custodian().ZoomLevel();

					if (ce.wheelDelta > 0)
					{
						for (size_t i = 0; i < zoomLevels.size() - 1; i++)
						{
							if (zoomLevel <= zoomLevels[i])
							{
								zoomLevel = zoomLevels[i + 1];
								break;
							}
						}
					}
					else if (ce.wheelDelta < 0)
					{
						for (size_t i = zoomLevels.size() - 1; i > 0; i--)
						{
							if (zoomLevel >= zoomLevels[i])
							{
								zoomLevel = zoomLevels[i - 1];
								break;
							}
						}
					}

					panel.Root().Custodian().SetUIZoom(zoomLevel);
					return EGREventRouting::Terminate;
				}
			}
			return EGREventRouting::NextHandler;
		}

		HString hoverHint; // Assigned a value when a mouse move event from some descendant grabs a hint string

		void OnHintHover(const GRWidgetEvent& hint)
		{
			hoverHint = hint.sMetaData;
		}

		EFlowLogic OnDeepChildFocusSet(int64 /* panelId */) override
		{
			// Changing focus zaps the hovered hint. This way focus takes priority when the mouse is not moving.
			hoverHint = "";
			return EFlowLogic::CONTINUE;
		}

		EGREventRouting OnChildEvent(GRWidgetEvent& widgetEvent, IGRWidget&) override
		{
			switch (widgetEvent.eventType)
			{
			case EGRWidgetEventType::ON_HINT_HOVER:
				OnHintHover(widgetEvent);
				return EGREventRouting::Terminate;
			case EGRWidgetEventType::GET_HINT_HOVER:
				widgetEvent.sMetaData = hoverHint;
				return EGREventRouting::Terminate;
			}

			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnCursorMove(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{

		}

		EGREventRouting OnEsc()
		{
			return MoveFocusToAncestor(panel);
		}

		void OnReverseTab()
		{
			SetFocusElseRotateFocusToNextSibling(panel, false);
		}

		void OnTab(bool ctrlHeld)
		{
			bool nextRatherThanPrevious = !ctrlHeld;
			SetFocusElseRotateFocusToNextSibling(panel, nextRatherThanPrevious);
		}

		void OnReturn()
		{
			MoveFocusIntoChildren(panel);
		}

		EGREventRouting Nav(EGRNavigationDirection direction)
		{
			auto* focusWidget = panel.Root().GR().FindFocusWidget();
			if (!focusWidget)
			{
				TrySetDeepFocus(ClientArea().Panel());
				return EGREventRouting::Terminate;
			}

			auto* targetFocus = focusWidget->Panel().Navigate(direction);
			if (targetFocus)
			{
				if (TrySetDeepFocus(*targetFocus) != nullptr)
				{
					return EGREventRouting::Terminate;
				}
			}

			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnKeyEvent(GRKeyEvent& ke) override
		{
			if (ke.osKeyEvent.IsUp())
			{
				switch (ke.osKeyEvent.VKey)
				{
				case Rococo::IO::VirtualKeys::VKCode_ESCAPE:
					return OnEsc();
				case Rococo::IO::VirtualKeys::VKCode_TAB:
					return EGREventRouting::Terminate;
				}
				return EGREventRouting::NextHandler;
			}

			switch (ke.osKeyEvent.VKey)
			{
			case Rococo::IO::VirtualKeys::VKCode_ESCAPE:
				// We trap Escape Is Up above, so we don't want other GUI elements consuming the down event
				return EGREventRouting::Terminate;
			case Rococo::IO::VirtualKeys::VKCode_TAB:
				OnTab(ke.context.isCtrlHeld);
				return EGREventRouting::Terminate;
			case Rococo::IO::VirtualKeys::VKCode_ANTITAB:
				OnReverseTab();
				return EGREventRouting::Terminate;
			case Rococo::IO::VirtualKeys::VKCode_ENTER:
				OnReturn();
				return EGREventRouting::Terminate;
			case Rococo::IO::VirtualKeys::VKCode_LEFT:
				if (Nav(EGRNavigationDirection::Left) == EGREventRouting::NextHandler)
				{
					OnReverseTab();					
				}
				return EGREventRouting::Terminate;
			case Rococo::IO::VirtualKeys::VKCode_RIGHT:
				if (Nav(EGRNavigationDirection::Right) == EGREventRouting::NextHandler)
				{
					OnTab(ke.context.isCtrlHeld);
				}
				return EGREventRouting::Terminate;
			case Rococo::IO::VirtualKeys::VKCode_UP:
				if (Nav(EGRNavigationDirection::Up) == EGREventRouting::NextHandler)
				{
					OnReverseTab();
				}
				return EGREventRouting::Terminate;
			case Rococo::IO::VirtualKeys::VKCode_DOWN:
				if (Nav(EGRNavigationDirection::Down) == EGREventRouting::NextHandler)
				{
					OnTab(ke.context.isCtrlHeld);
				}
				return EGREventRouting::Terminate;
			}
			return EGREventRouting::NextHandler;
		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		IGRWidgetDivision& ClientArea() override
		{
			return *clientArea;
		}

		enum { TOOLBAR_PIXEL_HEIGHT_DEFAULT = 30};

		void MakeTitleBar()
		{
			if (!titleBar)
			{
				titleBar = &CreateDivision(*this);
				titleBar->Panel().SetExpandToParentHorizontally();
				titleBar->Panel().SetConstantHeight(TOOLBAR_PIXEL_HEIGHT_DEFAULT);
				titleBar->Panel().SetLayoutDirection(ELayoutDirection::LeftToRight);
				titleBar->Panel().SetDesc("Frame.TitleBar");
			}
		}

		IGRWidgetMenuBar& MenuBar() override
		{
			MakeTitleBar();

			if (!menuBar)
			{
				menuBar = &CreateMenuBar(titleBar->Widget());
				menuBar->Widget().Panel().SetExpandToParentHorizontally();
				menuBar->Widget().Panel().SetExpandToParentVertically();
				menuBar->Widget().Panel().SetDesc("Frame.TitleBar.MenuBar");
			}

			return *menuBar;
		}

		IGRWidgetToolbar& TopRightHandSideTools() override
		{
			MakeTitleBar();

			if (!rhsTools)
			{
				rhsTools = &CreateToolbar(titleBar->Widget());
				rhsTools->Widget().Panel().SetDesc("Frame.TitleBar.RHS");
			}

			return *rhsTools;
		}

		IGRWidget& Widget() override
		{
			return *this;
		}

		IGRWidgetSupervisor& WidgetSupervisor() override
		{
			return *this;
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			auto result = Gui::QueryForParticularInterface<IGRWidgetLayout>(this, ppOutputArg, interfaceId);
			if (result == EGRQueryInterfaceResult::SUCCESS)
			{
				return result;
			}

			result = Gui::QueryForParticularInterface<IGRFocusNotifier>(this, ppOutputArg, interfaceId);
			if (result == EGRQueryInterfaceResult::SUCCESS)
			{
				return result;
			}

			return Gui::QueryForParticularInterface<IGRWidgetMainFrame>(this, ppOutputArg, interfaceId);
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRMainFrame";
		}
	};
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetMainFrame::InterfaceId()
	{
		return "IGRWidgetMainFrame";
	}

	IGRWidgetMainFrameSupervisor* CreateGRMainFrame(cstr name, IGRPanel& panel)
	{
		auto* frame = new GRANON::GRMainFrame(name, panel);
		frame->PostConstruct();
		return frame;
	}

	ROCOCO_GUI_RETAINED_API void DrawPanelBackground(IGRPanel& panel, IGRRenderContext& g)
	{
		GRWidgetRenderState rs(false, false, false);
		RGBAb colour = panel.GetColour(EGRSchemeColourSurface::BACKGROUND, rs);
		g.DrawRect(panel.AbsRect(), colour);
	}

	ROCOCO_GUI_RETAINED_API void RotateFocusToNextSibling(IGRWidget& focusWidget, bool nextRatherThanPrevious)
	{
		auto* parent = focusWidget.Panel().Parent();
		if (!parent)
		{
			return;
		}

		int nChildren = parent->EnumerateChildren(nullptr);

		for (int i = 0; i < nChildren; i++)
		{
			auto* child = parent->GetChild(i);
			if (child->Widget() == focusWidget)
			{
				if (nextRatherThanPrevious)
				{
					for (int j = i + 1; j < nChildren; j++)
					{
						auto* sibling = parent->GetChild(j);
						if (TrySetDeepFocus(*sibling))
						{
							return;
						}
					}

					// Nothing following the child was focusable, so try to roll back to the beginning

					if (i > 0)
					{
						for (int k = 0; k < i; k++)
						{
							auto* sibling = parent->GetChild(k);
							if (TrySetDeepFocus(*sibling))
							{
								return;
							}
						}
					}
				}
				else
				{
					for (int j = i - 1; j >= 0; j--)
					{
						auto* sibling = parent->GetChild(j);
						if (TrySetDeepFocus(*sibling))
						{
							return;
						}
					}

					for (int k = nChildren - 1; k > i; k--)
					{
						auto* sibling = parent->GetChild(k);
						if (TrySetDeepFocus(*sibling))
						{
							return;
						}
					}
				}

				// No sibling could take focus, so roll back to container;
				RotateFocusToNextSibling(parent->Widget(), nextRatherThanPrevious);
				return;
			}
		}
	}

	static void SetNewFocus(IGRPanel& panel, bool nextRatherThanPrevious)
	{
		DescAndIndex target = nextRatherThanPrevious ? panel.GetNextNavigationTarget(nullptr) : panel.GetPreviousNavigationTarget(nullptr);
		if (target.desc)
		{
			auto* targetPanel = panel.FindDescendantByDesc(target.desc);
			if (targetPanel)
			{
				TrySetDeepFocus(*targetPanel);
				return;
			}

			RaiseError(panel, EGRErrorCode::InvalidArg, __ROCOCO_FUNCTION__, "Unknown navigation target: %s. Source (%s)", target.desc, panel.Desc());
		}

		TrySetDeepFocus(panel);
	}

	ROCOCO_GUI_RETAINED_API void SetFocusElseRotateFocusToNextSibling(IGRPanel& panel, bool nextRatherThanPrevious)
	{
		auto* focusWidget = panel.Root().GR().FindFocusWidget();
		if (focusWidget == nullptr)
		{
			SetNewFocus(panel, nextRatherThanPrevious);
			return;
		}

		cstr desc = focusWidget->Panel().Desc();
		DescAndIndex nextTarget = nextRatherThanPrevious ? panel.GetNextNavigationTarget(desc) : panel.GetPreviousNavigationTarget(desc);
		if (nextTarget.index >= 0)
		{
			auto* nextPanel = panel.FindDescendantByDesc(nextTarget.desc);
			if (nextPanel)
			{
				TrySetDeepFocus(*nextPanel);
				return;
			}

			RaiseError(panel, EGRErrorCode::InvalidArg, __ROCOCO_FUNCTION__, "Unknown navigation target: %s. Source (%s)", nextTarget.desc, panel.Desc());
		}

		RotateFocusToNextSibling(*focusWidget, nextRatherThanPrevious);
	}

	ROCOCO_GUI_RETAINED_API void MoveFocusIntoChildren(IGRPanel& panel)
	{
		auto* focusWidget = panel.Root().GR().FindFocusWidget();
		if (!focusWidget)
		{
			panel.Root().GR().SetFocus(-1);
			return;
		}

		IGRPanel* newChildFocus = nullptr;

		int nChildren = focusWidget->Panel().EnumerateChildren(nullptr);
		for (int i = 0; i < nChildren; i++)
		{
			auto* child = focusWidget->Panel().GetChild(i);
			newChildFocus = TrySetDeepFocus(*child);
			if (newChildFocus)
			{
				return;
			}
		}

		GetCustodian(panel).AlertNoActionForKey();
	}

	ROCOCO_GUI_RETAINED_API EGREventRouting MoveFocusToAncestor(IGRPanel& panel)
	{
		auto* focusWidget = panel.Root().GR().FindFocusWidget();
		if (!focusWidget)
		{
			panel.Root().GR().SetFocus(-1);
			return EGREventRouting::NextHandler;
		}

		for (auto* ancestor = focusWidget->Panel().Parent(); ancestor != nullptr; ancestor = ancestor->Parent())
		{
			if (ancestor->HasFlag(EGRPanelFlags::AcceptsFocus))
			{
				ancestor->FocusAndNotifyAncestors();
				return EGREventRouting::Terminate;
			}
		}

		panel.Root().GR().SetFocus(-1);
		return EGREventRouting::Terminate;
	}

	ROCOCO_GUI_RETAINED_API IGRSystemSubRenderer& GetDefaultFocusRenderer()
	{
		struct FocusRenderer : Gui::IGRSystemSubRenderer
		{
			void Render(IGRPanel& panel, IGRRenderContext& g, const GuiRect& clipRect) override
			{
				g.EnableScissors(clipRect);
				g.DrawRect(panel.AbsRect(), RGBAb(255, 255, 0, 32), panel.RectStyle(), panel.CornerRadius());
				g.DisableScissors();
			}
		}
		
		static s_FocusRenderer;
		return s_FocusRenderer;
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.menubar.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <string>
#include <vector>
#include <unordered_map>

using namespace Rococo;
using namespace Rococo::Gui;

namespace GRANON
{
	struct MenuBranch;

	struct MenuButton
	{
		std::string text;
		int64 iMetaData;
		std::string sMetaData;
		int isEnabled : 1;
		int isEventHandlerCppOnly : 1;
	};

	struct MenuItem
	{
		MenuBranch* branch = nullptr;
		MenuButton* button = nullptr;
	};

	struct GRMenuTree
	{
		MenuBranch* root = nullptr;

		std::unordered_map<int64, MenuBranch*> mapIdToBranch;

		~GRMenuTree();

		MenuBranch* FindBranch(GRMenuItemId idContainer)
		{
			auto branchId = mapIdToBranch.find(idContainer.id);
			return (branchId != mapIdToBranch.end()) ? branchId->second : nullptr;
		}

		void Deactivate();

		bool IsActive() const;

		void Clear();
	};

	struct MenuBranch
	{
		MenuBranch* parent = nullptr;
		GRMenuTree& tree;
		GRMenuItemId id;
		std::string text;
		std::vector<MenuItem> children;
		uint32 isEnabled : 1;
		uint32 isActive : 1;

		MenuBranch(GRMenuTree& _tree, int64 _id, MenuBranch* _parent) : parent(_parent), tree(_tree), id({ _id }), isEnabled(0), isActive(0)
		{
			_tree.mapIdToBranch[_id] = this;
		}

		int32 GetFirstActiveBranchIndex() const
		{
			int32 index = 0;
			for (auto& child : children)
			{
				if (child.branch && child.branch->isActive)
				{
					return index;
				}
				index++;
			}
			return -1;
		}

		~MenuBranch()
		{
			tree.mapIdToBranch.erase(id.id);

			for (auto& subMenu : children)
			{
				delete subMenu.branch;
				delete subMenu.button;
			}
		}

		void ToggleActive()
		{
			isActive = isActive ? 0 : 1;

			// Making a branch active makes all of its siblings inactive

			if (parent)
			{
				for (auto& sibling : parent->children)
				{
					if (sibling.branch && sibling.branch != this)
					{
						sibling.branch->isActive = false;
					}
				}
			}
		}

		void Deactivate()
		{
			isActive = false;
			for (auto& child : children)
			{
				if (child.branch)
				{
					child.branch->Deactivate();
				}
			}
		}
	};

	GRMenuTree::~GRMenuTree()
	{
		delete root;
	}

	void GRMenuTree::Deactivate()
	{
		root->Deactivate();
	}

	bool GRMenuTree::IsActive() const
	{
		for (auto& child : root->children)
		{
			if (child.branch && child.branch->isActive)
			{
				return true;
			}
		}

		return false;
	}

	void GRMenuTree::Clear()
	{
		delete root; 
		mapIdToBranch.clear();
		auto rootId = 0;
		root = new MenuBranch(*this, rootId, nullptr);
	}

	struct GRMenuBar : IGRWidgetMenuBar, IGRWidgetSupervisor, IGRWidgetLayout
	{
		IGRPanel& panel;
		GRMenuTree tree;
		int64 nextId = 1;	
		bool isDirty = true;

		GRMenuBar(IGRPanel& owningPanel) : panel(owningPanel)
		{
			owningPanel.SetLayoutDirection(ELayoutDirection::None);
			if (owningPanel.Parent() == nullptr)
			{
				// We require a parent so that we can anchor to its dimensions
				RaiseError(owningPanel, EGRErrorCode::InvalidArg, __ROCOCO_FUNCTION__, "Panel parent was null");
				return;
			}
			auto rootId = 0;
			tree.root = new MenuBranch(tree, rootId, nullptr);
		}

		virtual ~GRMenuBar()
		{

		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		bool AddButton(GRMenuItemId parentMenu, const GRMenuButtonItem& item) override
		{
			auto* branch = tree.FindBranch(parentMenu);
			if (!branch)
			{
				RaiseError(panel, EGRErrorCode::InvalidArg, __ROCOCO_FUNCTION__, "No sub menu found with matching id");
				return false;
			}

			GRANON::MenuItem newMenuItem;
			auto* b = newMenuItem.button = new MenuButton();
			b->iMetaData = item.metaData.intData;
			b->sMetaData = item.metaData.stringData ? item.metaData.stringData : std::string();
			b->isEnabled = item.isEnabled;
			b->text = item.text;
			b->isEventHandlerCppOnly = item.isImplementedInCPP;

			branch->children.push_back(newMenuItem);

			isDirty = true;

			return true;
		}

		GRMenuItemId AddSubMenu(GRMenuItemId parentMenu, const GRMenuSubMenu& subMenu) override
		{
			auto* parent = tree.FindBranch(parentMenu);
			if (!parent)
			{
				RaiseError(panel, EGRErrorCode::InvalidArg, __ROCOCO_FUNCTION__, "No sub menu found with matching id");
				return GRMenuItemId{ -1 };
			}

			for (auto& c : parent->children)
			{
				if (c.branch && c.branch->text == subMenu.text)
				{
					return c.branch->id;
				}
			}

			GRANON::MenuItem newMenuItem;
			int64 branchId = nextId++;
			auto* b = newMenuItem.branch = new MenuBranch(tree, branchId, parent);
			b->isEnabled = subMenu.isEnabled;
			b->text = subMenu.text;

			parent->children.push_back(newMenuItem);

			isDirty = true;

			return GRMenuItemId{ branchId };
		}

		void ClearMenus() override
		{
			tree.Clear();
			isDirty = true;
		}

		enum { BUTTON_X_PADDING = 10 };

		Vec2i ShrinkPanelToFitText(IGRWidgetButton& button, Vec2i& lastPos)
		{
			Vec2i minimalSpan = button.MinimalSpan();
			Vec2i newSpan = { minimalSpan.x + 2 * BUTTON_X_PADDING,  minimalSpan.y };
			button.Panel().SetParentOffset({ lastPos.x, -lastPos.y });
			button.Panel().SetConstantWidth(newSpan.x);
			button.Panel().SetExpandToParentVertically();
			lastPos.x += newSpan.x + 1;
			return minimalSpan;
		}

		Vec2i ConstructButtonFromMenuItem(MenuItem& item, Vec2i& lastPos)
		{
			GRAlignmentFlags alignment;
			alignment.Add(EGRAlignment::Left).Add(EGRAlignment::VCentre);

			if (item.button != nullptr)
			{
				auto& button = CreateMenuButton(*this);
				button.SetTitle(item.button->text.c_str());
				button.SetMetaData({ item.button->iMetaData, item.button->sMetaData.c_str() }, item.button->isEventHandlerCppOnly);
				button.SetEventPolicy(EGREventPolicy::NotifyAncestors);
				button.SetClickCriterion(EGRClickCriterion::OnDownThenUp);
				button.SetAlignment(alignment, { BUTTON_X_PADDING,0});
				return ShrinkPanelToFitText(button, lastPos);
			}
			else if (item.branch != nullptr)
			{
				auto& button = CreateMenuButton(*this, true);
				button.SetTitle(item.branch->text.c_str());
				button.SetMetaData({ item.branch->id.id, "<sub-menu-id>" }, false);
				button.SetEventPolicy(EGREventPolicy::NotifyAncestors);
				button.SetClickCriterion(EGRClickCriterion::OnDownThenUp);
				button.SetAlignment(alignment, { BUTTON_X_PADDING,0 });
				return ShrinkPanelToFitText(button, lastPos);
			}
			else
			{
				return { 0,0 };
			}
		}

		int32 maxDepth = 0;

		void ConstructWidgetsFromBranchRecursive(IGRPanel& origin, MenuBranch& branch, int depth, Vec2i startPos, Vec2i barSpan)
		{
			UNUSED(origin);

			Vec2i lastPos = startPos;

			Vec2i largestMinimalSpan {0, 0};

			int32 currentChildCount = panel.EnumerateChildren(nullptr);

			for (auto& child : branch.children)
			{
				Vec2i minimalSpan = ConstructButtonFromMenuItem(child, lastPos);
				largestMinimalSpan.x = max(minimalSpan.x, largestMinimalSpan.x);
				largestMinimalSpan.y = max(minimalSpan.y, largestMinimalSpan.y);
			}			

			largestMinimalSpan.y = 0;

			if (depth > 0)
			{
				if (depth > 1)
				{
					maxDepth = depth;
				}
				// Move the new children in a vertical row aligned to the longest menu item amongst them
				Vec2i vertPos = startPos;
				int32 newChildCount = panel.EnumerateChildren(nullptr);

				for (int32 i = currentChildCount; i < newChildCount; ++i)
				{
					IGRPanel* newChildPanel = panel.GetChild(i);
					if (newChildPanel)
					{
						newChildPanel->SetConstantHeight(largestMinimalSpan.y);
						newChildPanel->SetConstantWidth(largestMinimalSpan.x + 2 * BUTTON_X_PADDING);
						newChildPanel->Resize({ largestMinimalSpan.x + 2 * BUTTON_X_PADDING, largestMinimalSpan.y });
						newChildPanel->SetParentOffset(vertPos);
						vertPos.y += largestMinimalSpan.y;
					}
				}
			}

			int32 activeBranchIndex = branch.GetFirstActiveBranchIndex();
			if (activeBranchIndex >= 0)
			{
				IGRPanel* activeBranchChild;
				if ((activeBranchChild = panel.GetChild(currentChildCount + activeBranchIndex)) != nullptr)
				{
					Vec2i branchPos;
					if (depth == 0)
					{
						// Our menu line appears vertically under the parent menu button
						branchPos = activeBranchChild->ParentOffset() + Vec2i{ 0, panel.Span().y - (panel.Padding().top + panel.Padding().bottom )};
					}
					else
					{
						// Our menu line appears to the right of the parent menu button
						branchPos = activeBranchChild->ParentOffset() + Vec2i{ activeBranchChild->Span().x, 0 };
					}
					ConstructWidgetsFromBranchRecursive(*activeBranchChild, *branch.children[activeBranchIndex].branch, depth + 1, branchPos, barSpan);
				}
			}
		}

		void ConstructWidgetsFromMenuTree()
		{
			// It should be safe to clear children here, because they are not yet within our callstack
			static_cast<IGRPanelSupervisor&>(panel).ClearChildren();
			Vec2i iconSpan = panel.Span();
			ConstructWidgetsFromBranchRecursive(panel, *tree.root, 0, { 0, 0 }, iconSpan);
		}

		void LayoutItems()
		{
			if (panel.GetChild(0) == nullptr)
			{
				panel.Resize({ 1,1 });
				return;
			}

			int spanX = 0;

			int index = 0;
			while (auto* child = panel.GetChild(index++))
			{
				int rightMostX = child->ParentOffset().x + child->Span().x;
				spanX = max(spanX, rightMostX);
			}

			panel.Resize({ spanX, panel.Span().y });
		}

		void Free() override
		{
			delete this;
		}

		void LayoutBeforeFit() override
		{

		}

		void LayoutBeforeExpand() override
		{
			if (isDirty)
			{
				ConstructWidgetsFromMenuTree();
				isDirty = false;
			}
		}

		void LayoutAfterExpand() override
		{
		}

		EGREventRouting OnCursorClick(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			if (tree.IsActive())
			{
				tree.Deactivate();
				isDirty = true;
				panel.Root().ReleaseCursor();
				return EGREventRouting::Terminate;
			}
			else
			{
				return EGREventRouting::NextHandler;
			}
		}

		EGREventRouting OnCursorMove(GRCursorEvent& ce) override
		{
			if (tree.IsActive())
			{
				int index = 0;
				IGRPanel* buttonPanel;
				while ((buttonPanel = panel.GetChild(index++)) != nullptr)
				{
					if (IsPointInRect(ce.position, buttonPanel->AbsRect()))
					{
						IGRWidgetButton* button = Cast<IGRWidgetButton>(buttonPanel->Widget());
						if (button && button->ButtonFlags().forSubMenu)
						{
							// In a submenu the meta data is synonymous with the branch id and was not provided by the consumer of the API
							int64 branchId = button->MetaData().intData; 
							auto* branch = tree.FindBranch(GRMenuItemId{ branchId });
							if (branch)
							{
								if (!branch->isActive)
								{
									branch->ToggleActive();
									isDirty = true;
								}
							}
						}
						break;
					}
				}
			}
			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{

		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		void Render(IGRRenderContext&) override
		{
			panel.SetClipChildren(!tree.IsActive());
		}

		EGREventRouting OnChildEvent(GRWidgetEvent& widgetEvent, IGRWidget& sourceWidget)
		{
			if (widgetEvent.eventType == EGRWidgetEventType::BUTTON_CLICK)
			{
				IGRWidgetButton* button = Cast<IGRWidgetButton>(sourceWidget);
				if (!button) return EGREventRouting::NextHandler;

				auto flags = button->ButtonFlags();
				if (flags.forSubMenu)
				{
					int64 branchId = button->MetaData().intData;
					// In a submenu the meta data is synonymous with the branch id and was not provided by the consumer of the API
					auto* branch = tree.FindBranch(GRMenuItemId{ branchId });// WTF
					if (branch)
					{
						branch->ToggleActive();
						isDirty = true;
						if (tree.IsActive()) panel.CaptureCursor();
					}
					return EGREventRouting::Terminate;
				}
				else
				{
					tree.Deactivate();
					isDirty = true;
				}

				panel.Root().ReleaseCursor();
			}

			return RouteEventToHandler(panel, widgetEvent);
		}

		EGREventRouting OnKeyEvent(GRKeyEvent&) override
		{
			return EGREventRouting::NextHandler;
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			if (DoInterfaceNamesMatch(interfaceId, IGRWidgetLayout::InterfaceId()))
			{
				if (ppOutputArg)
				{
					*ppOutputArg = (IGRWidgetLayout*)this;
				}
				return EGRQueryInterfaceResult::SUCCESS;
			}
			return Gui::QueryForParticularInterface<IGRWidgetMenuBar>(this, ppOutputArg, interfaceId);
		}

		IGRWidget& Widget()
		{
			return *this;
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRMenuBar";
		}
	};

	struct GRMenuBarFactory : IGRWidgetFactory
	{
		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			return *new GRMenuBar(panel);
		}
	} s_MenuBarFactory;
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetMenuBar::InterfaceId()
	{
		return "IGRWidgetMenuBar";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetMenuBar& CreateMenuBar(IGRWidget& parent)
	{
		auto& gr = parent.Panel().Root().GR();
		auto& bar = static_cast<GRANON::GRMenuBar&>(gr.AddWidget(parent.Panel(), GRANON::s_MenuBarFactory));
		return bar;
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.panel.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <vector>
#include <rococo.maths.i32.h>
#include <rococo.maths.h>

#define ROCOCO_USE_SAFE_V_FORMAT
#include <rococo.strings.h>

using namespace Rococo::Strings;

namespace GRANON
{
	using namespace Rococo;
	using namespace Rococo::Gui;

	static int64 nextId = 1;

	struct PaddingBools
	{
		int isLeft : 1;
		int isRight: 1;
		int isTop  : 1;
		int isBottom : 1;
	};

	struct GRPanel: IGRPanelSupervisor
	{
		GRPanel* parent;
		IGRPanelRootSupervisor& root;
		IGRWidgetSupervisor* widget = nullptr; // Should always be set immediately after construction
		Vec2i parentOffset{ 0,0 };
		Vec2i span { 0, 0};
		std::vector<GRPanel*> children;
		int64 uniqueId;
		GuiRect absRect{ 0,0,0,0 };
		GRAnchorPadding padding = { 0 };
		bool isMarkedForDeletion = false;
		AutoFree<IGRSchemeSupervisor> scheme;
		bool preventInvalidationFromChildren = false;
		bool isCollapsed = false;
		bool isRenderingLast = false;
		int64 refCount = 0;
		int64 flags = 0;
		int32 childPadding = 0;
		HString desc;
		const Sex::ISExpression* associatedSExpression = nullptr;
		IGRPanelSupervisor* clippingPanel;
		int32 cornerRadius = 4;

		// Currently only used by GradientFill widgets, but we have plans to change fill style more generally across widgets, so is defined here.
		EGRFillStyle fillStyle = EGRFillStyle::SOLID;

		EGRRectStyle rectStyle = EGRRectStyle::SHARP;

		GRPanel(IGRPanelRootSupervisor& _root, IGRPanelSupervisor* _parent): parent(static_cast<GRPanel*>(_parent)), root(_root), uniqueId(nextId++), clippingPanel(this)
		{
			refCount = 1;
		}

		void OnTick(float dt) override
		{
			widget->OnTick(dt);

			for (auto* child : children)
			{
				child->OnTick(dt);
			}
		}

		std::vector<HString> navigationTargets;

		void AddNavigationTarget(cstr target) override
		{
			if (navigationTargets.empty())
			{
				enum { INIT_NAVTARGET_SIZE = 8 };
				navigationTargets.reserve(INIT_NAVTARGET_SIZE);
			}
			navigationTargets.push_back(target);
		}

		int GetNavigationIndex(cstr panelDesc) const
		{
			int index = -1;

			if (panelDesc != nullptr)
			{
				for (int i = 0; i < (int)navigationTargets.size(); i++)
				{
					if (Eq(navigationTargets[i], panelDesc))
					{
						index = i;
					}
				}
			}

			return index;
		}

		DescAndIndex GetNextNavigationTarget(cstr panelDesc) override
		{
			if (navigationTargets.empty())
			{
				return { nullptr , -1 };
			}

			int index;

			int foundIndex = GetNavigationIndex(panelDesc);
			if (foundIndex == -1)
			{
				index = 0;
			}
			else
			{
				index = (foundIndex + 1) % (int)navigationTargets.size();
			}

			return { navigationTargets[index], foundIndex };
		}

		DescAndIndex GetPreviousNavigationTarget(cstr panelDesc) override
		{
			int index;

			int foundIndex = GetNavigationIndex(panelDesc);
			if (foundIndex == -1)
			{
				return { HString(), -1 };
			}
			else if (foundIndex == 0)
			{
				index = (int)navigationTargets.size() - 1;
			}
			else
			{
				index = (foundIndex - 1) % (int)navigationTargets.size();
			}

			return { navigationTargets[index], foundIndex };
		}

		HString directions[static_cast<int>(EGRNavigationDirection::Count)-1];

		IGRPanel& Set(EGRNavigationDirection direction, cstr targetDescription) override
		{
			int index = static_cast<int>(direction);

			if (index <= 0 || index >= static_cast<int>(EGRNavigationDirection::Count))
			{
				RaiseError(*this, EGRErrorCode::InvalidArg, __ROCOCO_FUNCTION__, "Bad [direction] %d", index);
			}
			else
			{
				directions[index - 1] = targetDescription == nullptr ? "" : targetDescription;
			}
			return *this;
		}

		IGRPanel* Navigate(EGRNavigationDirection direction) override
		{
			int index = static_cast<int>(direction);

			if (index <= 0 || index >= static_cast<int>(EGRNavigationDirection::Count))
			{
				RaiseError(*this, EGRErrorCode::InvalidArg, __ROCOCO_FUNCTION__, "Bad [direction] %d", index);
				return nullptr;
			}

			cstr description = directions[index - 1].c_str();
			if (*description == 0)
			{
				return nullptr;
			}

			auto* owner = FindOwner(*widget);
			if (!owner)
			{
				return nullptr;
			}

			return owner->Panel().FindDescendantByDesc(description);
		}

		IGRPanel* FindDescendantByDesc(cstr desc)
		{
			if (desc == nullptr)
			{
				return nullptr;
			}

			for (auto child : children)
			{
				if (Eq(child->desc, desc))
				{
					return child;
				}
			}

			for (auto child : children)
			{
				IGRPanel* candidate = child->FindDescendantByDesc(desc);
				if (candidate)
				{
					return candidate;
				}
			}

			return nullptr;
		}

		void SetClippingPanel(IGRPanel* panel) override
		{
			this->clippingPanel = static_cast<IGRPanelSupervisor*>(panel);
		}

		IGRPanel& SetCornerRadius(int radius) override
		{
			cornerRadius = radius;
			return *this;
		}

		int CornerRadius() const override
		{
			return cornerRadius;
		}

		IGRPanel& SetFillStyle(EGRFillStyle style) override
		{
			fillStyle = style;
			return *this;
		}

		EGRFillStyle FillStyle() const override
		{
			return fillStyle;
		}

		IGRPanel& SetRectStyle(EGRRectStyle style) override
		{
			rectStyle = style;
			return *this;
		}

		EGRRectStyle RectStyle() const override
		{
			return rectStyle;
		}

		void ClearAssociatedExpressions() override
		{
			associatedSExpression = nullptr;
			for (auto* child : children)
			{
				child->ClearAssociatedExpressions();
			}
		}

		const Sex::ISExpression* GetAssociatedSExpression() const override
		{
			return associatedSExpression;
		}

		void SetAssociatedSExpression(Sex::cr_sex s) override
		{
			associatedSExpression = &s;
		}

		IGRPanel& Add(EGRPanelFlags flag) override
		{
			flags |= (int64) flag;
			return *this;
		}

		void AppendDesc(Strings::StringBuilder& sb) override
		{
			sb.AppendFormat("%s (id %lld)", desc.c_str(), Id());
		}

		void PrepPanelAndDescendantsRecursive(IGRPanel& owningPanel)
		{
			for (auto& target : navigationTargets)
			{
				auto* targetPanel = owningPanel.FindDescendantByDesc(target);
				if (!targetPanel)
				{
					RaiseError(*this, EGRErrorCode::Generic, __ROCOCO_FUNCTION__, "Could not find navigation target \"%s\"", target.c_str());
					return;
				}
			}

			for (auto& direction : directions)
			{
				if (direction.length() == 0)
				{
					continue;
				}

				auto* targetPanel = owningPanel.FindDescendantByDesc(direction);
				if (!targetPanel)
				{
					RaiseError(*this, EGRErrorCode::Generic, __ROCOCO_FUNCTION__, "Could not find direction target \"%s\"", direction.c_str());
					return;
				}
			}

			auto* initializer = Cast<IGRWidgetInitializer>(*widget);
			if (initializer)
			{
				initializer->Prep();
			}

			for (auto* child : children)
			{
				child->PrepPanelAndDescendantsRecursive(owningPanel);
			}
		}

		void PrepPanelAndDescendants() override
		{
			auto* owner = FindOwner(*widget);
			if (!owner)
			{
				RaiseError(*this, EGRErrorCode::Generic, __ROCOCO_FUNCTION__, "No owner!");
				return;
			}

			PrepPanelAndDescendantsRecursive(owner->Panel());
		}

		cstr Desc() const override
		{
			return desc;
		}

		void SetDesc(cstr text) override
		{
			desc = text;
		}

		HString hint;

		void SetHint(cstr text) override
		{
			hint = text;
		}

		cstr Hint() const override
		{
			return hint;
		}

		bool HasFlag(EGRPanelFlags flag) const override
		{
			return (flags & (int64)flag) != 0;
		}

		IGRPanel& Remove(EGRPanelFlags flag) override
		{
			flags &= ~(int64)flag;
			return *this;
		}

		virtual ~GRPanel()
		{
			if (widget) widget->Free();
			static_cast<IGRSystemSupervisor&>(root.GR()).NotifyPanelDeleted(uniqueId);
			ClearChildren();
		}

		bool HasFocus() const override
		{
			return Root().GR().GetFocusId() == Id();
		}

		IGRPanel& FocusAndNotifyAncestors() override
		{
			Root().GR().SetFocus(Id());

			for (auto* target = this->parent; target != nullptr; target = target->parent)
			{
				auto* focusNotifier = Cast<IGRFocusNotifier>(target->Widget());
				if (focusNotifier)
				{
					EFlowLogic flow = focusNotifier->OnDeepChildFocusSet(Id());
					if (flow == EFlowLogic::BREAK)
					{
						break;
					}
				}
			}

			return *this;
		}

		bool IsCollapsed() const override
		{
			return isCollapsed;
		}

		bool IsCollapsedOrAncestorCollasped() const override
		{
			if (isCollapsed)
			{
				return true;
			}

			if (parent)
			{
				return parent->IsCollapsedOrAncestorCollasped();
			}
			else
			{
				return false;
			}
		}

		void MarkForDelete() override
		{
			isMarkedForDeletion = true;
			root.QueueGarbageCollect();
		}

		bool IsMarkedForDeletion() const override
		{
			return isMarkedForDeletion;
		}

		GRAnchorPadding Padding() override
		{
			GRAnchorPadding modulatedPadding;
			modulatedPadding.left = paddingsArePercentages.isLeft ? padding.left * Span().x / 100  : padding.left;
			modulatedPadding.right = paddingsArePercentages.isRight ? padding.right * Span().x / 100 : padding.right;
			modulatedPadding.top = paddingsArePercentages.isTop ? padding.top * Span().y / 100 : padding.top;
			modulatedPadding.bottom = paddingsArePercentages.isBottom ? padding.bottom * Span().y / 100 : padding.bottom;			
			return modulatedPadding;
		}

		IGRPanel& Set(GRAnchorPadding padding) override
		{
			this->padding = padding;
			return *this;
		}

		IGRPanel* GetChild(int32 index) override
		{
			if (index < 0 || index >= children.size())
			{
				return nullptr;
			}

			return children[index];
		}

		void ClearChildren() override
		{
			// We want to preserve the integrity of the children field during destruction, in case a widget destructor enumerates children
			// So we destruct it one member at a time, removing the member first
			while (!children.empty())
			{
				auto* child = children.back();
				children.pop_back();
				child->ReleasePanel();
			}
		}

		int32 EnumerateChildren(IEventCallback<IGRPanel>* callback) override
		{
			if (callback)
			{
				for (auto* child : children)
				{
					callback->OnEvent(*child);
				}
			}

			return (int32) children.size();
		}

		int64 Id() const override
		{
			return uniqueId;
		}

		EGREventRouting NotifyAncestors(GRWidgetEvent& event, IGRWidget& sourceWidget) override
		{
			if (parent == nullptr)
			{
				return EGREventRouting::NextHandler;
			}

			if (parent->Widget().Manager().OnChildEvent(event, sourceWidget) == EGREventRouting::Terminate)
			{
				return EGREventRouting::Terminate;
			}

			return parent->NotifyAncestors(event, sourceWidget);
		}

		enum class ESizingRule
		{
			Constant,
			ConstantPercentage,
			ExpandToParent,
			FitChildren
		};
		
		ESizingRule widthSizing = ESizingRule::Constant;
		ESizingRule heightSizing = ESizingRule::Constant;

		ELayoutDirection layoutDirection = ELayoutDirection::LeftToRight;

		int SumChildWidth()
		{
			int sum = 0;

			for (auto* child : children)
			{
				if (child->isCollapsed)
				{
					continue;
				}

				sum += child->Span().x;
			}

			return sum;
		}

		int MaxChildWidth()
		{
			int m = 0;

			for (auto* child : children)
			{
				if (child->isCollapsed)
				{
					continue;
				}

				m = max(child->Span().x, m);
			}

			return m;
		}

		int SumChildHeight()
		{
			int sum = 0;

			for (auto* child : children)
			{
				if (child->isCollapsed)
				{
					continue;
				}

				sum += child->Span().y;
			}

			return sum;
		}

		int MaxChildHeight()
		{
			int m = 0;

			for (auto* child : children)
			{
				if (child->isCollapsed)
				{
					continue;
				}

				m = max(child->Span().y, m);
			}

			return m;
		}

		void Layout() override
		{
			SetPanelLayoutRecursive(ELayoutPhase::BeforeFit);			
			ShrinkToFitRecursive();

			SetPanelLayoutRecursive(ELayoutPhase::BeforeExpand);
			ExpandToParentRecursive();

			SetPanelLayoutRecursive(ELayoutPhase::AfterExpand);
			SetAbsRectRecursive();
		}

		enum class ELayoutPhase
		{
			BeforeFit,
			BeforeExpand,
			AfterExpand
		};

		void SetPanelLayoutRecursive(ELayoutPhase phase)
		{
			auto* layout = Cast<IGRWidgetLayout>(Widget());
			if (layout)
			{
				switch (phase)
				{
				case ELayoutPhase::BeforeFit:
					layout->LayoutBeforeFit();
					break;
				case ELayoutPhase::BeforeExpand:
					layout->LayoutBeforeExpand();
					break;
				default:
					layout->LayoutAfterExpand();
					break;
				}
			}

			for (auto* child : children)
			{
				if (child->isCollapsed)
				{
					continue;
				}

				child->SetPanelLayoutRecursive(phase);
			}
		}

		void SetAbsRectRecursive()
		{
			absRect.left = parent ? parent->absRect.left : 0;
			absRect.left += parentOffset.x + (parent ? parent->Padding().left : 0);

			absRect.top = parent ? parent->absRect.top : 0;
			absRect.top += parentOffset.y + (parent ? parent->Padding().top : 0);
			absRect.right = absRect.left + Span().x;
			absRect.bottom = absRect.top + Span().y;

			if (watcher)
			{
				watcher->OnSetAbsRect(*this, absRect);
			}

			int dx = 0;
			int dy = 0;

			switch (layoutDirection)
			{
			case ELayoutDirection::LeftToRight:
				for (auto* child : children)
				{
					if (child->isCollapsed)
					{
						continue;
					}

					child->parentOffset.x = dx;
					child->parentOffset.y = 0;
					child->SetAbsRectRecursive();
					dx += child->Span().x;
					dx += childPadding;
				}
				break;
			case ELayoutDirection::RightToLeft:
				dx = Width(absRect) - Padding().right;
				for (auto i = children.rbegin(); i != children.rend(); ++i)
				{
					auto* child = *i;

					if (child->isCollapsed)
					{
						continue;
					}

					dx -= child->Span().x;
					dx -= childPadding;
					child->parentOffset.x = dx;
					child->parentOffset.y = 0;
					child->SetAbsRectRecursive();
				}
				break;
			case ELayoutDirection::TopToBottom:
				for (auto* child : children)
				{
					if (child->isCollapsed)
					{
						continue;
					}

					child->parentOffset.x = 0;
					child->parentOffset.y = dy;
					child->SetAbsRectRecursive();
					dy += child->Span().y;
					dy += childPadding;
				}
				break;
			case ELayoutDirection::BottomToTop:
				
				break;
			default:
				for (auto* child : children)
				{
					child->SetAbsRectRecursive();
				}
			}
		}

		void ExpandHorizontalSpansForChildren()
		{
			switch (layoutDirection)
			{
			case ELayoutDirection::LeftToRight:
			case ELayoutDirection::RightToLeft:
			{
				int nExpandingChildren = 0;
				int totalXSpanOfFixedWidthChildren = 0;

				int totalChildPadding = -childPadding;

				for (auto* child : children)
				{
					if (child->isCollapsed)
					{
						continue;
					}

					totalChildPadding += childPadding;

					if (child->widthSizing == ESizingRule::ExpandToParent)
					{
						nExpandingChildren++;
					}
					else if (child->widthSizing == ESizingRule::ConstantPercentage)
					{
						totalXSpanOfFixedWidthChildren += ((child->span.x * Span().x) / 100);
					}
					else
					{
						totalXSpanOfFixedWidthChildren += child->span.x;
					}
				}

				int freeSpace = Span().x - totalXSpanOfFixedWidthChildren - Padding().left - Padding().right - totalChildPadding;
				if (freeSpace <= 0 || nExpandingChildren == 0)
				{
					for (auto* child : children)
					{
						if (child->isCollapsed)
						{
							continue;
						}

						if (child->widthSizing == ESizingRule::ExpandToParent)
						{
							child->span.x = 0;
						}
					}
				}
				else
				{
					int averageSpan = freeSpace / nExpandingChildren;

					for (auto* child : children)
					{
						if (child->isCollapsed)
						{
							continue;
						}

						if (child->widthSizing == ESizingRule::ExpandToParent)
						{
							child->span.x = averageSpan;
						}
					}
				}
			}
			break;
			default:
			{
				for (auto* child : children)
				{
					if (child->isCollapsed)
					{
						continue;
					}

					if (child->widthSizing == ESizingRule::ExpandToParent)
					{
						child->span.x = Span().x - Padding().left - Padding().right;
					}
				}
			}
			break;
			}
		}

		void ExpandVerticalSpansForChildren()
		{
			switch (layoutDirection)
			{
			case ELayoutDirection::BottomToTop:
			case ELayoutDirection::TopToBottom:
			{
				int nExpandingChildren = 0;
				int totalYSpanOfFixedWidthChildren = 0;

				int totalChildPadding = -childPadding;

				for (auto* child : children)
				{
					if (child->isCollapsed)
					{
						continue;
					}

					totalChildPadding += childPadding;

					if (child->heightSizing == ESizingRule::ExpandToParent)
					{
						nExpandingChildren++;
					}
					else
					{
						totalYSpanOfFixedWidthChildren += child->Span().y;
					}
				}

				int freeSpace = Span().y - totalYSpanOfFixedWidthChildren - Padding().top - Padding().bottom - totalChildPadding;
				if (freeSpace <= 0 || nExpandingChildren == 0)
				{
					for (auto* child : children)
					{
						if (child->isCollapsed)
						{
							continue;
						}

						if (child->heightSizing == ESizingRule::ExpandToParent)
						{
							child->span.y = 0;
						}
					}
				}
				else
				{
					int averageSpan = freeSpace / nExpandingChildren;

					for (auto* child : children)
					{
						if (child->isCollapsed)
						{
							continue;
						}

						if (child->heightSizing == ESizingRule::ExpandToParent)
						{
							child->span.y = averageSpan;
						}
					}
				}
			}
			break;
			default:
			{
				for (auto* child : children)
				{
					if (child->isCollapsed)
					{
						continue;
					}

					if (child->heightSizing == ESizingRule::ExpandToParent)
					{
						child->span.y = Span().y - Padding().top - Padding().bottom;
					}
				}
			}
			break;
			}
		}
		void ExpandToParentRecursive()
		{
			ExpandHorizontalSpansForChildren();
			ExpandVerticalSpansForChildren();

			for (auto* child : children)
			{
				if (child->isCollapsed)
				{
					continue;
				}

				child->ExpandToParentRecursive();
			}
		}

		void ShrinkToFitRecursive()
		{
			for (auto* child : children)
			{
				if (child->isCollapsed)
				{
					continue;
				}

				child->ShrinkToFitRecursive();
			}

			int width = 0;
			int height = 0;

			switch (layoutDirection)
			{
			case ELayoutDirection::LeftToRight:
			case ELayoutDirection::RightToLeft:
				width = SumChildWidth();
				height = MaxChildHeight();
				break;
			case ELayoutDirection::TopToBottom:
			case ELayoutDirection::BottomToTop:
				width = MaxChildWidth();
				height = SumChildHeight();
				break;
			}

			if (widthSizing == ESizingRule::FitChildren)
			{
				span.x = width + Padding().left + Padding().right;
			}

			if (heightSizing == ESizingRule::FitChildren)
			{
				span.y = height + Padding().top + Padding().bottom;
			}
		}

		IGRPanel& SetLayoutDirection(ELayoutDirection direction) override
		{
			this->layoutDirection = direction;
			return *this;
		}

		IGRPanel& SetFitChildrenHorizontally() override
		{
			widthSizing = ESizingRule::FitChildren;
			return *this;
		}

		IGRPanel& SetFitChildrenVertically() override
		{
			heightSizing = ESizingRule::FitChildren;
			return *this;
		}

		IGRPanel& SetExpandToParentHorizontally() override
		{
			widthSizing = ESizingRule::ExpandToParent;
			return *this;
		}

		IGRPanel& SetExpandToParentVertically() override
		{
			heightSizing = ESizingRule::ExpandToParent;
			return *this;
		}

		IGRPanel& SetConstantWidth(int width, bool isPercentage) override
		{
			if (watcher)
			{
				watcher->OnSetConstantWidth(*this, width);
			}

			widthSizing = isPercentage ? ESizingRule::ConstantPercentage : ESizingRule::Constant;
			span.x = width;
			return *this;
		}

		IGRPanel& SetConstantHeight(int height, bool isPercentage) override
		{
			if (watcher)
			{
				watcher->OnSetConstantHeight(*this, height);
			}

			heightSizing = isPercentage ? ESizingRule::ConstantPercentage : ESizingRule::Constant;
			span.y = height;
			return *this;
		}

		IGRPanel& SetConstantSpan(Vec2i ds) override
		{
			SetConstantWidth(ds.x, false);
			SetConstantHeight(ds.y, false);	
			return *this;
		}

		void GarbageCollectRecursive() override
		{
			bool removeMarkedChildren = false;

			if (isMarkedForDeletion)
			{
				for (auto* child : children)
				{
					child->ReleasePanel();
				}
				children.clear();
				return;
			}

			for (auto* child : children)
			{
				child->GarbageCollectRecursive();
				if (child->IsMarkedForDeletion())
				{
					removeMarkedChildren = true;
				}
			}

			if (removeMarkedChildren)
			{
				std::vector<GRPanel*> newChildren;
				for (auto* child : children)
				{
					if (child->IsMarkedForDeletion())
					{
						child->ReleasePanel();
					}
					else
					{
						newChildren.push_back(child);
					}
				}

				children.clear();
				children.swap(newChildren);
			}
		}

		IGRPanel& AddChild() override
		{
			auto* child = new GRPanel(root, this);
			children.push_back(child);
			return* child;
		}

		RGBAb GetColour(EGRSchemeColourSurface surface, GRWidgetRenderState rs, RGBAb defaultColour) const override
		{
			if (surface == EGRSchemeColourSurface::NONE)
			{
				return RGBAb(0, 0, 0, 0);
			}

			RGBAb result;
			if (!TryGetColour(surface, result, rs))
			{
				return defaultColour;
			}
			return result;
		}

		void SetCollapsed(bool isCollapsed) override
		{
			this->isCollapsed = isCollapsed;
		}

		void SetRenderLast(bool isRenderingLast) override
		{
			this->isRenderingLast = isRenderingLast;
		}

		bool TryGetColour(EGRSchemeColourSurface surface, RGBAb& colour, GRWidgetRenderState rs) const override
		{
			if (scheme && scheme->TryGetColour(surface, colour, rs))
			{
				return true;
			}

			if (parent)
			{
				return parent->TryGetColour(surface, colour, rs);
			}
			else
			{
				return Root().Scheme().TryGetColour(surface, colour, rs);
			}
		}

		IGRPanel& Set(EGRSchemeColourSurface surface, RGBAb colour, GRWidgetRenderState rs) override
		{
			if (!scheme)
			{
				scheme = CreateGRScheme();
			}

			scheme->SetColour(surface, colour, rs);
			return *this;
		}

		IGRPanel& Set(EGRSchemeColourSurface surface, RGBAb colour, EGRColourSpec spec) override
		{
			if (!scheme)
			{
				scheme = CreateGRScheme();
			}

			switch (spec)
			{
			case EGRColourSpec::None:
				break;
			case EGRColourSpec::ForAllRenderStates:
				SetUniformColourForAllRenderStates(*scheme, surface, colour);
				break;
			}

			return *this;
		}

		int32 ChildPadding() const override
		{
			return childPadding;
		}

		PaddingBools paddingsArePercentages{ 0,0,0,0 };

		IGRPanel& SetPaddingAsPercentage(bool left, bool right, bool top, bool bottom)
		{
			paddingsArePercentages = { left, right, top, bottom };
			return *this;
		}

		IGRPanel& SetChildPadding(int32 delta) override
		{
			childPadding = delta;
			return *this;
		}

		IGRPanel* Parent() override
		{
			return parent;
		}

		GuiRect AbsRect() const override
		{
			return absRect;
		}

		IGRPanel& CaptureCursor() override
		{
			root.CaptureCursor(*this);
			return *this;
		}

		void ReleasePanel() override
		{
			refCount--;
			if (refCount == 0)
			{
				delete this;
			}
		}

		IGRPanel& Resize(Vec2i span) override
		{
			if (this->span != span)
			{
				this->span = span;
			}
			return *this;
		}

		Vec2i ParentOffset() const override
		{
			return parentOffset;
		}

		void RenderRecursive(IGRRenderContext& g, const GuiRect& clipRect, bool isRenderingFirstLayer, int64 focusId) override
		{
			if (!widget || isCollapsed)
			{
				return;
			}

			if (isRenderingFirstLayer && isRenderingLast)
			{
				root.DeferRendering(*this);
				return;
			}

			if (Span().x > 0 && Span().y > 0)
			{
				g.EnableScissors(clipRect);

				if (extraRenderer)
				{
					extraRenderer->PreRender(*this, clipRect, g);
				}

				if (!extraRenderer || !extraRenderer->IsReplacementForWidgetRendering(*this)) widget->Render(g);

				if (extraRenderer)
				{
					extraRenderer->PostRender(*this, clipRect, g);
				}

				if (focusId == this->uniqueId)
				{
					root.GR().RenderFocus(*this, g, clipRect);
				}
			}

			for (auto* child : children)
			{
				GuiRect childClipRect = doesClipChildren ? IntersectNormalizedRects(clipRect, child->AbsRect()) : child->AbsRect();
				if (childClipRect.IsNormalized() || child->isRenderingLast)
				{
					child->RenderRecursive(g, childClipRect, isRenderingFirstLayer, focusId);
				}
			}
		}

		IGRPanelRoot& Root() const override
		{
			return root;
		}

		EGREventRouting RouteCursorClickEvent(GRCursorEvent& ce, bool filterChildrenByParentRect) override
		{
			if (isCollapsed)
			{
				return EGREventRouting::NextHandler;
			}

			if (filterChildrenByParentRect && !IsPointInRect(ce.position, absRect))
			{
				return EGREventRouting::NextHandler;
			}

			ce.history.RecordWidget(*widget);

			for (auto* child : children)
			{
				EGREventRouting routing = child->RouteCursorClickEvent(ce, filterChildrenByParentRect);
				if (routing == EGREventRouting::Terminate)
				{
					return EGREventRouting::Terminate;
				}
			}

			if (parent)
			{
				auto* parentClippingPanel = parent->clippingPanel;
				if (parentClippingPanel && parentClippingPanel->DoesClipChildren())
				{
					if (!IsPointInRect(ce.position, parentClippingPanel->AbsRect()))
					{
						return EGREventRouting::NextHandler;
					}
				}
			}

			if (!widget || !IsPointInRect(ce.position, absRect))
			{
				return EGREventRouting::NextHandler;
			}

			return widget->OnCursorClick(ce);
		}

		void BuildCursorMovementHistoryRecursive(GRCursorEvent& ce, IGRPanelEventBuilder& eb) override
		{
			if (!IsPointInRect(ce.position, absRect))
			{
				return;
			}

			eb += { uniqueId, this, absRect };

			for (auto* child : children)
			{
				child->BuildCursorMovementHistoryRecursive(ce, eb);
			}
		}

		void BuildWidgetCallstackRecursiveUnderPoint(Vec2i targetPoint, IGRPanelEventBuilder& wb) override
		{
			if (!IsPointInRect(targetPoint, absRect))
			{
				return;
			}

			wb += { uniqueId, this, absRect };

			for (auto* child : children)
			{
				child->BuildWidgetCallstackRecursiveUnderPoint(targetPoint, wb);
			}
		}

		IGRPanel& SetParentOffset(Vec2i offset) override
		{
			if (this->parentOffset != offset)
			{
				this->parentOffset = offset;
			}
			return *this;
		}

		Vec2i Span() const override
		{
			if (isCollapsed)
			{
				return { 0,0 };
			}

			int dx = span.x;
			int dy = span.y;

			if (widthSizing == ESizingRule::ConstantPercentage && parent)
			{
				dx = span.x * parent->Span().x / 100;
			}

			if (heightSizing == ESizingRule::ConstantPercentage && parent)
			{
				dy = span.y * parent->Span().y / 100;
			}

			return { dx, dy };
		}

		void SetWidget(IGRWidgetSupervisor& widget) override
		{
			this->widget = &widget;
			this->desc = widget.GetImplementationTypeName();
		}

		IGRWidget& Widget() override
		{
			return *widget;
		}

		bool doesClipChildren = true;

		void SetClipChildren(bool enabled) override
		{
			doesClipChildren = enabled;
		}

		bool DoesClipChildren() const override
		{
			return doesClipChildren;
		}

		// It is recommended to place the implementation in either the widget or an ancestor widget, that way the pointer is valid for the life of the panel
		IGRPanelRenderer* extraRenderer = nullptr;

		// Get extra rendering before and after widget rendering for the panel
		IGRPanelRenderer* GetPanelRenderer() override
		{
			return extraRenderer;
		}

		// Add extra rendering before and after widget rendering for the panel
		IGRPanel& SetPanelRenderer(IGRPanelRenderer* renderer) override
		{
			extraRenderer = renderer;
			return *this;
		}

		IGRPanelWatcher* watcher = nullptr;

		IGRPanelWatcher* SetPanelWatcher(IGRPanelWatcher* newWatcher) override
		{
			auto* old = watcher;
			watcher = newWatcher;
			return old;
		}

		EGREventRouting RouteToParentRecursive(GRWidgetEvent& ev, IGRWidget& sender)
		{
			if (parent)
			{
				auto followup = parent->widget->OnChildEvent(ev, sender);
				if (followup == EGREventRouting::NextHandler)
				{
					return parent->RouteToParentRecursive(ev, sender);
				}
				else
				{
					return EGREventRouting::Terminate;
				}
			}
			else
			{
				return EGREventRouting::NextHandler;
			}
		}

		EGREventRouting RouteToParent(GRWidgetEvent& ev) override
		{
			auto followup = RouteToParentRecursive(ev, *widget);
			if (followup == EGREventRouting::NextHandler)
			{
				return RouteEventToHandler(*this, ev);
			}

			return EGREventRouting::Terminate;
		}
	};
}

namespace Rococo::Gui
{
	IGRPanelSupervisor* CreatePanel(IGRPanelRootSupervisor& root, IGRPanelSupervisor* parent)
	{
		return new GRANON::GRPanel(root, parent);
	}

	ROCOCO_GUI_RETAINED_API void CopyColour(IGRPanel& src, IGRPanel& target, EGRSchemeColourSurface srcSurface, EGRSchemeColourSurface trgSurface, GRWidgetRenderState rs)
	{
		RGBAb c = src.GetColour(srcSurface, rs);
		target.Set(trgSurface, c, rs);
	}

	ROCOCO_GUI_RETAINED_API void CopyAllColours(IGRPanel& src, IGRPanel& target, EGRSchemeColourSurface srcSurface, EGRSchemeColourSurface trgSurface)
	{
		GRWidgetRenderState::ForEachPermutation(
			[&src, &target, srcSurface, trgSurface](GRWidgetRenderState rs)
			{
				CopyColour(src, target, srcSurface, trgSurface, rs);
			}
		);
	}

	void Throw(IGRPanel& panel, EGRErrorCode code, cstr function, cstr format, ...)
	{
		va_list args;
		va_start(args, format);

		char message[1024];
		Strings::SafeVFormat(message, sizeof(message), format, args);

		char completeMessage[1280];
		Strings::SafeFormat(completeMessage, "Panel(%s): %s", panel.Desc(), message);

		RaiseError(panel, code, function, completeMessage);
		va_end(args);
	}

	ROCOCO_GUI_RETAINED_API cstr IGRPanelWatcher::InterfaceId()
	{
		return "IGRPanelWatcher";
	}

	ROCOCO_GUI_RETAINED_API cstr IGRNavigator::InterfaceId()
	{
		return "IGRNavigator";
	}

	// Enumerates all children and their descendants, and returns the one with the given id. If it is not found the function returns nullptr
	ROCOCO_GUI_RETAINED_API bool IsCandidateDescendantOfParent(IGRPanel& parent, IGRPanel& candidate)
	{
		for (auto* ancestor = candidate.Parent(); ancestor != nullptr; ancestor = ancestor->Parent())
		{
			if (ancestor == &parent)
			{
				return true;
			}
		}

		return false;
	}

	ROCOCO_GUI_RETAINED_API IGRPanel* TrySetDeepFocus(IGRPanel& panel)
	{
		if (panel.IsCollapsed())
		{
			return nullptr;
		}

		if (panel.HasFlag(EGRPanelFlags::AcceptsFocus))
		{
			panel.FocusAndNotifyAncestors();
			return &panel;
		}

		DescAndIndex nextTarget = panel.GetNextNavigationTarget(nullptr);
		auto* targetPanel = panel.FindDescendantByDesc(nextTarget.desc);
		if (targetPanel != nullptr)
		{
			targetPanel->FocusAndNotifyAncestors();
			return targetPanel;
		}

		int32 index = 0;
		while (auto* child = panel.GetChild(index++))
		{
			IGRPanel* candidate = TrySetDeepFocus(*child);
			if (candidate)
			{
				return candidate;
			}
		}

		return nullptr;
	}

	ROCOCO_GUI_RETAINED_API cstr IGRFocusNotifier::InterfaceId()
	{
		return "IGRFocusNotifier";
	}

	ROCOCO_GUI_RETAINED_API cstr IGRWidgetLayout::InterfaceId()
	{
		return "IGRWidgetLayout";
	}

	ROCOCO_GUI_RETAINED_API IGRCustodian& GetCustodian(IGRPanel& panel)
	{
		return panel.Root().Custodian();
	}

	ROCOCO_GUI_RETAINED_API IGRCustodian& GetCustodian(IGRWidget& widget)
	{
		return GetCustodian(widget.Panel());
	}

	ROCOCO_GUI_RETAINED_API void RaiseError(IGRPanel& panel, EGRErrorCode errCode, cstr function, const char* format, ...)
	{
		char buf[1024];
		va_list args;
		va_start(args, format);
		SafeVFormat(buf, sizeof(buf),format, args);
		va_end(args);
		panel.Root().Custodian().RaiseError(panel.GetAssociatedSExpression(), errCode, function, "%s", buf);
	}

	ROCOCO_GUI_RETAINED_API void DrawEdge(EGRSchemeColourSurface topLeft, EGRSchemeColourSurface bottomRight, IGRPanel& panel, IGRRenderContext& rc)
	{
		GRWidgetRenderState edgeState(false, rc.IsHovered(panel), false);
		RGBAb topLeftColour = panel.GetColour(topLeft, edgeState);
		RGBAb bottomRightColour = panel.GetColour(bottomRight, edgeState);
		rc.DrawRectEdge(panel.AbsRect(), topLeftColour, bottomRightColour);
	}

	ROCOCO_GUI_RETAINED_API cstr IGRWidget::InterfaceId()
	{
		return "IGRWidget";
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.portrait.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <rococo.strings.h>

using namespace Rococo;
using namespace Rococo::Gui;
using namespace Rococo::Strings;

namespace GRANON
{
	struct GRPortrait : IGRWidgetPortrait, IGRWidgetLayout, IGRWidgetSupervisor
	{
		IGRPanel& panel;

		IGRImage* image = nullptr;
		HString imagePath;

		IGRWidgetDivision* clientArea;

		GRPortrait(IGRPanel& owningPanel) : panel(owningPanel)
		{
		}

		virtual ~GRPortrait()
		{

		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		void Free() override
		{
			delete this;
		}

		void PostConstruct()
		{
			clientArea = &CreateDivision(*this);
			panel.SetExpandToParentHorizontally();
			panel.SetExpandToParentVertically();
		}

		void LayoutBeforeFit() override
		{

		}

		GuiRect imageRect{ 0, 0, 0, 0 };
		GuiRect band1Rect{ 0, 0, 0, 0 };
		GuiRect band2Rect{ 0, 0, 0, 0 };

		void ComputeRects()
		{
			GRAlignmentFlags alignment;

			imageRect = GuiRect{ 0, 0, 0, 0 };
			band1Rect = GuiRect{ 0, 0, 0, 0 };
			band2Rect = GuiRect{ 0, 0, 0, 0 };

			if (!image)
			{
				imageRect = panel.Parent()->AbsRect();
				return;
			}

			Vec2i span = image->Span();
			if (span.x == 0 || span.y == 0)
			{
				imageRect = panel.Parent()->AbsRect();
				return;
			}

			double aspectRatio = span.x / (double)span.y;

			GuiRect targetRect = panel.AbsRect();
			Vec2i targetSpan = Span(targetRect);

			if (targetSpan.x == 0 || targetSpan.y == 0)
			{
				return;
			}

			double targetAspectRatio = targetSpan.x / (double)targetSpan.y;

			if (aspectRatio == targetAspectRatio)
			{
				imageRect = targetRect;
				return;
			}

			Vec2i centre = Centre(targetRect);

			if (aspectRatio > targetAspectRatio)
			{
				int32 correctedHeight = (int)(targetSpan.x / aspectRatio);
				targetRect.top = centre.y - correctedHeight / 2;
				targetRect.bottom = centre.y + correctedHeight / 2;
				imageRect = targetRect;
				band1Rect = GuiRect{ targetRect.left, panel.AbsRect().top, targetRect.right, targetRect.top };
				band2Rect = GuiRect{ targetRect.left, targetRect.bottom, targetRect.right, panel.AbsRect().bottom };
			}
			else
			{
				int32 correctedWidth = (int)(aspectRatio * targetSpan.y);
				targetRect.left = centre.x - correctedWidth / 2;
				targetRect.right = centre.x + correctedWidth / 2;
				imageRect = targetRect;
				band1Rect = GuiRect{ panel.AbsRect().left, targetRect.top, targetRect.left, targetRect.bottom };
				band2Rect = GuiRect{ targetRect.right, targetRect.top, panel.AbsRect().right, targetRect.bottom };
			}
		}

		void LayoutBeforeExpand() override
		{
			ComputeRects();
			clientArea->Panel().SetConstantSpan(Span(imageRect));

			GRAnchorPadding padding;
			padding.left = imageRect.left - panel.AbsRect().left;
			padding.top = imageRect.top - panel.AbsRect().top;
			padding.right = 0;
			padding.bottom = 0;
			panel.Set(padding);
		}

		void LayoutAfterExpand() override
		{
		}

		EGREventRouting OnCursorClick(GRCursorEvent&) override
		{
			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{
		}

		EGREventRouting OnCursorMove(GRCursorEvent&) override
		{
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnKeyEvent(GRKeyEvent&) override
		{
			return EGREventRouting::NextHandler;
		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		IGRWidgetDivision& ClientArea() override
		{
			return *clientArea;
		}

		void Render(IGRRenderContext& g) override
		{
			if (image)
			{
				g.DrawImageStretched(*image, imageRect);
			}

			RGBAb bandColour = clientArea->Panel().GetColour(EGRSchemeColourSurface::PORTRAIT_BAND_COLOUR, GRWRS());
			g.DrawRect(band1Rect, bandColour);
			g.DrawRect(band2Rect, bandColour);
		}

		IGRWidgetPortrait& SetImagePath(cstr imagePath) override
		{
			this->imagePath = imagePath ? imagePath : "";
			image = this->imagePath.length() == 0 ? nullptr : panel.Root().Custodian().CreateImageFromPath("portrait", imagePath);
			return *this;
		}

		Vec2i ImageSpan() const override
		{
			return image ? image->Span() : Vec2i{ 0,0 };
		}

		EGREventRouting OnChildEvent(GRWidgetEvent&, IGRWidget&) override
		{
			return EGREventRouting::NextHandler;
		}

		Vec2i EvaluateMinimalSpan() const
		{
			Vec2i extraSpan;
			extraSpan.x = panel.Padding().left + panel.Padding().right;
			extraSpan.y = panel.Padding().top + panel.Padding().bottom;
			return image ? image->Span() + extraSpan : extraSpan;
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			auto result = QueryForParticularInterface<IGRWidgetLayout, GRPortrait>(this, ppOutputArg, interfaceId);
			if (result == EGRQueryInterfaceResult::SUCCESS)
			{
				return result;
			}
			return QueryForParticularInterface<IGRWidgetPortrait, GRPortrait>(this, ppOutputArg, interfaceId);
		}

		IGRWidget& Widget()
		{
			return *this;
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRPortrait";
		}
	};

	struct GRPortraitFactory : IGRWidgetFactory
	{
		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			auto* portrait = new GRPortrait(panel);
			portrait->PostConstruct();
			return *portrait;
		}
	};
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetPortrait::InterfaceId()
	{
		return "IGRWidgetPortrait";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetPortrait& CreatePortrait(IGRWidget& parent)
	{
		GRANON::GRPortraitFactory factory;
		auto& gr = parent.Panel().Root().GR();
		auto& widget = gr.AddWidget(parent.Panel(), factory);
		IGRWidgetPortrait* portrait = Cast<IGRWidgetPortrait>(widget);
		return *portrait;
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.property-editor-tree.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <string>
#include <rococo.reflector.h>
#include <rococo.strings.h>
#include <rococo.formatting.h>
#include <vector>
#include <unordered_map>
#include <rococo.ui.h>
#include <rococo.vkeys.h>

using namespace Rococo;
using namespace Rococo::Gui;
using namespace Rococo::Reflection;
using namespace Rococo::Strings;

namespace GRANON
{
	struct PreviewData;

	enum class PrimitiveType
	{
		I32, I64, U64, F32, F64, BOOL, CSTR, HSTR, SUB_OBJECT
	};

	union PreviewPrimitive
	{
		int32 int32Value;
		int64 int64Value;
		uint64 uint64Value;
		float float32Value;
		double float64Value;
		bool boolValue;
		PreviewData* pSubObject;

		PreviewPrimitive(): uint64Value(0)
		{

		}
	};

	struct EditableString
	{
		HString text;
		size_t capacity = 0;
	};

	struct PrimitiveVariant
	{
		EditableString stringValue;
		PreviewPrimitive primitive;
		PrimitiveType type = PrimitiveType::BOOL;

		// Pointer to the primitive from which this was copied. If the pointer is volatile or temporary, then the orgin will remain null
		void* primitiveOrigin = nullptr;
	};

	void Assign(PrimitiveVariant& v, int32& value, bool retainOrigin)
	{
		v.primitive.int32Value = value;
		v.type = PrimitiveType::I32;
		if (retainOrigin)
		{
			v.primitiveOrigin = &value;
		}
	}

	void Assign(PrimitiveVariant& v, int64& value, bool retainOrigin)
	{
		v.primitive.int64Value = value;
		v.type = PrimitiveType::I64;
		if (retainOrigin)
		{
			v.primitiveOrigin = &value;
		}
	}

	void Assign(PrimitiveVariant& v, uint64& value, bool retainOrigin)
	{
		v.primitive.uint64Value = value;
		v.type = PrimitiveType::U64;
		if (retainOrigin)
		{
			v.primitiveOrigin = &value;
		}
	}

	void Assign(PrimitiveVariant& v, float& value, bool retainOrigin)
	{
		v.primitive.float32Value = value;
		v.type = PrimitiveType::F32;
		if (retainOrigin)
		{
			v.primitiveOrigin = &value;
		}
	}

	void Assign(PrimitiveVariant& v, double& value, bool retainOrigin)
	{
		v.primitive.float64Value = value;
		v.type = PrimitiveType::F64;
		if (retainOrigin)
		{
			v.primitiveOrigin = &value;
		}
	}

	void Assign(PrimitiveVariant& v, bool& value, bool retainOrigin)
	{
		v.primitive.boolValue = value;
		v.type = PrimitiveType::BOOL;
		if (retainOrigin)
		{
			v.primitiveOrigin = &value;
		}
	}

	void Assign(PrimitiveVariant& v, char* value, size_t capacity, bool retainOrigin)
	{
		v.primitive.float64Value = 0;
		v.stringValue.text = value;
		v.stringValue.capacity = capacity;
		v.type = PrimitiveType::CSTR;
		if (retainOrigin)
		{
			v.primitiveOrigin = value;
		}
	}

	void Assign(PrimitiveVariant& v, HString& stringRef, bool retainOrigin)
	{
		v.primitive.float64Value = 0;
		v.stringValue.text = stringRef.c_str();
		v.stringValue.capacity = Rococo::max(4096ULL, stringRef.length() + 1ULL);
		v.type = PrimitiveType::HSTR;
		if (retainOrigin)
		{
			v.primitiveOrigin = &stringRef;
		}
	}

	void Assign(PrimitiveVariant& v, PreviewData* subObject, bool retainOrigin)
	{
		v.primitive.pSubObject = subObject;
		v.type = PrimitiveType::SUB_OBJECT;
		if (retainOrigin)
		{
			v.primitiveOrigin = subObject;
		}		
	}

	enum EParseAndWriteBackResult
	{
		Success,
		NoOrigin,
		UnknownPrimitiveType
	};

	void RemoveRedundantZeros(char* buffer)
	{
		size_t len = strlen(buffer);

		char* end = buffer + len - 1;

		const char* decimalPos = FindChar(buffer, '.');
		if (decimalPos)
		{
			for (char* zeros = end; zeros > decimalPos + 1; zeros--)
			{
				if (*zeros == '0')
				{
					*zeros = 0;
				}
				else
				{
					break;
				}
			}
		}
	}

	struct PreviewField
	{
		HString fieldName;
		PrimitiveVariant value;
		ReflectionMetaData meta;

		[[nodiscard]] EParseAndWriteBackResult TryParseAndWriteBackToOrigin(cstr text, IGRWidgetEditBox& sender)
		{
			if (!value.primitiveOrigin)
			{
				return EParseAndWriteBackResult::NoOrigin;
			}

			switch (value.type)
			{
				case PrimitiveType::I32:
				{
					Formatting::TryParseResult<int32> result = Formatting::TryParseInt32FromDecimalStringSkippingCetera(text);
					auto* origin = reinterpret_cast<int*>(value.primitiveOrigin);
					*origin = meta.hasMinmax ? clamp(result.Value, meta.min.i32Value, meta.max.i32Value) : result.Value;

					char buffer[16];
					Formatting::ToAscii(*origin, 10, meta.addThousandMarks, ',', buffer, sizeof(buffer));
					sender.SetText(buffer);
					return EParseAndWriteBackResult::Success;
				}
				case PrimitiveType::I64:
				{
					Formatting::TryParseResult<int64> result = Formatting::TryParseInt64FromDecimalStringSkippingCetera(text);
					auto* origin = reinterpret_cast<int64*>(value.primitiveOrigin);
					*origin = meta.hasMinmax ? clamp(result.Value, meta.min.i64Value, meta.max.i64Value) : result.Value;

					char buffer[32];
					Formatting::ToAscii(*origin, 10, meta.addThousandMarks, ',', buffer, sizeof(buffer));
					sender.SetText(buffer);
					return EParseAndWriteBackResult::Success;
				}
				case PrimitiveType::F32:
				{
					float f = (float) atof(text);
					auto* origin = reinterpret_cast<float*>(value.primitiveOrigin);

					float f1;

					if (isnan(f))
					{
						f1 = meta.min.f32Value;
					}
					else if (isinf(f))
					{
						f1 = meta.max.f32Value;
					}
					else
					{
						f1 = meta.hasMinmax ? clamp(f, meta.min.f32Value, meta.max.f32Value) : f;
					}

					*origin = f1;
					char buffer[32];
					SafeFormat(buffer, "%f", *origin);
					RemoveRedundantZeros(buffer);
					sender.SetText(buffer);
					return EParseAndWriteBackResult::Success;
				}
				case PrimitiveType::F64:
				{
					double d = atof(text);
					auto* origin = reinterpret_cast<double*>(value.primitiveOrigin);
		
					double d1;
					if (isnan(d))
					{
						d1 = meta.min.f32Value;
					}
					else if (isinf(d))
					{
						d1 = meta.max.f32Value;
					}
					else
					{
						d1 = meta.hasMinmax ? clamp(d, meta.min.f64Value, meta.max.f64Value): d;
					}

					*origin = d1;
					char buffer[32];
					SafeFormat(buffer, "%f", *origin);
					RemoveRedundantZeros(buffer);
					sender.SetText(buffer);
					return EParseAndWriteBackResult::Success;
				}
				case PrimitiveType::HSTR:
				{
					auto* origin = reinterpret_cast<HString*>(value.primitiveOrigin);
					*origin = text;
					return EParseAndWriteBackResult::Success;
				}
				case PrimitiveType::CSTR:
				{
					auto* origin = reinterpret_cast<char*>(value.primitiveOrigin);
					CopyString(origin, value.stringValue.capacity, text);
					return EParseAndWriteBackResult::Success;
				}
			default:
				return EParseAndWriteBackResult::UnknownPrimitiveType;
			}
		}
	};

	bool ToAscii(const PrimitiveVariant& variant, char* buffer, size_t capacity, const ReflectionMetaData& meta, int32 radix = 10)
	{
		char format[8] = "%.nAB";

		char precision = (char) clamp(meta.precision, 0, 9);
		format[2] = precision + '0';

		switch (variant.type)
		{
		case PrimitiveType::F32:
			format[3] = 'f';
			format[4] = 0;
			break;
		case PrimitiveType::F64:
			format[3] = 'l';
			format[4] = 'f';
			format[5] = 0;
			break;
		}

		switch (variant.type)
		{
		case PrimitiveType::I32:
			return Formatting::ToAscii(variant.primitive.int32Value, radix, meta.addThousandMarks, ',', buffer, capacity);
		case PrimitiveType::I64:
			return _i64toa_s(variant.primitive.int64Value, buffer, capacity, radix) != 0;
		case PrimitiveType::U64:
			return _ui64toa_s(variant.primitive.int64Value, buffer, capacity, radix) != 0;
		case PrimitiveType::F32:
			return snprintf(buffer, capacity, format, variant.primitive.float32Value) > 0;
		case PrimitiveType::F64:
			return snprintf(buffer, capacity, format, variant.primitive.float64Value) > 0;
		case PrimitiveType::BOOL:
			return snprintf(buffer, capacity, "%s", variant.primitive.boolValue ? "true" : "false") > 0;
		case PrimitiveType::CSTR:
			return snprintf(buffer, capacity, "%s", variant.stringValue.text.c_str()) > 0;
		case PrimitiveType::HSTR:
			return snprintf(buffer, capacity, "%s", variant.stringValue.text.c_str()) > 0;
		case PrimitiveType::SUB_OBJECT:
			return snprintf(buffer, capacity, "SUB_OBJECT") > 0;
		default:
			return snprintf(buffer, capacity, "UNKNOWN-TYPE") > 0;			
		}
	}

	struct PreviewData
	{
		PreviewData(PreviewData* _parent, const char* _instanceName = nullptr) : parent(_parent)
		{
			if (_instanceName != nullptr)
			{
				this->instanceName = _instanceName;
			}
		}

		~PreviewData()
		{
			for (auto& i : fields)
			{
				if (i->value.type == PrimitiveType::SUB_OBJECT)
				{
					auto* subObject = i->value.primitive.pSubObject;
					delete subObject;
				}

				delete i;
			}
		}

		PreviewData* parent;
		HString instanceName;
		HString containerKey;
		std::vector<PreviewField*> fields;

		template<class T>
		PreviewField& AddField(cstr name, T& value, const Reflection::ReflectionMetaData& meta)
		{
			fields.push_back(new PreviewField());
			auto& back = *fields.back();
			back.fieldName = name;
			back.meta = meta;
			Assign(back.value, value, true);
			return back;
		}

		PreviewField& AddField(cstr name, char* value, size_t capacity, const Reflection::ReflectionMetaData& meta)
		{
			fields.push_back(new PreviewField());
			auto& back = *fields.back();
			back.fieldName = name;
			back.meta = meta;
			Assign(back.value, value, capacity, true);
			return back;
		}

		void CancelVisitRecursive()
		{
			for (auto* f : fields)
			{
				f->value.primitiveOrigin = nullptr;

				if (f->value.type == PrimitiveType::SUB_OBJECT)
				{
					f->value.primitive.pSubObject->CancelVisitRecursive();
				}
			}
		}
	};

	struct ReflectionEnumerator : IReflectionVisitor
	{
		int fieldCount = 0;
		int subTargetCount = 0;
		int sectionCount = 0;

		void Reflect(cstr name, int32& value, ReflectionMetaData& ) override
		{
			UNUSED(name);
			UNUSED(value);
			fieldCount++;
		}

		void Reflect(cstr name, int64& value, ReflectionMetaData&) override
		{
			UNUSED(name);
			UNUSED(value);
			fieldCount++;
		}

		void Reflect(cstr name, uint64& value, ReflectionMetaData&) override
		{
			UNUSED(name);
			UNUSED(value);
			fieldCount++;
		}

		void Reflect(cstr name, float& value, ReflectionMetaData&) override
		{
			UNUSED(name);
			UNUSED(value);
			fieldCount++;
		}

		void Reflect(cstr name, double& value, ReflectionMetaData&) override
		{
			UNUSED(name);
			UNUSED(value);
			fieldCount++;
		}

		void Reflect(cstr name, bool& value, ReflectionMetaData&) override
		{
			UNUSED(name);
			UNUSED(value);
			fieldCount++;
		}

		void Reflect(cstr name, char* buffer, size_t capacity, ReflectionMetaData&) override
		{
			UNUSED(name);
			UNUSED(buffer);
			UNUSED(capacity);
			fieldCount++;
		}

		void Reflect(cstr name, IReflectionTarget& subTarget, ReflectionMetaData&) override
		{
			UNUSED(name);
			UNUSED(subTarget);
			subTargetCount++;
		}

		void EnterSection(cstr sectionName)
		{
			UNUSED(sectionName);
			sectionCount++;
		}

		void LeaveSection()
		{

		}
	};

	struct GRPropertyEditorTree;

	struct Previewer : IReflectionVisitor
	{
		GRPropertyEditorTree& owner;
		PreviewData* root = nullptr;
		PreviewData* target = nullptr;

		Previewer(GRPropertyEditorTree& _owner): owner(_owner)
		{
			root = new PreviewData(nullptr);
			target = root;
		}

		~Previewer()
		{
			delete root;
		}

		EReflectionDirection Direction() const override
		{
			return EReflectionDirection::READ_ONLY;
		}

		void Reflect(cstr name, int32& value, ReflectionMetaData& meta) override
		{
			target->AddField(name, value, meta);
		}

		void Reflect(cstr name, int64& value, ReflectionMetaData& meta) override
		{
			target->AddField(name, value, meta);
		}

		void Reflect(cstr name, uint64& value, ReflectionMetaData& meta) override
		{
			target->AddField(name, value, meta);
		}

		void Reflect(cstr name, float& value, ReflectionMetaData& meta) override
		{
			target->AddField(name, value, meta);
		}

		void Reflect(cstr name, double& value, ReflectionMetaData& meta) override
		{
			target->AddField(name, value, meta);
		}

		void Reflect(cstr name, bool& value, ReflectionMetaData& meta) override
		{
			target->AddField(name, value, meta);
		}

		void Reflect(cstr name, char* stringBuffer, size_t capacity, ReflectionMetaData& meta) override
		{
			target->AddField(name, stringBuffer, capacity, meta);
		}

		void Reflect(cstr name, Strings::HString& stringRef, ReflectionMetaData& metaData) override
		{
			target->AddField(name, stringRef, metaData);
		}

		void Reflect(cstr name, IReflectionTarget& subTarget, ReflectionMetaData& meta) override
		{
			auto* subSection = new PreviewData(target);
			target->AddField(name, subSection, meta);
			target = subSection;
			subTarget.Visit(*this);
			target = subSection->parent;
		}

		void EnterSection(cstr sectionName)
		{
			auto* child = new PreviewData(target, sectionName);
			target->AddField(sectionName, child, ReflectionMetaData::Default());
			target = child;
		}

		void LeaveSection()
		{
			target = target->parent;
		}

		void EnterContainer(cstr name) override
		{
			auto* subSection = new PreviewData(target);
			target->AddField(name, subSection, ReflectionMetaData::Default());
			subSection->parent = target;
			target = subSection;
			target->instanceName = name;
		}

		void LeaveContainer() override
		{
			target = target->parent;
		}

		void EnterElement(cstr keyName) override
		{
			auto* subSection = new PreviewData(target);
			target->AddField(keyName, subSection, ReflectionMetaData::Default());
			subSection->parent = target;
			target = subSection;
			target->containerKey = keyName;
		}

		void LeaveElement() override
		{
			target = target->parent;
		}

		void CancelVisit(IReflectionVisitation& visitation) override;
	};

	void SetEditorsToReadOnlyRecursive(IGRPanel& panel)
	{
		auto* editor = Cast<IGRWidgetEditBox>(panel.Widget());
		if (editor)
		{
			editor->SetReadOnly(true);
		}

		int nChildren = panel.EnumerateChildren(nullptr);
		for (int i = 0; i < nChildren; i++)
		{
			auto* child = panel.GetChild(i);
			SetEditorsToReadOnlyRecursive(*child);
		}
	}

	struct GRPropertyEditorTree: IGRWidgetPropertyEditorTree, IGRWidgetSupervisor, IGRWidgetCollapserEvents
	{
		IGRPanel& panel;
		Previewer previewer;
		IGRPropertyEditorPopulationEvents& populationEventHandler;
		PropertyEditorSpec spec;

		std::unordered_map<size_t, PreviewField*> editorToPreviewField;

		GRPropertyEditorTree(IGRPanel& panel, IGRPropertyEditorPopulationEvents& _populationEventHandler, const PropertyEditorSpec& _spec) :
			panel(panel), previewer(*this), populationEventHandler(_populationEventHandler), spec(_spec)
		{
			panel.SetClipChildren(true);
			panel.SetExpandToParentHorizontally();
			panel.SetExpandToParentVertically();

			if (spec.NameplateFontId == GRFontId::NONE)
			{
				FontSpec boldFont;
				boldFont.Bold = true;
				boldFont.CharHeight = 14;
				boldFont.CharSet = ECharSet::ANSI;
				boldFont.FontName = "Consolas";
				spec.NameplateFontId = GetCustodian(panel).Fonts().BindFontId(boldFont);
			}

			if (spec.HeadingFontId == GRFontId::NONE)
			{
				FontSpec headingFontSpec;
				headingFontSpec.Bold = true;
				headingFontSpec.CharHeight = 16;
				headingFontSpec.CharSet = ECharSet::ANSI;
				headingFontSpec.FontName = "Consolas";
				spec.HeadingFontId = GetCustodian(panel).Fonts().BindFontId(headingFontSpec);
			}

			if (spec.ValueFontId == GRFontId::NONE)
			{
				FontSpec valueFontSpec;
				valueFontSpec.Bold = false;
				valueFontSpec.CharHeight = 14;
				valueFontSpec.CharSet = ECharSet::ANSI;
				valueFontSpec.FontName = "Consolas";
				spec.ValueFontId = GetCustodian(panel).Fonts().BindFontId(valueFontSpec);
			}
		}

		virtual ~GRPropertyEditorTree()
		{
			if (currentVisitation)
			{
				currentVisitation->OnVisitorGone(previewer);
			}
		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		void Free() override
		{
			delete this;
		}

		bool CancelVisit(IReflectionVisitation& visitation)
		{
			if (currentVisitation == &visitation)
			{
				currentVisitation = nullptr;
				SetEditorsToReadOnlyRecursive(panel);
				return true;
			}

			return false;
		}

		void OnCollapserExpanded(IGRWidgetCollapser&) override
		{
			SetCollapserSizes();
		}

		void OnCollapserInlined(IGRWidgetCollapser&) override
		{
			SetCollapserSizes();
		}

		EGREventRouting OnCursorClick(GRCursorEvent& ce) override
		{
			return viewport->VScroller().Scroller().Widget().Manager().OnCursorClick(ce);
		}

		EGREventRouting OnCursorMove(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{

		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		void HilightFocusedCollapserRecursive(IGRPanel& p)
		{
			auto* collapser = Cast<IGRWidgetCollapser>(p.Widget());
			if (collapser)
			{
				auto* textPanel = collapser->TitleBar().Panel().GetChild(2);
				if (textPanel)
				{
					auto* text = Cast<IGRWidgetText>(textPanel->Widget());
					if (p.HasFocus())
					{
						text->SetBackColourSurface(EGRSchemeColourSurface::FOCUS_RECTANGLE);
					}
					else
					{
						text->SetBackColourSurface(EGRSchemeColourSurface::CONTAINER_BACKGROUND);
					}
				}
			}

			int nChildren = p.EnumerateChildren(nullptr);
			for (int i = 0; i < nChildren; i++)
			{
				auto* child = p.GetChild(i);
				HilightFocusedCollapserRecursive(*child);
			}
		}

		void Render(IGRRenderContext& g) override
		{
			auto rect = panel.AbsRect();
			bool isHovered = g.IsHovered(panel);
			RGBAb colour = panel.GetColour(Gui::EGRSchemeColourSurface::CONTAINER_BACKGROUND, GRWidgetRenderState(false, isHovered, false));
			g.DrawRect(rect, colour);

			HilightFocusedCollapserRecursive(panel);
		}

		void UpdateValueFrom(IGRWidgetEditBox& editor)
		{
			size_t key = reinterpret_cast<size_t>(&editor);
			auto i = editorToPreviewField.find(key);
			if (i == editorToPreviewField.end())
			{
				return;
			}

			char text[256];
			editor.GetTextAndLength(text, sizeof(text));

			auto result = i->second->TryParseAndWriteBackToOrigin(text, editor);
			if (result != EParseAndWriteBackResult::Success)
			{
				RaiseError(editor.Panel(), EGRErrorCode::Generic, __ROCOCO_FUNCTION__, "TryParseAndWriteBackToOrigin failed with code %d", result);
			}
		}

		EGREventRouting OnEditorUpdated(GRWidgetEvent_EditorUpdated& update, IGRWidget& sender)
		{
			UNUSED(sender);
			IGRWidgetEditBox& editor = *update.editor;
			if (update.editorEventType == EGREditorEventType::LostFocus)
			{
				UpdateValueFrom(editor);
			}
			return EGREventRouting::Terminate;
		}

		EGREventRouting OnChildEvent(GRWidgetEvent& ev, IGRWidget& sender)
		{
			if (ev.eventType == EGRWidgetEventType::EDITOR_UPDATED)
			{
				auto& editorEv = static_cast<GRWidgetEvent_EditorUpdated&>(ev);
				return OnEditorUpdated(editorEv, sender);
			}
			return EGREventRouting::NextHandler;
		}

		EGREventRouting MoveToSiblingCollapserIfFocused()
		{
			auto* focusWidget = panel.Root().GR().FindFocusWidget();
			if (!focusWidget)
			{
				return EGREventRouting::NextHandler;
			}

			auto* collapser = Cast<IGRWidgetCollapser>(*focusWidget);
			if (!collapser)
			{
				return EGREventRouting::NextHandler;
			}

			if (collapser->Panel().Parent()->EnumerateChildren(nullptr) == 1)
			{
				// Collapser has no siblings, so we prevent focus moving
				return EGREventRouting::Terminate;
			}

			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnKeyEvent(GRKeyEvent& ke) override
		{
			if (ke.osKeyEvent.IsUp())
			{
				switch (ke.osKeyEvent.VKey)
				{
				case IO::VirtualKeys::VKCode_ANTITAB:
				case IO::VirtualKeys::VKCode_UP:
				case IO::VirtualKeys::VKCode_DOWN:
				case IO::VirtualKeys::VKCode_TAB:
					return EGREventRouting::Terminate;
				}
				return EGREventRouting::NextHandler;
			}			

			// Key down or repeat
			switch (ke.osKeyEvent.VKey)
			{
			case IO::VirtualKeys::VKCode_TAB:
				return MoveToSiblingCollapserIfFocused();
			}

			return EGREventRouting::NextHandler;
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			return QueryForParticularInterface<IGRWidgetPropertyEditorTree>(this, ppOutputArg, interfaceId);
		}

		IGRWidget& Widget() override
		{
			return *this;
		}

		struct NameValueControls
		{
			IGRWidgetText& name;
			IGRWidgetEditBox& editor;
		};

		IGRWidgetEditBox* firstCreatedEditBox = nullptr;
		IGRWidgetEditBox* lastCreatedEditBox = nullptr;

		NameValueControls AddFieldToTable(IGRWidgetTable& table, PreviewField& field, int rowHeight, int depth)
		{
			UNUSED(depth);

			int newRowIndex = table.AddRow(GRRowSpec{ rowHeight });
			auto* nameCell = table.GetCell(0, newRowIndex);

			auto rowSurface = (newRowIndex % 2 == 0) ? EGRSchemeColourSurface::ROW_COLOUR_EVEN : EGRSchemeColourSurface::ROW_COLOUR_ODD;

			auto& rowPanel = *nameCell->Panel().Parent();
			CopyAllColours(rowPanel, rowPanel, rowSurface, EGRSchemeColourSurface::CONTAINER_BACKGROUND);
			CopyAllColours(rowPanel, rowPanel, rowSurface, EGRSchemeColourSurface::CONTAINER_TOP_LEFT);
			CopyAllColours(rowPanel, rowPanel, rowSurface, EGRSchemeColourSurface::CONTAINER_BOTTOM_RIGHT);

			GRAlignmentFlags nameAlignment;
			nameAlignment.Add(EGRAlignment::VCentre).Add(spec.LeftAlignNameplates ? EGRAlignment::Left : EGRAlignment::Right);
			auto& leftSpacer = CreateDivision(nameCell->Widget());
			leftSpacer.SetTransparency(0);
			leftSpacer.Panel().SetConstantWidth(spec.LeftHandMargin + spec.LeftHandShiftPerDepth * depth).SetDesc("NameCell-LeftSpacer");

			char label[256];
			Strings::SafeFormat(label, "%s:", field.fieldName.c_str());
			auto& nameText = CreateText(nameCell->Widget()).SetText(label).SetAlignment(nameAlignment, spec.NameTextSpacing);
			nameText.SetFont(spec.NameplateFontId);
			nameText.Panel().SetExpandToParentHorizontally();
			nameText.Panel().SetExpandToParentVertically();
			nameText.Panel().Set(spec.NameCellPadding);

			Strings::SafeFormat(label, "NameCell: %s", field.fieldName.c_str());

			nameCell->Panel().SetDesc(label);;

			auto& namePanel = nameText.Panel();
			CopyAllColours(namePanel, namePanel, EGRSchemeColourSurface::NAME_TEXT, EGRSchemeColourSurface::TEXT);

			IGREditFilter* filter = nullptr;

			int32 capacity;

			switch (field.value.type)
			{
			case PrimitiveType::I32:
				filter = &GetI32Filter();
				capacity = 12;
				break;
			case PrimitiveType::I64:
				filter = &GetI64Filter();
				capacity = 24;
				break;
			case PrimitiveType::F32:
				filter = &GetF32Filter();
				capacity = 12;
				break;
			case PrimitiveType::F64:
				filter = &GetF64Filter();
				capacity = 24;
				break;
			case PrimitiveType::CSTR:
				if (field.value.stringValue.capacity > 0x7FFF'FFFFUL)
				{
					RaiseError(table.Panel(), EGRErrorCode::InvalidArg, __ROCOCO_FUNCTION__, "[capacity] > max int32 value");
				}
				capacity = (int32)field.value.stringValue.capacity;
				break;
			case PrimitiveType::HSTR:
				capacity = (int32)field.value.stringValue.capacity;
				break;
			default:
				capacity = 1;
				RaiseError(panel, EGRErrorCode::InvalidArg, __ROCOCO_FUNCTION__, "Bad field value type: %d", field.value.type);
			}

			auto* valueCell = table.GetCell(1, newRowIndex);

			auto& valuePanel = valueCell->Panel();
			CopyAllColours(valuePanel, valuePanel, rowSurface, EGRSchemeColourSurface::CONTAINER_BACKGROUND);
			CopyAllColours(valuePanel, valuePanel, rowSurface, EGRSchemeColourSurface::CONTAINER_TOP_LEFT);
			CopyAllColours(valuePanel, valuePanel, rowSurface, EGRSchemeColourSurface::CONTAINER_BOTTOM_RIGHT);
			CopyAllColours(valuePanel, valuePanel, EGRSchemeColourSurface::VALUE_TEXT, EGRSchemeColourSurface::TEXT);

			char description[64];

			GRAlignmentFlags valueAlignment;
			valueAlignment.Add(EGRAlignment::VCentre).Add(EGRAlignment::Left);
			auto& valueText = CreateEditBox(valueCell->Widget(), filter, capacity, spec.ValueFontId).SetAlignment(valueAlignment, spec.EditorCellPadding);

			SafeFormat(description, "editor %llx", valueText.Panel().Id());
			valueText.Panel().SetDesc(description);

			if (lastCreatedEditBox)
			{
				lastCreatedEditBox->Panel().Set(EGRNavigationDirection::Down, description);
				valueText.Panel().Set(EGRNavigationDirection::Up, lastCreatedEditBox->Panel().Desc());
			}

			lastCreatedEditBox = &valueText;
			if (firstCreatedEditBox == nullptr)
			{
				firstCreatedEditBox = lastCreatedEditBox;
			}

			valueText.Panel().Set(spec.ValueCellPadding);
			valueText.Panel().SetExpandToParentHorizontally();
			valueText.Panel().SetExpandToParentVertically();

			if (field.meta.isReadOnly)
			{
				valueText.SetReadOnly(true);
			}

			if (field.value.type != PrimitiveType::CSTR && field.value.type != PrimitiveType::HSTR)
			{
				char buf[16];
				if (!ToAscii(field.value, buf, sizeof(buf), field.meta))
				{	
					RaiseError(panel, EGRErrorCode::InvalidArg, __ROCOCO_FUNCTION__, "Could not get an ascii representation of the field value");
				}
				valueText.SetText(buf);
			}
			else
			{
				valueText.SetText(field.value.stringValue.text.c_str());
			}

			NameValueControls controls{ nameText, valueText };

			size_t key = reinterpret_cast<size_t>(&valueText);
			editorToPreviewField[key] = &field;

			return controls;
		}

		std::vector<int> maxColumnWidthByDepth;

		struct TableList
		{
			std::vector<IGRWidgetTable*> tables;
		};

		std::vector<TableList> tableByDepth;

		// firstValidIndex and lastValidIndex are required to be valid. Iteration includes the final index
		void AddFieldTable(PreviewData& data, int32 firstValidIndex, int32 lastValidIndex, IGRWidget& parent, int depth)
		{
			auto& table = CreateTable(parent);
			table.Panel().SetExpandToParentHorizontally();
			table.Panel().SetExpandToParentVertically();
			table.Panel().SetLayoutDirection(ELayoutDirection::TopToBottom);

			GRColumnSpec nameSpec;
			nameSpec.name = "Name";
			nameSpec.maxWidth = 240;
			nameSpec.minWidth = 64;
			nameSpec.defaultWidth = spec.NameColumnDefaultWidth;
			table.AddColumn(nameSpec);

			GRColumnSpec valueSpec;
			valueSpec.name = "Value";
			valueSpec.maxWidth = 8192;
			valueSpec.minWidth = 64;
			valueSpec.defaultWidth = spec.ValueColumnDefaultWidth;
			table.AddColumn(valueSpec);

			SetUniformColourForAllRenderStates(table.Panel(), EGRSchemeColourSurface::CONTAINER_BACKGROUND, RGBAb(0, 0, 0, 0));

			int nameColumnWidth = nameSpec.defaultWidth;

			for (int32 j = firstValidIndex; j <= lastValidIndex; j++)
			{
				NameValueControls controls = AddFieldToTable(table, *data.fields[j], rowHeight, depth);

				int nameWidth = controls.name.TextWidth();
				auto* spacer = controls.name.Panel().Parent()->GetChild(0);
				const int padding = spacer->Span().x + spec.NamePlateSafeZone;
				nameColumnWidth = Rococo::max(nameWidth + padding, nameColumnWidth);

				populationEventHandler.OnAddNameValue(controls.name, controls.editor);
			}

			while (depth + 1 > (int)maxColumnWidthByDepth.size())
			{
				maxColumnWidthByDepth.push_back(0);
				tableByDepth.push_back(TableList());
			}

			int& maxColumnWidthForDepth = maxColumnWidthByDepth.back();
			maxColumnWidthForDepth = Rococo::max(nameColumnWidth, maxColumnWidthForDepth);
			table.SetColumnWidth(0, maxColumnWidthForDepth);

			auto& tableList = tableByDepth.back();
			tableList.tables.push_back(&table);
		}

		void AddSubObject(PreviewField& subObjectField, IGRWidget& parent, int depth)
		{
			SyncUIToPreviewerRecursive(*subObjectField.value.primitive.pSubObject, parent, depth);
		}

		void SyncUIToPreviewerRecursive(PreviewData& data, IGRWidget& parentContainer, int32 depth)
		{
			if (data.fields.empty())
			{
				char message[1024];
				Strings::StackStringBuilder sb(message, sizeof(message));
				sb.AppendFormat("[PreviewData& data] had no fields.\n");

				PreviewData* pData = &data;
				while(pData)
				{
					sb.AppendFormat(" under node %s\n", pData->instanceName.length() > 0 ? pData->instanceName.c_str() : "<anon>");
					pData = pData->parent;
				}

				RaiseError(parentContainer.Panel(), EGRErrorCode::BadSpanHeight, __ROCOCO_FUNCTION__, "%s", message);
				return;
			}

			auto& collapser = CreateCollapser(parentContainer, *this);
			collapser.Panel().Set(spec.CollapserPadding).Add(EGRPanelFlags::AcceptsFocus);
			collapser.Panel().SetExpandToParentHorizontally();
			collapser.Panel().SetExpandToParentVertically();
			collapser.LeftSpacer().Panel().SetConstantWidth(depth * 24);
			collapser.LeftSpacer().SetTransparency(0.0f);

			MakeTransparent(collapser.Panel(), EGRSchemeColourSurface::CONTAINER_BACKGROUND);
			MakeTransparent(collapser.Panel(), EGRSchemeColourSurface::BUTTON);
			MakeTransparent(collapser.Panel(), EGRSchemeColourSurface::BUTTON_EDGE_BOTTOM_RIGHT);
			MakeTransparent(collapser.Panel(), EGRSchemeColourSurface::BUTTON_EDGE_TOP_LEFT);

			MakeTransparent(collapser.TitleBar().Panel(), EGRSchemeColourSurface::CONTAINER_TOP_LEFT);
			MakeTransparent(collapser.TitleBar().Panel(), EGRSchemeColourSurface::CONTAINER_BOTTOM_RIGHT);
			MakeTransparent(collapser.TitleBar().Panel(), EGRSchemeColourSurface::CONTAINER_BACKGROUND);

			GRAlignmentFlags alignment;
			alignment.Add(EGRAlignment::HCentre).Add(EGRAlignment::VCentre);
			collapser.CollapseButton().SetAlignment(alignment, spec.CollapserButtonSpacing);

			auto& titleDiv = collapser.TitleBar();
			titleDiv.Panel().SetConstantHeight(rowHeight);

			//parentContainer.Panel().GetColour(EGRSchemeColourSurface::)

			auto collapserSurface = ((depth % 2) == 0) ? EGRSchemeColourSurface::COLLAPSER_TITLE_DEPTH_EVEN : EGRSchemeColourSurface::COLLAPSER_TITLE_DEPTH_ODD;
			CopyAllColours(titleDiv.Panel(), titleDiv.Panel(), collapserSurface, EGRSchemeColourSurface::CONTAINER_BACKGROUND);
			
			char title[128];
			if (data.containerKey.length() > 0)
			{
				// We must look to the parent, i.e the container, to get the container name
				cstr container = data.parent->instanceName;
				SafeFormat(title, "%s[%s]", container, data.containerKey.c_str());

				collapser.SetExpandClientAreaImagePath("$(COLLAPSER_ELEMENT_EXPAND)");
				collapser.SetCollapsedToInlineImagePath("$(COLLAPSER_ELEMENT_INLINE)");
			}
			else
			{
				SafeFormat(title, "%s", data.instanceName.c_str());
			}

			if (*title == 0)
			{
				SafeFormat(title, "root");
			}

			auto& titleDescription = Rococo::Gui::CreateText(titleDiv.Widget()).SetText(title);
			titleDescription.Panel().SetExpandToParentVertically();
			titleDescription.Panel().SetExpandToParentHorizontally();
			titleDescription.Panel().Set(spec.TitleDescPadding);
			titleDescription.SetFont(spec.HeadingFontId);

			GRAlignmentFlags rightCentered;
			rightCentered.Add(EGRAlignment::Left).Add(EGRAlignment::VCentre);

			titleDescription.SetAlignment(rightCentered, { 4,0 });

			MakeTransparent(titleDescription.Panel(), EGRSchemeColourSurface::LABEL_BACKGROUND);
			MakeTransparent(titleDescription.Panel(), EGRSchemeColourSurface::CONTAINER_BOTTOM_RIGHT);
			MakeTransparent(titleDescription.Panel(), EGRSchemeColourSurface::CONTAINER_TOP_LEFT);

			titleDescription.SetTextColourSurface(EGRSchemeColourSurface::COLLAPSER_TITLE_TEXT);
			titleDescription.SetTextColourShadowSurface(EGRSchemeColourSurface::COLLAPSER_TITLE_SHADOW);
			
			auto& list = CreateVerticalList(collapser.ClientArea().Widget());
			list.Panel().SetExpandToParentHorizontally();
			list.Panel().SetExpandToParentVertically();
			list.Panel().SetLayoutDirection(ELayoutDirection::TopToBottom);


			int32 firstSimpleFieldIndex = -1;
			int32 nextSimpleFieldIndex = -1;

			for (int32 i = 0; i < (int32)data.fields.size(); ++i)
			{
				auto& f = *data.fields[i];

				if (f.value.type != PrimitiveType::SUB_OBJECT)
				{
					if (firstSimpleFieldIndex == -1)
					{
						firstSimpleFieldIndex = i;
					}

					if (nextSimpleFieldIndex < i)
					{
						nextSimpleFieldIndex = i;
					}
				}
				else
				{
					if (firstSimpleFieldIndex >= 0)
					{
						AddFieldTable(data, firstSimpleFieldIndex, nextSimpleFieldIndex, list.Widget(), depth);
						firstSimpleFieldIndex = -1;
						nextSimpleFieldIndex = -1;
					}

					AddSubObject(*data.fields[i], list.Widget(), depth + 1);
				}
			}

			if (firstSimpleFieldIndex >= 0)
			{
				AddFieldTable(data, firstSimpleFieldIndex, (int32)data.fields.size() - 1, list.Widget(), depth);
			}
		}

		IGRWidgetViewport* viewport = nullptr;

		IGRWidgetViewport& Viewport() override
		{
			if (!viewport)
			{
				viewport = &CreateViewportWidget(*this);
				viewport->SetLineDeltaPixels(spec.LineDeltaPixels);

				auto& vp = viewport->Widget().Panel();
				vp.SetExpandToParentHorizontally();
				vp.SetExpandToParentVertically();
				vp.SetDesc("PropEditor-Viewport");
			}

			return *viewport;
		}

		int rowHeight = 30;

		void SetRowHeight(int height) override
		{
			rowHeight = clamp(height, 16, 300);
		}

		IReflectionVisitation* currentVisitation = nullptr;

		void View(IReflectionVisitation* visitation) override
		{
			if (!visitation || !visitation->AcceptVisitor(previewer))
			{
				return;
			}

			auto* nextTarget = &visitation->Target();
			if (currentVisitation && &currentVisitation->Target() != nextTarget)
			{
				visitation->OnVisitorGone(previewer);
			}

			currentVisitation = visitation;

			editorToPreviewField.clear();

			currentVisitation->Target().Visit(previewer);

			auto& viewport = Viewport();
			auto* node = previewer.root;

			if (node) SyncUIToPreviewerRecursive(*node, viewport.ClientArea().Widget(), 0);

			if (firstCreatedEditBox != lastCreatedEditBox)
			{
				firstCreatedEditBox->Panel().Set(EGRNavigationDirection::Up, lastCreatedEditBox->Panel().Desc());
				lastCreatedEditBox->Panel().Set(EGRNavigationDirection::Down, firstCreatedEditBox->Panel().Desc());
			}

			for (size_t depth = 0; depth < tableByDepth.size(); depth++)
			{
				auto& tablesAtDepth = tableByDepth[depth];
				int maxWidth = maxColumnWidthByDepth[depth];
				
				for (auto& t : tablesAtDepth.tables)
				{
					t->SetColumnWidth(0, maxWidth);
				}
			}

			SetCollapserSizes();
		}

		int ComputeAndAssignCollapserHeights(IGRWidgetCollapser& collapserParent)
		{
			int32 heightOfDescendants = collapserParent.TitleBar().Panel().Span().y;

			auto* collapserChild = collapserParent.ClientArea().Panel().GetChild(0);

			if (!collapserChild)
			{
				return 0;
			}

			IGRWidgetVerticalList* list = Cast<IGRWidgetVerticalList>(collapserChild->Widget());
			if (!list)
			{
				return 0;
			}
			
			if (!collapserParent.IsCollapsed())
			{
				for (int i = 0; auto * child = list->Widget().Panel().GetChild(i); i++)
				{
					IGRWidgetCollapser* collapser = Cast<IGRWidgetCollapser>(child->Widget());
					if (collapser)
					{
						heightOfDescendants += ComputeAndAssignCollapserHeights(*collapser);
					}
					else
					{
						IGRWidgetTable* table = Cast<IGRWidgetTable>(child->Widget());
						if (table)
						{
							heightOfDescendants += table->EstimateHeight();
						}
					}
				}
			}

			auto& cp = collapserParent.Panel();
			cp.SetConstantHeight(heightOfDescendants);
			return heightOfDescendants;
		}

		void SetCollapserSizes()
		{
			if (!viewport)
			{
				// Preview was not called, so nothing in the editor to see
				return;
			}
			auto& clientArea = viewport->ClientArea();

			auto* rootCollapserPanel = clientArea.Panel().GetChild(0);
			if (!rootCollapserPanel) return;

			IGRWidgetCollapser* collapser = Cast<IGRWidgetCollapser>(rootCollapserPanel->Widget());
			if (collapser)
			{
				int sumTotalHeight = ComputeAndAssignCollapserHeights(*collapser);
				viewport->SetDomainHeight(sumTotalHeight);
			}
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRPropertyEditorTree";
		}
	};

	void Previewer::CancelVisit(IReflectionVisitation& visitation)
	{
		if (owner.CancelVisit(visitation))
		{
			root->CancelVisitRecursive();
		}
	}
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetPropertyEditorTree::InterfaceId()
	{
		return "IGRWidgetPropertyEditorTree";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetPropertyEditorTree& CreatePropertyEditorTree(IGRWidget& parent, IGRPropertyEditorPopulationEvents& populationEventHandler, const PropertyEditorSpec& spec)
	{
		auto& gr = parent.Panel().Root().GR();

		struct GRPropertyEditorTreeFactory : IGRWidgetFactory
		{
			IGRPropertyEditorPopulationEvents& populationEventHandler;
			const PropertyEditorSpec& spec;

			GRPropertyEditorTreeFactory(IGRPropertyEditorPopulationEvents& _populationEventHandler, const PropertyEditorSpec& _spec):
				populationEventHandler(_populationEventHandler),
				spec(_spec)

			{

			}

			IGRWidget& CreateWidget(IGRPanel& panel)
			{
				return *new GRANON::GRPropertyEditorTree(panel, populationEventHandler, spec);
			}
		};

		GRPropertyEditorTreeFactory factory(populationEventHandler, spec);
		auto* tree = static_cast<GRANON::GRPropertyEditorTree*>(Cast<IGRWidgetPropertyEditorTree>(gr.AddWidget(parent.Panel(), factory)));
		return *tree;
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.radio-buttons.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <rococo.strings.h>
#include <rococo.hashtable.h>
#include <rococo.ui.h>
#include <rococo.vkeys.h>
#include <vector>

using namespace Rococo;
using namespace Rococo::Gui;
using namespace Rococo::Strings;

namespace GRANON
{
	struct GRRadioButtons : IGRWidgetRadioButtons, IGRWidgetSupervisor, IGRWidgetLayout, IGRWidgetInitializer
	{
		IGRPanel& panel;

		float transparency = 1.0f;

		HString defaultButtonString;
		std::vector<HString> group;
		stringmap<HString> mapMetaToToggler;

		GRRadioButtons(IGRPanel& owningPanel) : panel(owningPanel)
		{
			group.reserve(8);
		}

		virtual ~GRRadioButtons()
		{

		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		IGRWidget& Widget() override
		{
			return *this;
		}

		void Free() override
		{
			delete this;
		}

		void Prep() override
		{
			for (auto& i : mapMetaToToggler)
			{
				cstr meta = i.first;
				cstr toggler = i.second.c_str();

				IGRWidgetButton* button = FindButtonWithMeta(panel, meta);
				if (!button)
				{
					RaiseError(panel, EGRErrorCode::Generic, __ROCOCO_FUNCTION__, "Cannot find child with meta string: %s", meta);
					return;
				}

				auto* togglePanel = FindPanelWithDescription(toggler);
				if (!togglePanel)
				{
					RaiseError(panel, EGRErrorCode::Generic, __ROCOCO_FUNCTION__, "Cannot find Panel.Description '%s' for meta: '%s'", toggler, meta);
					return;
				}
			}
		}

		static IGRPanel* FindPanelWithDescription(IGRPanel& panel, cstr description)
		{
			if (Eq(panel.Desc(), description))
			{
				return &panel;
			}

			return panel.FindDescendantByDesc(description);
		}

		IGRPanel* FindPanelWithDescription(cstr description)
		{
			auto* owner = Gui::FindOwner(Widget());
			if (!owner)
			{
				return nullptr;
			}

			auto& framePanel = owner->Panel();
			return FindPanelWithDescription(framePanel, description);
		}

		static IGRWidgetButton* FindButtonWithMeta(IGRPanel& panel, cstr metaString)
		{
			auto* button = Cast<IGRWidgetButton>(panel.Widget());
			if (button)
			{
				if (Eq(button->MetaData().stringData, metaString))
				{
					return button;
				}
				else
				{
					return nullptr;
				}
			}

			int nChildren = panel.EnumerateChildren(nullptr);
			for (int i = 0; i < nChildren; i++)
			{
				auto* child = panel.GetChild(i);
				button = FindButtonWithMeta(*child, metaString);
				if (button)
				{
					return button;
				}
			}

			return nullptr;
		}

		void MakeGroupExclusive(cstr defaultButton)
		{
			defaultButtonString = defaultButton;

			for (auto& member : group)
			{
				cstr meta = member.c_str();

				IGRWidgetButton* button = FindButtonWithMeta(panel, meta);
				if (!button)
				{
					RaiseError(panel, EGRErrorCode::Generic, __ROCOCO_FUNCTION__, "Cannot find child with meta string: %s", meta);
					return;
				}

				button->SetEventPolicy(EGREventPolicy::NotifyAncestors);
				button->MakeToggleButton();

				bool isPressed = Eq(defaultButton, meta);
				button->SetPressedNoCallback(isPressed);

				auto i = mapMetaToToggler.find(meta);
				if (i != mapMetaToToggler.end())
				{
					cstr toggleDescription = i->second.c_str();
					auto* panel = FindPanelWithDescription(toggleDescription);
					if (panel)
					{
						panel->SetCollapsed(!isPressed);
					}
				}
			}
		}

		void LayoutBeforeFit() override
		{
			MakeGroupExclusive(defaultButtonString);
		}

		void LayoutBeforeExpand() override
		{

		}

		void LayoutAfterExpand() override
		{

		}

		EGREventRouting OnCursorClick(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnCursorMove(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{

		}

		void Render(IGRRenderContext& g) override
		{
			DrawPanelBackgroundEx(
				panel,
				g, 
				EGRSchemeColourSurface::CONTAINER_BACKGROUND,
				EGRSchemeColourSurface::CONTAINER_TOP_LEFT,
				EGRSchemeColourSurface::CONTAINER_BOTTOM_RIGHT,
				transparency
			);
		}

		EGREventRouting OnChildEvent(GRWidgetEvent& we, IGRWidget& src)
		{
			if (we.eventType == EGRWidgetEventType::BUTTON_CLICK)
			{
				auto* button = Cast<IGRWidgetButton>(src);
				if (button)
				{
					cstr meta = button->MetaData().stringData;
					for (auto& member : group)
					{
						if (Eq(meta, member))
						{
							MakeGroupExclusive(meta);
							return EGREventRouting::Terminate;
						}
					}
				}
			}

			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnKeyEvent(GRKeyEvent& ke) override
		{
			if (ke.osKeyEvent.IsUp())
			{
				return EGREventRouting::NextHandler;
			}

			auto* focusWidget = panel.Root().GR().FindFocusWidget();
			if (!focusWidget)
			{
				return EGREventRouting::NextHandler;
			}

			auto* buttonFocus = Cast<IGRWidgetButton>(*focusWidget);
			if (!buttonFocus)
			{
				return EGREventRouting::NextHandler;
			}

			switch (ke.osKeyEvent.VKey)
			{
			case Rococo::IO::VirtualKeys::VKCode_UP:
				if (navigation == EGRRadioNavigation::Vertical)
				{
					Gui::RotateFocusToNextSibling(*focusWidget, false);
					return EGREventRouting::Terminate;
				}				
				break;
			case Rococo::IO::VirtualKeys::VKCode_LEFT:
				if (navigation == EGRRadioNavigation::Horizontal)
				{
					Gui::RotateFocusToNextSibling(*focusWidget, false);
					return EGREventRouting::Terminate;
				}
				break;
			case Rococo::IO::VirtualKeys::VKCode_DOWN:
				if (navigation == EGRRadioNavigation::Vertical)
				{
					Gui::RotateFocusToNextSibling(*focusWidget, true);
					return EGREventRouting::Terminate;
				}
				break;
			case Rococo::IO::VirtualKeys::VKCode_RIGHT:
				if (navigation == EGRRadioNavigation::Horizontal)
				{
					Gui::RotateFocusToNextSibling(*focusWidget, true);
					return EGREventRouting::Terminate;
				}
				break;
			}

			return EGREventRouting::NextHandler;
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			auto result = QueryForParticularInterface<IGRWidgetInitializer>(this, ppOutputArg, interfaceId);
			if (result == EGRQueryInterfaceResult::SUCCESS)
			{
				return result;
			}
			result = QueryForParticularInterface<IGRWidgetLayout>(this, ppOutputArg, interfaceId);
			if (result == EGRQueryInterfaceResult::SUCCESS)
			{
				return result;
			}
			return QueryForParticularInterface<IGRWidgetRadioButtons>(this, ppOutputArg, interfaceId);
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRRadioButtons";
		}

		void AddButtonToGroup(cstr description) override
		{
			if (description == nullptr || *description == 0)
			{
				RaiseError(panel, EGRErrorCode::InvalidArg, __ROCOCO_FUNCTION__, "Blank [description]");
			}

			group.push_back(description);
		}

		EGRRadioNavigation navigation = EGRRadioNavigation::None;

		void SetNavigation(EGRRadioNavigation navigation) override
		{
			this->navigation = navigation;
		}

		void AddTab(cstr meta, cstr toggleTarget) override
		{
			if (meta == nullptr || toggleTarget == nullptr)
			{
				RaiseError(panel, EGRErrorCode::Generic, __ROCOCO_FUNCTION__, "Null argument");
			}

			for (auto& member : group)
			{
				if (Eq(member, meta))
				{
					mapMetaToToggler[meta] = toggleTarget;
					return;
				}
			}

			RaiseError(panel, EGRErrorCode::Generic, __ROCOCO_FUNCTION__, "Could not find tab for %s toggling %s in the radio button group list", meta, toggleTarget);
		}

		void SetDefaultButton(cstr defaultButton) override
		{
			if (defaultButton == nullptr || *defaultButton == 0)
			{
				RaiseError(panel, EGRErrorCode::InvalidArg, __ROCOCO_FUNCTION__, "Blank [defaultButton]");
			}

			defaultButtonString = defaultButton;
		}
	};

	struct GRRadioButtonsFactory : IGRWidgetFactory
	{
		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			return *new GRRadioButtons(panel);
		}
	};
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetInitializer::InterfaceId()
	{
		return "IGRWidgetInitializer";
	}

	ROCOCO_GUI_RETAINED_API cstr IGRWidgetRadioButtons::InterfaceId()
	{
		return "IGRWidgetRadioButtons";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetRadioButtons& CreateRadioButtonsManager(IGRWidget& parent)
	{
		auto& gr = parent.Panel().Root().GR();

		GRANON::GRRadioButtonsFactory factory;
		auto& rb = static_cast<GRANON::GRRadioButtons&>(gr.AddWidget(parent.Panel(), factory));
		return rb;
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.scheme.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.h>
#include <unordered_map>

using namespace Rococo;
using namespace Rococo::Gui;

namespace ANON
{
	struct GRWidgetRenderStateMiniScheme
	{
		struct MiniFocusScheme
		{
			RGBAb focusedColour;
			RGBAb notFocusedColour;
		};

		struct HoverAndFocus
		{
			MiniFocusScheme hovered;
			MiniFocusScheme notHovered;
		};

		HoverAndFocus pressed;
		HoverAndFocus notPressed;
	};

	struct Scheme : IGRSchemeSupervisor
	{
		std::unordered_map<EGRSchemeColourSurface, GRWidgetRenderStateMiniScheme> mapSurfaceToColour;

		void Free() override
		{
			delete this;
		}

		RGBAb GetColour(EGRSchemeColourSurface surface, GRWidgetRenderState rs) const override
		{
			auto i = mapSurfaceToColour.find(surface);
			if (i == mapSurfaceToColour.end())
			{
				return RGBAb(255, 255, 0, 64); // Semi transparent magenta is the colour that indicates undefined scheme entry
			}

			const GRWidgetRenderStateMiniScheme::HoverAndFocus& hf = rs.value.bitValues.pressed ? i->second.pressed : i->second.notPressed;
			const GRWidgetRenderStateMiniScheme::MiniFocusScheme f = rs.value.bitValues.hovered ? hf.hovered : hf.notHovered;
			return rs.value.bitValues.focused ? f.focusedColour : f.notFocusedColour;
		}

		void SetColour(EGRSchemeColourSurface surface, RGBAb colour, EGRColourSpec spec) override
		{
			switch(spec)
			{
			case EGRColourSpec::ForAllRenderStates:
				SetUniformColourForAllRenderStates(*this, surface, colour);
				break;
			case EGRColourSpec::ForAllPressedStates:
				SetColour(surface, colour, GRWidgetRenderState(true, false, false));
				SetColour(surface, colour, GRWidgetRenderState(true, false, true));
				SetColour(surface, colour, GRWidgetRenderState(true, true, false));
				SetColour(surface, colour, GRWidgetRenderState(true, true, true));
				break;
			case EGRColourSpec::ForAllFocusedStates:
				SetColour(surface, colour, GRWidgetRenderState(false, false, true));
				SetColour(surface, colour, GRWidgetRenderState(false, true, true));
				SetColour(surface, colour, GRWidgetRenderState(true, false, true));
				SetColour(surface, colour, GRWidgetRenderState(true, true, true));
				break;
			case EGRColourSpec::ForAllHoveredStates:
				SetColour(surface, colour, GRWidgetRenderState(false, true, false));
				SetColour(surface, colour, GRWidgetRenderState(false, true, true));
				SetColour(surface, colour, GRWidgetRenderState(true, true, false));
				SetColour(surface, colour, GRWidgetRenderState(true, true, true));
				break;
			}
		}

		void SetColour(EGRSchemeColourSurface surface, RGBAb colour, GRWidgetRenderState rs) override
		{
			auto i = mapSurfaceToColour.find(surface);
			if (i != mapSurfaceToColour.end())
			{
				GRWidgetRenderStateMiniScheme::HoverAndFocus& hf = rs.value.bitValues.pressed ? i->second.pressed : i->second.notPressed;
				GRWidgetRenderStateMiniScheme::MiniFocusScheme& f = rs.value.bitValues.hovered ? hf.hovered : hf.notHovered;
				RGBAb& target = rs.value.bitValues.focused ? f.focusedColour : f.notFocusedColour;
				target = colour;
			}
			else
			{						
				GRWidgetRenderStateMiniScheme newScheme;

				GRWidgetRenderStateMiniScheme::MiniFocusScheme mfs;
				mfs.focusedColour = colour;
				mfs.notFocusedColour = colour;

				GRWidgetRenderStateMiniScheme::HoverAndFocus hf;
				hf.hovered = mfs;
				hf.notHovered = mfs;

				newScheme.pressed = hf;
				newScheme.notPressed = hf;

				mapSurfaceToColour.emplace(surface, newScheme);
			}
		}

		bool TryGetColour(EGRSchemeColourSurface surface, RGBAb& colour, GRWidgetRenderState rs) const override
		{
			auto i = mapSurfaceToColour.find(surface);
			if (i == mapSurfaceToColour.end())
			{
				return false;
			}

			const GRWidgetRenderStateMiniScheme::HoverAndFocus& hf = rs.value.bitValues.pressed ? i->second.pressed : i->second.notPressed;
			const GRWidgetRenderStateMiniScheme::MiniFocusScheme f = rs.value.bitValues.hovered ? hf.hovered : hf.notHovered;
			colour = rs.value.bitValues.focused ? f.focusedColour : f.notFocusedColour;
			return true;
		}
	};
}

namespace Rococo::Gui
{
	IGRSchemeSupervisor* CreateGRScheme()
	{
		return new ANON::Scheme();
	}

	void SetAllHoverStates(IGRScheme& scheme, EGRSchemeColourSurface surface, RGBAb colour)
	{
		scheme.SetColour(surface, colour, EGRColourSpec::ForAllHoveredStates);
	}

	ROCOCO_GUI_RETAINED_API void SetSchemeColours_ThemeGrey(IGRScheme& scheme)
	{
		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::CONTAINER_BACKGROUND, RGBAb(64, 64, 64, 192));
		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::CONTAINER_TOP_LEFT, RGBAb(64, 64, 64, 192));
		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::BACKGROUND, RGBAb(64, 64, 64, 192));
		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::MENU_BUTTON, RGBAb(96, 96, 96, 255));
		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::MENU_BUTTON_EDGE_TOP_LEFT, RGBAb(64, 64, 64, 255));
		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::MENU_BUTTON_EDGE_BOTTOM_RIGHT, RGBAb(64, 64, 64, 255));
		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::BUTTON, RGBAb(96, 96, 96, 255));
		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::BUTTON_EDGE_TOP_LEFT, RGBAb(64, 64, 64, 255));
		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::BUTTON_EDGE_BOTTOM_RIGHT, RGBAb(64, 64, 64, 255));
		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::BUTTON_SHADOW, RGBAb(0, 0, 0, 0));
		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::BUTTON_TEXT, RGBAb(255, 255, 255, 255));

		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::EDIT_TEXT, RGBAb(224, 224, 224, 255));

		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::TEXT, RGBAb(224, 224, 224, 255));
		scheme.SetColour(EGRSchemeColourSurface::TEXT, RGBAb(255, 255, 255, 255), EGRColourSpec::ForAllHoveredStates);

		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::EDIT_TEXT, RGBAb(224, 224, 224, 255));
		scheme.SetColour(EGRSchemeColourSurface::EDIT_TEXT, RGBAb(255, 255, 255, 255), EGRColourSpec::ForAllHoveredStates);

		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::BUTTON_IMAGE_FOG, RGBAb(0, 0, 0, 0));
		scheme.SetColour(EGRSchemeColourSurface::BUTTON_IMAGE_FOG, RGBAb(0, 0, 0,   128), GRWidgetRenderState(0, 0, 0));
		scheme.SetColour(EGRSchemeColourSurface::BUTTON_IMAGE_FOG, RGBAb(64, 64, 64, 64), GRWidgetRenderState(0, 0, 1));
		scheme.SetColour(EGRSchemeColourSurface::BUTTON_IMAGE_FOG, RGBAb(0, 0, 0,    64), GRWidgetRenderState(0, 1, 0));
		scheme.SetColour(EGRSchemeColourSurface::BUTTON_IMAGE_FOG, RGBAb(64, 64, 64, 32), GRWidgetRenderState(0, 1, 1));
		scheme.SetColour(EGRSchemeColourSurface::BUTTON_IMAGE_FOG, RGBAb(64, 64, 64, 64), GRWidgetRenderState(0, 0, 1));

		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::SLIDER_BACKGROUND, RGBAb(64, 64, 64, 255));
		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::GAME_OPTION_BACKGROUND, RGBAb(64, 64, 64, 255));
		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::SLIDER_SLOT_BACKGROUND, RGBAb(128, 128, 128, 255));
		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::SLIDER_SLOT_EDGE_1, RGBAb(255, 255, 255, 255));
		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::SLIDER_SLOT_EDGE_2, RGBAb(192, 192, 192, 255));

		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::GAME_OPTION_TOP_LEFT, RGBAb(128, 128, 128, 255));
		SetAllHoverStates(scheme, EGRSchemeColourSurface::GAME_OPTION_TOP_LEFT, RGBAb(255, 255, 255, 255));

		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::GAME_OPTION_BOTTOM_RIGHT, RGBAb(96, 96, 96, 255));
		SetAllHoverStates(scheme, EGRSchemeColourSurface::GAME_OPTION_BOTTOM_RIGHT, RGBAb(128, 128, 128, 255));

		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::GAME_OPTION_TEXT, RGBAb(192, 192, 192, 255));
		SetAllHoverStates(scheme, EGRSchemeColourSurface::GAME_OPTION_TEXT, RGBAb(255, 255, 255, 255));

		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::GAME_OPTION_DISABLED_TEXT, RGBAb(96, 96, 96, 255));
		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::GAME_OPTION_DISABLED_BACKGROUND, RGBAb(48, 48, 48, 255));

		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::LABEL_SHADOW, RGBAb(0, 0, 0, 255));
		SetUniformColourForAllRenderStates(scheme, EGRSchemeColourSurface::FOCUS_RECTANGLE, RGBAb(255, 64, 64, 255));
	}

	ROCOCO_GUI_RETAINED_API void SetPropertyEditorColours_PastelScheme(IGRPanel& framePanel)
	{
		framePanel.Set(EGRSchemeColourSurface::SCROLLER_BUTTON_BACKGROUND, RGBAb(160, 160, 160, 255), EGRColourSpec::ForAllRenderStates);
		framePanel.Set(EGRSchemeColourSurface::SCROLLER_BUTTON_BACKGROUND, RGBAb(192, 192, 192, 255), GRWRS());
		framePanel.Set(EGRSchemeColourSurface::SCROLLER_BUTTON_TOP_LEFT, RGBAb(64, 64, 64, 255), EGRColourSpec::ForAllRenderStates);
		framePanel.Set(EGRSchemeColourSurface::SCROLLER_BUTTON_BOTTOM_RIGHT, RGBAb(32, 32, 32, 255), EGRColourSpec::ForAllRenderStates);
		framePanel.Set(EGRSchemeColourSurface::SCROLLER_BAR_BACKGROUND, RGBAb(225, 225, 225, 255), EGRColourSpec::ForAllRenderStates);
		framePanel.Set(EGRSchemeColourSurface::SCROLLER_BAR_TOP_LEFT, RGBAb(64, 64, 64, 255), EGRColourSpec::ForAllRenderStates);
		framePanel.Set(EGRSchemeColourSurface::SCROLLER_BAR_BOTTOM_RIGHT, RGBAb(32, 32, 32, 255), EGRColourSpec::ForAllRenderStates);
		framePanel.Set(EGRSchemeColourSurface::SCROLLER_SLIDER_BACKGROUND, RGBAb(64, 64, 64, 255), EGRColourSpec::ForAllRenderStates);
		framePanel.Set(EGRSchemeColourSurface::SCROLLER_SLIDER_TOP_LEFT, RGBAb(128, 128, 128, 255), EGRColourSpec::ForAllRenderStates);
		framePanel.Set(EGRSchemeColourSurface::SCROLLER_SLIDER_BOTTOM_RIGHT, RGBAb(96, 96, 96, 255), EGRColourSpec::ForAllRenderStates);
		framePanel.Set(EGRSchemeColourSurface::SCROLLER_TRIANGLE_NORMAL, RGBAb(224, 224, 224, 255), EGRColourSpec::ForAllRenderStates);
		framePanel.Set(EGRSchemeColourSurface::READ_ONLY_TEXT, RGBAb(128, 128, 128, 255), EGRColourSpec::ForAllRenderStates);
		SetUniformColourForAllRenderStates(framePanel, EGRSchemeColourSurface::ROW_COLOUR_EVEN, RGBAb(240, 240, 240));
		SetUniformColourForAllRenderStates(framePanel, EGRSchemeColourSurface::ROW_COLOUR_ODD, RGBAb(255, 255, 255));
		SetUniformColourForAllRenderStates(framePanel, EGRSchemeColourSurface::NAME_TEXT, RGBAb(0, 0, 0, 255));
		SetUniformColourForAllRenderStates(framePanel, EGRSchemeColourSurface::LABEL_BACKGROUND, RGBAb(255, 255, 255, 0));
		MakeTransparent(framePanel, EGRSchemeColourSurface::LABEL_SHADOW);
		SetUniformColourForAllRenderStates(framePanel, EGRSchemeColourSurface::EDITOR, RGBAb(192, 192, 192));
		SetUniformColourForAllRenderStates(framePanel, EGRSchemeColourSurface::EDIT_TEXT, RGBAb(0, 0, 0));
		SetUniformColourForAllRenderStates(framePanel, EGRSchemeColourSurface::COLLAPSER_TITLE_DEPTH_EVEN, RGBAb(255, 240, 240));
		SetUniformColourForAllRenderStates(framePanel, EGRSchemeColourSurface::COLLAPSER_TITLE_DEPTH_ODD, RGBAb(240, 255, 240));
		framePanel.Set(EGRSchemeColourSurface::COLLAPSER_TITLE_DEPTH_EVEN, RGBAb(64, 64, 64, 255), EGRColourSpec::ForAllFocusedStates);
		framePanel.Set(EGRSchemeColourSurface::COLLAPSER_TITLE_DEPTH_ODD, RGBAb(64, 64, 64, 255), EGRColourSpec::ForAllFocusedStates);
		SetUniformColourForAllRenderStates(framePanel, EGRSchemeColourSurface::COLLAPSER_TITLE_TEXT, RGBAb(0, 0, 0, 255));
		MakeTransparent(framePanel, EGRSchemeColourSurface::COLLAPSER_TITLE_SHADOW);
		SetUniformColourForAllRenderStates(framePanel, EGRSchemeColourSurface::VALUE_TEXT, RGBAb(0, 0, 0, 255));
		MakeTransparent(framePanel, EGRSchemeColourSurface::BUTTON_IMAGE_FOG);
		framePanel.Set(EGRSchemeColourSurface::BUTTON_IMAGE_FOG, RGBAb(192, 192, 192, 32), GRWidgetRenderState(0, 1, 0));
		framePanel.Set(EGRSchemeColourSurface::BUTTON_IMAGE_FOG, RGBAb(192, 192, 192, 48), GRWidgetRenderState(0, 0, 1));
		framePanel.Set(EGRSchemeColourSurface::BUTTON_IMAGE_FOG, RGBAb(192, 192, 192, 64), GRWidgetRenderState(0, 1, 1));
		framePanel.Set(EGRSchemeColourSurface::BACKGROUND, RGBAb(255, 0, 0, 0), EGRColourSpec::ForAllRenderStates);
	}

	ROCOCO_GUI_RETAINED_API void MakeTransparent(IGRPanel& panel, EGRSchemeColourSurface surface)
	{
		SetUniformColourForAllRenderStates(panel, surface, RGBAb(255, 255, 0, 0));
	}

	ROCOCO_GUI_RETAINED_API void SetUniformColourForAllRenderStates(IGRScheme& scheme, EGRSchemeColourSurface surface, RGBAb colour)
	{
		GRWidgetRenderState::ForEachPermutation([&scheme, surface, colour](GRWidgetRenderState rs)
			{
				scheme.SetColour(surface, colour, rs);
			}
		);
	}

	ROCOCO_GUI_RETAINED_API void SetUniformColourForAllRenderStates(IGRPanel& panel, EGRSchemeColourSurface surface, RGBAb colour)
	{
		GRWidgetRenderState::ForEachPermutation([&panel, surface, colour](GRWidgetRenderState rs)
			{
				panel.Set(surface, colour, rs);
			}
		);
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.scrollable-menu.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <rococo.strings.h>
#include <math.h>
#include <vector>
#include <rococo.ui.h>
#include <rococo.vkeys.h>

using namespace Rococo;
using namespace Rococo::Gui;
using namespace Rococo::Strings;

namespace GRANON
{
	struct ButtonWatcher : IGRPanelWatcher
	{
		void OnSetConstantHeight(IGRPanel& panel, int height) override
		{
			UNUSED(panel);
			UNUSED(height);
		}

		void OnSetConstantWidth(IGRPanel& panel, int width) override
		{
			UNUSED(panel);
			UNUSED(width);
		}

		Vec2i lastButtonSpan{ 0,0 };

		void OnSetAbsRect(IGRPanel& panel, const GuiRect& absRect) override
		{
			UNUSED(panel);
			lastButtonSpan = Span(absRect);
		}
	};

	struct GRScrollableMenu : IGRWidgetScrollableMenu, IGRWidgetSupervisor
	{
		struct Option
		{
			HString key;
			HString value;
			IGRWidgetButton* button;
		};

		IGRPanel& panel;

		std::vector<Option> options;

		int optionIndex = 1;

		int optionSpan = 200;

		GRAnchorPadding buttonPadding{ 0,0,0,0 };

		IGRWidgetViewport* viewport = nullptr;

		ButtonWatcher watcher; // used for debugging, put breakpoints in the watcher implementation if needs be
		
		GRScrollableMenu(IGRPanel& owningPanel) : panel(owningPanel)
		{
			panel.SetLayoutDirection(ELayoutDirection::LeftToRight);
		}

		virtual ~GRScrollableMenu()
		{

		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		void Free() override
		{
			delete this;
		}

		void PostConstruct()
		{
			viewport = &CreateViewportWidget(*this);
			viewport->Panel().SetExpandToParentHorizontally().SetExpandToParentVertically();
			viewport->ClientArea().Panel().SetLayoutDirection(ELayoutDirection::TopToBottom).SetClipChildren(true);
			viewport->SetMovePageScale(0.5);
		}

		void AddOption(cstr name, cstr caption, cstr hint) override
		{
			auto* button = &CreateButton(viewport->ClientArea().Widget());
			button->Panel().SetExpandToParentHorizontally();
			button->Panel().Set(buttonPadding);
			button->FitTextVertically();
			button->SetTitle(caption);
			button->SetClickCriterion(EGRClickCriterion::OnDownThenUp);
			button->SetEventPolicy(EGREventPolicy::NotifyAncestors);
			button->SetBackSurface(EGRSchemeColourSurface::CAROUSEL_DROP_DOWN_BACKGROUND);
			button->SetTextSurface(EGRSchemeColourSurface::CAROUSEL_DROP_DOWN_TEXT);
			button->SetFontId(buttonFontId);
			button->Panel().SetPanelWatcher(&watcher);
			button->TriggerOnKeyDown();
			button->Panel().SetHint(hint);
			button->FocusOnMouseMove(true);

			GRControlMetaData metaData;
			metaData.stringData = name;
			button->SetMetaData(metaData, true);

			options.push_back({ name, caption, button });

			size_t domainHeight = ComputeDomainHeight();

			viewport->SetDomainHeight((int) domainHeight);
		}

		int ComputeDomainHeight() const override
		{
			if (options.size() == 0)
			{
				return 0;
			}

			int buttonHeight = watcher.lastButtonSpan.y;
			return (int) (buttonHeight * options.size());
		}

		IGRWidgetButton* GetButtonUnderPoint(Vec2i position) override
		{
			if (panel.IsCollapsed())
			{
				return nullptr;
			}

			if (!IsPointInRect(position, panel.AbsRect()))
			{
				return nullptr;
			}

			for (auto& opt : options)
			{
				if (IsPointInRect(position, opt.button->Panel().AbsRect()))
				{
					return opt.button;
				}
			}

			return nullptr;
		}

		GRFontId buttonFontId = GRFontId::NONE;

		Vec2i LastComputedButtonSpan() const override
		{
			return watcher.lastButtonSpan;
		}

		cstr GetAncestorsHint()
		{
			for (auto* parent = panel.Parent(); parent != nullptr; parent = parent->Parent())
			{
				cstr hint = parent->Hint();
				if (hint && *hint != 0)
				{
					return hint;
				}
			}

			return nullptr;
		}

		void OnVisible() override
		{
			cstr rootHint = GetAncestorsHint();

			for (auto& opt : options)
			{
				auto* hint = opt.button->Panel().Hint();
				if (hint && StartsWith(hint, "$*$"))
				{
					char fullHint[1024];
					SafeFormat(fullHint, "%s%s%s", rootHint, hint + 3, opt.value.c_str());
					opt.button->Panel().SetHint(fullHint);
				}
			}
		}

		void SetOptionFont(GRFontId fontId) override
		{
			buttonFontId = fontId;
		}

		void SetOptionPadding(const GRAnchorPadding& padding) override
		{
			buttonPadding = padding;
		}

		EGREventRouting OnCursorClick(GRCursorEvent& ce) override
		{
			if (ce.click.LeftButtonUp && !IsPointInRect(ce.position, panel.AbsRect()))
			{
				GRWidgetEvent ev;
				ev.clickPosition = ce.position;
				ev.eventType = EGRWidgetEventType::BUTTON_CLICK_OUTSIDE;
				ev.iMetaData = 0;
				ev.isCppOnly = true;
				ev.panelId = panel.Id();
				ev.sMetaData = nullptr;
				panel.NotifyAncestors(ev, *this);
				return EGREventRouting::Terminate;
			}
			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{
		}

		void SetFocusWithoutCallback(IGRWidgetButton& button)
		{
			SetFocusWithNoCallback(button.Panel());
		}

		void SetFocusToTopmostVisibleButton(int deltaOffset)
		{
			if (options.size() == 0)
			{
				return;
			}

			int y = panel.AbsRect().top + deltaOffset;

			if (y < options[0].button->Panel().AbsRect().top)
			{
				SetFocusWithoutCallback(*options[0].button);
				return;
			}

			for (auto& opt : options)
			{
				GuiRect rect = opt.button->Panel().AbsRect();
				if (y <= rect.top && y < rect.bottom)
				{
					SetFocusWithoutCallback(*opt.button);
					return;
				}
			}

			SetFocusWithoutCallback(*options.back().button);
		}

		void OnFocusPageChange(int delta)
		{
			int beforeMove = viewport->GetOffset();
			viewport->VScroller().Scroller().MovePage(delta);
			int afterMove = viewport->GetOffset();

			int deltaOffset = afterMove - beforeMove;

			if (deltaOffset == 0)
			{
				// We scrolled to the last bit of the scrollable menu, so pick the extreme end button
				if (delta > 0) SetFocusWithoutCallback(*options.back().button);
				else		   SetFocusWithoutCallback(*options.front().button);
				return;
			}

			SetFocusToTopmostVisibleButton(deltaOffset);
		}

		EGREventRouting OnChildEvent(GRWidgetEvent&, IGRWidget&) override
		{
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnCursorMove(GRCursorEvent& ce) override
		{
			if (panel.Root().CapturedPanelId() == panel.Id())
			{
				auto& vpPanel = viewport->ClientArea().Panel();
				int nChildren = vpPanel.EnumerateChildren(nullptr);
				for (int i = 0; i < nChildren; i++)
				{
					auto* child = vpPanel.GetChild(i);
					if (IsPointInRect(ce.position, child->AbsRect()))
					{
						child->Widget().Manager().OnCursorMove(ce);
						break;
					}
				}
			}
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnKeyEvent(GRKeyEvent& ke) override
		{
			if (ke.osKeyEvent.IsUp())
			{
				return EGREventRouting::NextHandler;
			}

			auto* focusWidget = panel.Root().GR().FindFocusWidget();

			if (!focusWidget)
			{
				return EGREventRouting::NextHandler;
			}

			auto* pButton = Cast<IGRWidgetButton>(*focusWidget);
			if (!pButton)
			{
				return EGREventRouting::NextHandler;
			}

			auto& button = pButton->Widget();

			switch (ke.osKeyEvent.VKey)
			{
			case IO::VirtualKeys::VKCode_ANTITAB:
			case IO::VirtualKeys::VKCode_UP:
				RotateFocusToNextSibling(button, false);
				NotifySelectionChanged(panel, EGRSelectionChangeOrigin::VMenuKeyNav);
				return EGREventRouting::Terminate;
			case IO::VirtualKeys::VKCode_TAB:
			case IO::VirtualKeys::VKCode_DOWN:
				RotateFocusToNextSibling(button, !ke.context.isCtrlHeld);
				NotifySelectionChanged(panel, EGRSelectionChangeOrigin::VMenuKeyNav);
				return EGREventRouting::Terminate;
			case IO::VirtualKeys::VKCode_PGUP:
				OnFocusPageChange(-1);
				NotifySelectionChanged(panel, EGRSelectionChangeOrigin::VMenuKeyNav);
				return EGREventRouting::Terminate;
			case IO::VirtualKeys::VKCode_PGDOWN:
				NotifySelectionChanged(panel, EGRSelectionChangeOrigin::VMenuKeyNav);
				OnFocusPageChange(1);
				return EGREventRouting::Terminate;
			case IO::VirtualKeys::VKCode_HOME:
				viewport->VScroller().Scroller().SetSliderPosition(0);
				viewport->SetOffset(0, true);
				SetFocusWithoutCallback(*options.front().button);
				NotifySelectionChanged(panel, EGRSelectionChangeOrigin::VMenuKeyNav);
				return EGREventRouting::Terminate;
			case IO::VirtualKeys::VKCode_END:
				viewport->VScroller().Scroller().SetSliderPosition(-1);
				viewport->SetOffset(-1, true);
				SetFocusWithoutCallback(*options.back().button);
				NotifySelectionChanged(panel, EGRSelectionChangeOrigin::VMenuKeyNav);
				return EGREventRouting::Terminate;
			}

			return EGREventRouting::NextHandler;
		}

		void SignalButtonClick(int optionIndex) override
		{
			if (optionIndex < 0 || optionIndex >= (int)options.size())
			{
				return;
			}

			auto& button = *options[optionIndex].button;
			GRWidgetEvent widgetEvent{ EGRWidgetEventType::BUTTON_CLICK, button.Panel().Id(), 0, "SignalButtonClick", {0,0}, true };
			auto result = panel.NotifyAncestors(widgetEvent, button.Widget());
			UNUSED(result);
		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		void Render(IGRRenderContext& g) override
		{
			// Viewport expands to the widget area and covers up everything we would render, so our method is empty
			viewport->SetLineDeltaPixels(LastComputedButtonSpan().y);

			if (panel.IsCollapsed())
			{
				return;
			}

			for (auto* ancestor = panel.Parent(); ancestor != nullptr; ancestor = ancestor->Parent())
			{
				if (ancestor->HasFlag(EGRPanelFlags::OcclusionSurface))
				{
					DrawPanelBackgroundEx(*ancestor, g, EGRSchemeColourSurface::OCCLUSION_SURFACE, EGRSchemeColourSurface::NONE, EGRSchemeColourSurface::NONE);
					break;
				}
			}
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			return Gui::QueryForParticularInterface<IGRWidgetScrollableMenu, GRScrollableMenu>(this, ppOutputArg, interfaceId);
		}

		IGRWidgetViewport& Viewport() override
		{
			return *viewport;
		}

		IGRWidget& Widget() override
		{
			return *this;
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRScrollableMenu";
		}
	};

	struct GRScrollableMenuFactory : IGRWidgetFactory
	{
		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			AutoFree<GRScrollableMenu> newMenu = new GRScrollableMenu(panel);
			newMenu->PostConstruct();
			return *newMenu.Detach();
		}
	};
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetScrollableMenu::InterfaceId()
	{
		return "IGRWidgetScrollableMenu";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetScrollableMenu& CreateScrollableMenu(IGRWidget& parent)
	{
		auto& gr = parent.Panel().Root().GR();

		GRANON::GRScrollableMenuFactory menuFactory;
		auto& widget = gr.AddWidget(parent.Panel(), menuFactory);
		auto* menu = Cast<IGRWidgetScrollableMenu>(widget);
		return *menu;
	}

	ROCOCO_GUI_RETAINED_API void NotifySelectionChanged(IGRPanel& panel, EGRSelectionChangeOrigin origin)
	{
		panel.Root().NotifySelectionChanged(panel, origin);
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.slider.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <rococo.strings.h>
#include <math.h>

using namespace Rococo;
using namespace Rococo::Gui;

namespace GRANON
{
	struct GRSlider : IGRWidgetSlider, IGRWidgetSupervisor
	{
		IGRPanel& panel;

		bool isRaised = true;
		Strings::HString raisedImagePath;
		Strings::HString pressedImagePath;
		IGRImage* raisedImage = nullptr;
		IGRImage* pressedImage = nullptr;
		GRAnchorPadding slotPadding{ 24, 24, 4, 4 };
		int sliderPos = 0;

		int lastSliderSpan = 0;

		void* renderArgContext = nullptr;

		FN_RENDER_SLIDER fnRenderSlider = RenderSlider_Default;

		int bulbCount = 20;
		int bulbHGap = 6;
		int bulbVGap = 6;
		
		GRSlider(IGRPanel& owningPanel) : panel(owningPanel)
		{
		}

		virtual ~GRSlider()
		{

		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		void Free() override
		{
			delete this;
		}

		void SetRenderingMetrics(int bulbCount, int vgap, int hgap) override
		{
			this->bulbCount = bulbCount;
			this->bulbHGap = hgap;
			this->bulbVGap = vgap;
		}

		void SetSlotPadding(GRAnchorPadding padding) override
		{
			slotPadding = padding;
		}

		IGRWidgetSlider& SetImagePath(cstr imagePath) override
		{
			this->raisedImagePath = imagePath ? imagePath : "";
			this->pressedImagePath = imagePath ? imagePath : "";
			raisedImage = panel.Root().Custodian().CreateImageFromPath("raised button", this->raisedImagePath.c_str());
			pressedImage = panel.Root().Custodian().CreateImageFromPath("pressed button", this->pressedImagePath.c_str());
			return *this;
		}

		IGRWidgetSlider& SetPressedImagePath(cstr imagePath) override
		{
			this->pressedImagePath = imagePath ? imagePath : "";
			pressedImage = panel.Root().Custodian().CreateImageFromPath("pressed button", this->pressedImagePath.c_str());
			return *this;
		}

		IGRWidgetSlider& SetRaisedImagePath(cstr imagePath) override
		{
			this->raisedImagePath = imagePath ? imagePath : "";
			raisedImage = panel.Root().Custodian().CreateImageFromPath("raised button", this->raisedImagePath.c_str());
			return *this;
		}

		void SetRenderFunction(FN_RENDER_SLIDER fnRender, void* context)
		{
			this->fnRenderSlider = fnRender;
			this->renderArgContext = context;
		}

		double positionBeforeClick = 0;

		EGREventRouting OnCursorClick(GRCursorEvent& ce) override
		{
			if (ce.click.LeftButtonDown)
			{
				positionBeforeClick = position;
				isRaised = false;
				panel.CaptureCursor();
				if (!isRaised) UpdateSliderPos(ce.position);

				GRWidgetEvent mouseUp;
				mouseUp.eventType = EGRWidgetEventType::SLIDER_HELD;
				mouseUp.isCppOnly = true;
				mouseUp.iMetaData = 0;
				mouseUp.sMetaData = GetImplementationTypeName();
				panel.NotifyAncestors(mouseUp, *this);

				return EGREventRouting::Terminate;
			}
			else if (ce.click.LeftButtonUp)
			{
				isRaised = true;
				panel.Root().ReleaseCursor();

				GRWidgetEvent mouseUp;
				mouseUp.eventType = EGRWidgetEventType::SCROLLER_RELEASED;
				mouseUp.isCppOnly = true;
				mouseUp.iMetaData = 0;
				mouseUp.sMetaData = GetImplementationTypeName();
				panel.NotifyAncestors(mouseUp, *this);

				if (positionBeforeClick != position)
				{
					GRWidgetEvent posUpdated;
					posUpdated.eventType = EGRWidgetEventType::SLIDER_NEW_POS;
					posUpdated.isCppOnly = true;
					posUpdated.iMetaData = 0;
					posUpdated.sMetaData = GetImplementationTypeName();
					panel.NotifyAncestors(posUpdated, *this);
				}

				return EGREventRouting::Terminate;
			}
			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{
		}

		EGREventRouting OnChildEvent(GRWidgetEvent&, IGRWidget&) override
		{
			return EGREventRouting::NextHandler;
		}

		void UpdateSliderPos(Vec2i cursorPos)
		{
			int32 pixelRange = Width(panel.AbsRect()) - slotPadding.left - slotPadding.right;
			if (pixelRange <= 0)
			{
				return;
			}

			int absLeft = panel.AbsRect().left + slotPadding.left;

			sliderPos = clamp(cursorPos.x, absLeft, panel.AbsRect().right - slotPadding.right) - absLeft;

			double quotient = sliderPos / (double)pixelRange;

			position = minValue + quotient * (maxValue - minValue);

			if (quantum > 0)
			{
				double intPosition = floor(position);

				double qPosition = intPosition;

				for(double q = intPosition; q < position; q += quantum)
				{
					qPosition = q;
				}

				position = clamp(qPosition, minValue, maxValue);
			}
		}

		void SetSliderPosFromValuePos()
		{
			int32 pixelRange = Width(panel.AbsRect()) - slotPadding.left - slotPadding.right;
			if (pixelRange <= 0)
			{
				return;
			}

			position = clamp(position, minValue, maxValue);

			double range = maxValue - minValue;

			if (range == 0)
			{
				return;
			}

			double posRatio = (position - minValue) / (maxValue - minValue);

			double pixelPos = pixelRange * posRatio;
			sliderPos = (int)pixelPos;
		}

		EGREventRouting OnCursorMove(GRCursorEvent& ce) override
		{
			if (!isRaised) UpdateSliderPos(ce.position);
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnKeyEvent(GRKeyEvent&) override
		{
			return EGREventRouting::NextHandler;
		}

		double minValue = 0.0;
		double maxValue = 100.0;

		// If minValue > maxValue then the order is reversed. If they match are are not finite, the bar is disabled
		void SetRange(double minValue, double maxValue) override
		{
			this->minValue = minValue;
			this->maxValue = maxValue;
		}

		double Max() const override
		{
			return maxValue;
		}

		double Min() const override
		{
			return minValue;
		}

		double quantum = 0.25;

		GRFontId guageFont = GRFontId::NONE;
		int guageDecimalPlaces = 2;
		int guageVerticalOffset = 4;
		EGRSchemeColourSurface guageTextSurface = EGRSchemeColourSurface::GAME_OPTION_TEXT;

		void SetGuage(GRFontId fontId, int decimalPlaces, EGRSchemeColourSurface surface) override
		{
			guageFont = fontId;
			guageDecimalPlaces = decimalPlaces;
			guageTextSurface = surface;
		}

		void HideBackgroundWhenPartFilled(bool value) override
		{
			hideBackgroundWhenPartFilled = value;
		}

		// Represents the number of units to increment the position when an extremum button is clicked, or the left/right keys are used 
		void SetQuantum(double quantum) override
		{
			this->quantum = quantum;
		}

		double position = 0;

		double Position() const override
		{
			return position;
		}

		// Note that the true value is clamp of the supplied value using the range values
		void SetPosition(double value) override
		{
			double oldPos = position;
			position = value;
			SetSliderPosFromValuePos();

			if (position != oldPos)
			{
				GRWidgetEvent posUpdated;
				posUpdated.eventType = EGRWidgetEventType::SLIDER_NEW_POS;
				posUpdated.isCppOnly = true;
				posUpdated.iMetaData = 0;
				posUpdated.sMetaData = GetImplementationTypeName();
				panel.NotifyAncestors(posUpdated, *this);
			}
		}

		GRAlignmentFlags guageAlignment;
		Vec2i guageSpacing{ 0,0 };

		void SetGuageAlignment(GRAlignmentFlags alignment, Vec2i spacing) override
		{
			guageAlignment = alignment;
			guageSpacing = spacing;
		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		bool hideBackgroundWhenPartFilled = false;

		void Render(IGRRenderContext& g) override
		{
			if (lastSliderSpan != Width(panel.AbsRect()))
			{
				lastSliderSpan = Width(panel.AbsRect());
				SetSliderPosFromValuePos();
			}

			SliderDesc slider 
			{
				panel, slotPadding, isRaised, raisedImage, pressedImage, sliderPos, guageFont,
				guageAlignment, guageSpacing, guageDecimalPlaces, guageTextSurface, position, renderArgContext,
				minValue, maxValue, bulbCount, bulbHGap, bulbVGap, hideBackgroundWhenPartFilled
			};

			fnRenderSlider(g, slider);
		}

		GRAlignmentFlags alignment;
		Vec2i spacing { 0,0 };

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			return Gui::QueryForParticularInterface<IGRWidgetSlider, GRSlider>(this, ppOutputArg, interfaceId);
		}

		IGRWidget& Widget()
		{
			return *this;
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRSlider";
		}

		void Advance(int quanta) override
		{
			double oldPos = position;

			position += quanta * quantum;
			SetSliderPosFromValuePos();

			if (oldPos != position)
			{
				GRWidgetEvent posUpdated;
				posUpdated.eventType = EGRWidgetEventType::SLIDER_NEW_POS;
				posUpdated.isCppOnly = true;
				posUpdated.iMetaData = 0;
				posUpdated.sMetaData = GetImplementationTypeName();
				panel.NotifyAncestors(posUpdated, *this);

				NotifySelectionChanged(panel, EGRSelectionChangeOrigin::ScalarChangeKey);
			}
		}
	};

	struct GRSliderFactory : IGRWidgetFactory
	{
		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			auto* slider = new GRSlider(panel);
			return *slider;
		}
	} s_SliderFactory;
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetSlider::InterfaceId()
	{
		return "IGRWidgetSlider";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetSlider& CreateSlider(IGRWidget& parent)
	{
		auto& gr = parent.Panel().Root().GR();
		auto& widget = gr.AddWidget(parent.Panel(), GRANON::s_SliderFactory);
		auto* slider = static_cast<GRANON::GRSlider*>(Cast<IGRWidgetSlider>(widget));
		return *slider;
	}

	ROCOCO_GUI_RETAINED_API void RenderSlider_Default(IGRRenderContext& g, SliderDesc& slider)
	{
		auto& panel = slider.panel;
		auto& slotPadding = slider.slotPadding;
		bool isRaised = slider.isRaised;

		bool isHovered = g.IsHovered(panel);

		GuiRect sliderSlot = panel.AbsRect();
		sliderSlot.left += slotPadding.left;
		sliderSlot.right -= slotPadding.right;

		sliderSlot.top += slotPadding.top;
		sliderSlot.bottom -= slotPadding.bottom;

		int y = Centre(sliderSlot).y;

		RGBAb backColour = panel.GetColour(EGRSchemeColourSurface::SLIDER_BACKGROUND, GRWidgetRenderState(false, isHovered, false), RGBAb(255, 255, 0, 255));
		g.DrawRect(panel.AbsRect(), backColour);

		RGBAb sliderSlotColour = panel.GetColour(EGRSchemeColourSurface::SLIDER_SLOT_BACKGROUND, GRWidgetRenderState(false, isHovered, false), RGBAb(255, 0, 255, 255));
		g.DrawRect(sliderSlot, sliderSlotColour);

		RGBAb sliderEdge1Colour = panel.GetColour(EGRSchemeColourSurface::SLIDER_SLOT_EDGE_1, GRWidgetRenderState(false, isHovered, false), RGBAb(255, 0, 255, 255));
		RGBAb sliderEdge2Colour = panel.GetColour(EGRSchemeColourSurface::SLIDER_SLOT_EDGE_2, GRWidgetRenderState(false, isHovered, false), RGBAb(255, 0, 255, 255));

		g.DrawRectEdge(sliderSlot, sliderEdge1Colour, sliderEdge2Colour);

		IGRImage* image = isRaised ? slider.raisedImage : slider.pressedImage;

		GRWidgetRenderState rs(!isRaised, isHovered, false);

		if (image)
		{
			GRAlignmentFlags centred;
			centred.Add(EGRAlignment::HCentre).Add(EGRAlignment::VCentre);

			Vec2i imageSpan = image->Span();

			int renderedSliderPos = panel.AbsRect().left + slotPadding.left + clamp(slider.sliderPos, 0, Width(panel.AbsRect()) - slotPadding.right - slotPadding.left);

			int x = renderedSliderPos - (imageSpan.x / 2);

			GuiRect targetRect;
			targetRect.left = x;
			targetRect.top = y - 200;
			targetRect.bottom = y + 200;
			targetRect.right = x + imageSpan.x;
			g.DrawImageUnstretched(*image, targetRect, centred);
		}

		if (slider.guageFont != GRFontId::NONE)
		{
			char guageText[16];
			char format[16];

			Strings::SafeFormat(format, "%%.%df", slider.guageDecimalPlaces);

			Strings::SafeFormat(guageText, format, slider.position);

			RGBAb colour = panel.GetColour(slider.guageTextSurface, rs);
			g.DrawText(slider.guageFont, panel.AbsRect(), slider.guageAlignment, slider.guageSpacing, to_fstring(guageText), colour);
		}

		bool isObscured = DoesAncestorObscure(slider.panel);
		if (isObscured)
		{
			g.DrawRect(panel.AbsRect(), RGBAb(64, 64, 64, 192));
		}
	}

	ROCOCO_GUI_RETAINED_API void RenderSlider_AsLeftToRightBulbs(IGRRenderContext& g, SliderDesc& slider)
	{
		auto& panel = slider.panel;
		auto& slotPadding = slider.slotPadding;
		bool isRaised = slider.isRaised;

		bool isHovered = g.IsHovered(panel);

		GuiRect sliderSlot = panel.AbsRect();
		sliderSlot.left += slotPadding.left;
		sliderSlot.right -= slotPadding.right;

		sliderSlot.top += slotPadding.top;
		sliderSlot.bottom -= slotPadding.bottom;

		const int BULB_COUNT = slider.bulbCount;

		double valueSpan = slider.maxValue - slider.minValue;
		if (valueSpan != 0.0)
		{
			double quotient = clamp((slider.position - slider.minValue) / valueSpan, 0.0, 1.0);
			int nBulbsLit = (int)(round(quotient * BULB_COUNT));
			
			RGBAb bulbColour = panel.GetColour(EGRSchemeColourSurface::BUTTON, GRWidgetRenderState(false, isHovered, false), RGBAb(255, 255, 0, 255));

			bool hideBackground = nBulbsLit > 0 && slider.hideBackgroundWhenPartFilled;

			if (!hideBackground) // uncomment this if you want backgrounds to be hidden when sliders are part filled
			{
				RGBAb sliderSlotColour = panel.GetColour(EGRSchemeColourSurface::SLIDER_SLOT_BACKGROUND, GRWidgetRenderState(false, isHovered, false), RGBAb(255, 0, 255, 255));
				g.DrawRect(sliderSlot, sliderSlotColour);

				RGBAb sliderEdge1Colour = panel.GetColour(EGRSchemeColourSurface::SLIDER_SLOT_EDGE_1, GRWidgetRenderState(false, isHovered, false), RGBAb(255, 0, 255, 255));
				RGBAb sliderEdge2Colour = panel.GetColour(EGRSchemeColourSurface::SLIDER_SLOT_EDGE_2, GRWidgetRenderState(false, isHovered, false), RGBAb(255, 0, 255, 255));

				g.DrawRectEdge(sliderSlot, sliderEdge1Colour, sliderEdge2Colour);
			}
			 
			const int GAP_WIDTH = slider.bulbWidthPadding;

			double bulbWidth = (Width(sliderSlot) - GAP_WIDTH) / (double) BULB_COUNT;

			double bulbHeight = min(bulbWidth, (double) Height(sliderSlot) - 2.0 * slider.bulbHeightPadding);

			int y = Centre(sliderSlot).y;

			for (int i = 0; i < nBulbsLit; i++)
			{
				GuiRect bulbRect = sliderSlot;

				bulbRect.top = y - (int) (0.5 * bulbHeight);
				bulbRect.bottom  = y + (int) (0.5 * bulbHeight);

				bulbRect.left += (int)(i * bulbWidth) + GAP_WIDTH;
				bulbRect.right = bulbRect.left + (int) bulbWidth - GAP_WIDTH;

				g.DrawRect(bulbRect, bulbColour);
			}
		}

		GRWidgetRenderState rs(!isRaised, isHovered, false);

		if (slider.guageFont != GRFontId::NONE)
		{
			char guageText[16];
			char format[16];

			Strings::SafeFormat(format, "%%.%df", slider.guageDecimalPlaces);

			Strings::SafeFormat(guageText, format, slider.position);

			RGBAb colour = panel.GetColour(slider.guageTextSurface, rs);

			g.DrawText(slider.guageFont, panel.AbsRect(), slider.guageAlignment, slider.guageSpacing, to_fstring(guageText), colour);
		}

		bool isObscured = DoesAncestorObscure(slider.panel);
		if (isObscured)
		{
			g.DrawRect(panel.AbsRect(), RGBAb(64, 64, 64, 192));
		}
	}

	Rococo::Gui::FN_RENDER_SLIDER sliderCustomRenderer = RenderSlider_Default;

	ROCOCO_GUI_RETAINED_API void SetCustomSliderRenderer(FN_RENDER_SLIDER fnRender)
	{
		sliderCustomRenderer = fnRender;
	}

	ROCOCO_GUI_RETAINED_API void RenderSlider_Custom(IGRRenderContext& g, SliderDesc& slider)
	{
		sliderCustomRenderer(g, slider);
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.splitter.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <rococo.impressario.inl>
#include <vector>

namespace GRANON
{
	using namespace Rococo;
	using namespace Rococo::Gui;

	struct GRSplitter : IGRWidgetSplitter, IGRWidgetSupervisor, IGRWidgetLayout
	{
		IGRPanel& panel;
		IGRWidgetDivision* first = nullptr;
		IGRWidgetDivision* second = nullptr;
		int32 draggerThickness = 8;
		int32 draggerStartPos = 0;
		int32 realDraggerStartPos = 0;
		bool isHorizontal = true;
		GuiRect draggerRect {0,0,0,0};
		int32 virtualDraggerStartPos = -1;
		bool updateWithMouseMove;
		int32 splitterMin = 0;
		int32 splitterMax = 8192;

		GRSplitter(IGRPanel& _panel, int32 _draggerStartPos, bool _updateWithMouseMove) :
			panel(_panel), 
			draggerStartPos(_draggerStartPos),
			updateWithMouseMove(_updateWithMouseMove)
		{
			_panel.SetExpandToParentHorizontally();
			_panel.SetExpandToParentVertically();
			_panel.SetLayoutDirection(ELayoutDirection::LeftToRight);
			realDraggerStartPos = _draggerStartPos;
		}

		virtual ~GRSplitter()
		{

		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		void PostConstruct()
		{
			if (!first)
			{
				first = &CreateDivision(*this);
				second = &CreateDivision(*this);
			}
		}

		void LayoutBeforeFit() override
		{

		}

		void LayoutBeforeExpand() override
		{

		}

		void LayoutAfterExpand() override
		{
			first->Panel().
				SetExpandToParentVertically().SetConstantWidth(realDraggerStartPos).
				SetLayoutDirection(ELayoutDirection::TopToBottom);

			int offset = realDraggerStartPos + draggerThickness - 1;
			second->Panel().
				SetExpandToParentVertically().
				SetConstantWidth(panel.Parent()->Span().x - offset).
				SetParentOffset({ offset,0 }).SetLayoutDirection(ELayoutDirection::TopToBottom);
		}

		void Render(IGRRenderContext& g) override
		{
			draggerRect = panel.AbsRect();
			draggerRect.left += realDraggerStartPos + 1;
			draggerRect.right = draggerRect.left + draggerThickness - 2;

			bool isHovered = IsPointInRect(g.CursorHoverPoint(), draggerRect);

			GRWidgetRenderState rs(false, isHovered, false);

			RGBAb colour = panel.GetColour(EGRSchemeColourSurface::SPLITTER_BACKGROUND, rs, RGBAb(64, 64, 64, 255));
			g.DrawRect(draggerRect, colour);

			RGBAb edgeColour = panel.GetColour(EGRSchemeColourSurface::SPLITTER_EDGE, rs, RGBAb(64, 64, 64, 255));
			g.DrawRectEdge(draggerRect, edgeColour, edgeColour);

			if (virtualDraggerStartPos >= 0)
			{
				int delta = g.CursorHoverPoint().x - virtualDraggerStartPos;
				int virtualDraggerPos = clamp(clamp(draggerStartPos + delta, 0, panel.Span().x - draggerThickness - 2), splitterMin, splitterMax);

				GuiRect virtualRect = panel.AbsRect();
				virtualRect.left += virtualDraggerPos + 1;
				virtualRect.right = virtualRect.left + draggerThickness - 2;

				GRWidgetRenderState litEdgeState(true, isHovered, false);
				RGBAb litEdge = panel.GetColour(EGRSchemeColourSurface::SPLITTER_EDGE, litEdgeState, RGBAb(255, 255, 255, 255));
				g.DrawRectEdgeLast(virtualRect, litEdge, litEdge);
			}
		}

		void Free() override
		{
			delete this;
		}

		void LayoutHorizontal(const GuiRect& panelDimensions)
		{
			realDraggerStartPos = min(realDraggerStartPos, Width(panelDimensions) - draggerThickness);
			first->Panel().SetParentOffset({ 0,0 }).Resize({ realDraggerStartPos, Height(panelDimensions)});
			second->Panel().SetParentOffset({ realDraggerStartPos + draggerThickness,0 }).Resize({ Width(panelDimensions) - (realDraggerStartPos + draggerThickness), Height(panelDimensions)});
		}

		EGREventRouting OnCursorClick(GRCursorEvent& ce) override
		{
			if (ce.click.LeftButtonUp)
			{
				if (panel.Id() == panel.Root().GR().GetFocusId())
				{
					panel.Root().GR().SetFocus(-1);
				}

				if (virtualDraggerStartPos >= 0)
				{
					int delta = ce.position.x - virtualDraggerStartPos;
					virtualDraggerStartPos = -1;
					realDraggerStartPos = clamp(clamp(draggerStartPos + delta, 0, panel.Span().x - draggerThickness - 2), splitterMin, splitterMax);
					draggerStartPos = realDraggerStartPos;

					evOnSplitterChanged.Invoke(realDraggerStartPos);
				}

				return EGREventRouting::Terminate;
			}
			else if (ce.click.LeftButtonDown)
			{
				if (virtualDraggerStartPos > 0)
				{
					// We lost focus and missed the previous mouse down
					virtualDraggerStartPos = -1;
					draggerStartPos = realDraggerStartPos;
					return EGREventRouting::Terminate;;
				}
				if (IsPointInRect(ce.position, draggerRect))
				{
					panel.FocusAndNotifyAncestors();
					virtualDraggerStartPos = ce.position.x;
					return EGREventRouting::Terminate;
				}
			}

			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnChildEvent(GRWidgetEvent&, IGRWidget&) override
		{
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnCursorMove(GRCursorEvent& ce) override
		{
			if (!panel.HasFocus())
			{
				if (virtualDraggerStartPos >= 0)
				{
					virtualDraggerStartPos = -1;
					draggerStartPos = realDraggerStartPos;
				}
			}

			bool isDraggerHovered = IsPointInRect(ce.position, draggerRect);
			if (isDraggerHovered)
			{
				ce.nextIcon = EGRCursorIcon::LeftAndRightDragger;
			}

			if (updateWithMouseMove && virtualDraggerStartPos >= 0)
			{
				int delta = ce.position.x - virtualDraggerStartPos;
				realDraggerStartPos = clamp(clamp(draggerStartPos + delta, 0, panel.Span().x - draggerThickness - 2), splitterMin, splitterMax);;
			}

			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{

		}

		EGREventRouting OnKeyEvent(GRKeyEvent&) override
		{
			return EGREventRouting::NextHandler;
		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		IGRWidgetDivision& First() override
		{
			return *first;
		}

		IGRWidgetDivision& Second() override
		{
			return *second;
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			auto result = Gui::QueryForParticularInterface<IGRWidgetLayout>(this, ppOutputArg, interfaceId);
			if (result == EGRQueryInterfaceResult::SUCCESS)
			{
				return result;
			}
			return Gui::QueryForParticularInterface<IGRWidgetSplitter>(this, ppOutputArg, interfaceId);
		}

		IGRWidgetSplitter& SetDraggerMinMax(int32 minValue, int32 maxValue) override
		{
			splitterMin = minValue;
			splitterMax = maxValue;
			return *this;
		}

		EventImpressario<int> evOnSplitterChanged;

		IEventImpressario<int>& EvOnSplitSizeChanged()
		{
			return evOnSplitterChanged;
		}

		IGRWidget& Widget() override
		{
			return *this;
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRSplitter";
		}
	};

	struct GRSplitterFactory : IGRWidgetFactory
	{
		int32 draggerStartPos;
		bool updateWithMouseMove;

		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			auto splitter = new GRSplitter(panel, draggerStartPos, updateWithMouseMove);
			splitter->PostConstruct();
			return *splitter;
		}
	};
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetSplitter::InterfaceId()
	{
		return "IGRWidgetSplitter";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetSplitter& CreateLeftToRightSplitter(IGRWidget& parent, int32 draggerStartPos, bool updateWithMouseMove)
	{
		auto& gr = parent.Panel().Root().GR();

		GRANON::GRSplitterFactory factory;
		factory.draggerStartPos = draggerStartPos;
		factory.updateWithMouseMove = updateWithMouseMove;
		return *Cast<IGRWidgetSplitter>(gr.AddWidget(parent.Panel(), factory));
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.system.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <vector>
#include <stdio.h>
#include <string>
#include <algorithm>
#include <rococo.maths.i32.h>
#include <unordered_map>
#include <rococo.maths.h>
#include <rococo.ui.h>
#include <rococo.ringbuffer.h>

#define ROCOCO_USE_SAFE_V_FORMAT
#include <rococo.strings.h>

using namespace Rococo;
using namespace Rococo::Gui;

namespace Rococo::Gui
{
	IGRLayoutSupervisor* CreateFullScreenLayout();
	IGRWidgetMainFrameSupervisor* CreateGRMainFrame(cstr name, IGRPanel& panel);
	IGRPanelSupervisor* CreatePanel(IGRPanelRootSupervisor& root, IGRPanelSupervisor* parent);

	bool operator == (const GuiRect& a, const GuiRect& b)
	{
		return a.left == b.left && a.right == b.right && a.top == b.top && a.bottom == b.bottom;
	}
}

namespace ANON
{
	struct GRSystem: IGRSystemSupervisor, IGRPanelRootSupervisor
	{
		GRConfig config;
		IGRCustodian& custodian;
		AutoFree<IGRSchemeSupervisor> scheme = CreateGRScheme();
		std::unordered_map<int64, IGRPanel*> mapIdToPanel;
		int queryDepth = 0;
		bool queueGarbageCollect = false;

		int grDebugFlags = 0;

		bool HasDebugFlag(EGRDebugFlags flag) const override
		{
			return (grDebugFlags & (int) flag) != 0;
		}

		void SetDebugFlags(int grDebugFlags) override
		{
			this->grDebugFlags |= (int)grDebugFlags;
		}

		struct FrameDesc
		{
			IGRPanelSupervisor* panel;
			IGRWidgetMainFrame* frame;
			std::string id;

			bool Eq(GRIdWidget other) const
			{
				return other.Name && strcmp(other.Name, id.c_str()) == 0;
			}
		};

		using TFrames = std::vector<FrameDesc>;

		TFrames frameDescriptors;

		OneReaderOneWriterCircleBuffer<GRWidgetEvent>* eventQueue;
		OneReaderOneWriterCircleBuffer<GRWidgetEvent>* dispatchQueue;

		enum { MAX_EVENT_QUEUE_LENGTH = 1024 };

		GRSystem(GRConfig& _config, IGRCustodian& _custodian) :
			config(_config),
			custodian(_custodian), 
			eventQueue(new OneReaderOneWriterCircleBuffer<GRWidgetEvent>(MAX_EVENT_QUEUE_LENGTH)),
			dispatchQueue(new OneReaderOneWriterCircleBuffer<GRWidgetEvent>(MAX_EVENT_QUEUE_LENGTH))
		{

		}

		virtual ~GRSystem()
		{
			for (auto& d : frameDescriptors)
			{
				d.panel->ReleasePanel();
			}

			delete eventQueue;
			delete dispatchQueue;
		}

		void OnTick(float dt) override
		{
			for (auto& d : frameDescriptors)
			{
				d.panel->OnTick(dt);
			}
		}

		void QueueGarbageCollect() override
		{
			queueGarbageCollect = true;
		}

		IGRWidget* FindWidget(int64 panelId)
		{
			auto i = mapIdToPanel.find(panelId);
			return i != mapIdToPanel.end() ? &i->second->Widget() : nullptr;
		}

		void NotifyPanelDeleted(int64 uniqueId)
		{
			mapIdToPanel.erase(uniqueId);
		}

		void Free() override
		{
			delete this;
		}

		IGRWidgetMainFrame& BindFrame(GRIdWidget id) override
		{
			if (queryDepth > 0)
			{
				custodian.RaiseError(nullptr, EGRErrorCode::RecursionLocked, __ROCOCO_FUNCTION__, "The GUI Retained API is locked for a recursive query. BindFrame cannot be executed here");
				IGRWidgetMainFrame* frame = nullptr;
				return *frame;
			}

			IGRWidgetMainFrame* oldFrame = FindFrame(id);
			if (oldFrame)
			{
				return *oldFrame;
			}

			// Create the frame descriptor string first, so we can pass a const reference to the internal string to the frame
			frameDescriptors.push_back(FrameDesc{ nullptr, nullptr, id.Name });

			auto& last = frameDescriptors.back();

			auto* newFramePanel = CreatePanel(*this, nullptr);
			auto* newFrame = CreateGRMainFrame(last.id.c_str(), * newFramePanel);
			newFramePanel->SetWidget(newFrame->WidgetSupervisor());
			last.panel = newFramePanel;
			last.frame = newFrame;

			mapIdToPanel.try_emplace(newFramePanel->Id(), newFramePanel);
			return *newFrame;
		}

		void DeleteFrame(GRIdWidget id) override
		{
			if (queryDepth > 0)
			{
				custodian.RaiseError(nullptr, EGRErrorCode::RecursionLocked, __ROCOCO_FUNCTION__, "The GUI Retained API is locked for a recursive query. FrameDelete cannot be executed here");
				return;
			}

			auto matchesId = [&id](const FrameDesc& desc)
			{
				return desc.Eq(id);
			};

			auto d = std::remove_if(frameDescriptors.begin(), frameDescriptors.end(), matchesId);
			frameDescriptors.erase(d, frameDescriptors.end());
		}

		IGRScheme& Scheme()
		{
			return *scheme;
		}

		Vec2i ScreenDimensions() const override
		{
			return Span(screenDimensions);
		}

		IGRWidgetMainFrame* FindFrame(GRIdWidget id) override
		{
			for (auto& d : frameDescriptors)
			{
				if (d.Eq(id))
				{
					return d.frame;
				}
			}

			return nullptr;
		}

		// Added to a method to prevent the API consumer from modifying the widget tree while the implementation expects the tree hierarchy to be immutable
		struct RecursionGuard
		{
			GRSystem& This;

			RecursionGuard(GRSystem& _This) : This(_This)
			{
				This.queryDepth++;
			}
			~RecursionGuard()
			{
				This.queryDepth--;
			}
		};

		void GarbageCollect() override
		{
			if (queryDepth > 0)
			{
				custodian.RaiseError(nullptr, EGRErrorCode::RecursionLocked, __ROCOCO_FUNCTION__, "The GUI Retained API is locked for a recursive query. GarbageCollect cannot be executed here");
				return;
			}

			RecursionGuard guard(*this);
			for (auto& d : frameDescriptors)
			{
				d.panel->GarbageCollectRecursive();
			}
		}

		Vec2i lastRenderedCursorPosition{ -10000000, -10000000 };

		std::vector<IGRPanelSupervisor*> deferredRenderQueue;

		void DeferRendering(IGRPanelSupervisor& panel) override
		{
			deferredRenderQueue.push_back(&panel);
		}

		GuiRect screenDimensions{ 0,0,0,0 };

		void RenderAllFrames(IGRRenderContext& g) override
		{
			lastRenderedCursorPosition = g.CursorHoverPoint();

			if (queueGarbageCollect)
			{
				GarbageCollect();
				queueGarbageCollect = false;
			}

			RecursionGuard guard(*this);

			screenDimensions = g.ScreenDimensions();

			for (auto& d : frameDescriptors)
			{
				d.panel->SetConstantWidth(Width(screenDimensions));
				d.panel->SetConstantHeight(Height(screenDimensions));
				d.panel->Layout();
			}

			for (auto& d : frameDescriptors)
			{
				d.panel->RenderRecursive(g, screenDimensions, true, focusId);
				g.DisableScissors();
			}

			for (auto* panel : deferredRenderQueue)
			{
				panel->RenderRecursive(g, screenDimensions, false, focusId);
				g.DisableScissors();
			}

			if (focusId >= 0)
			{
				auto* widget = FindFocusWidget();
				if (widget)
				{
					if (widget->Panel().IsCollapsedOrAncestorCollasped())
					{
						focusId = -1;
					}
					else
					{
						GuiRect rect = widget->Panel().AbsRect();
						if (rect.right > rect.left && rect.bottom > rect.top)
						{
							RGBAb colour = widget->Panel().GetColour(EGRSchemeColourSurface::FOCUS_RECTANGLE, GRWidgetRenderState(false, false, true), RGBAb(255, 255, 255, 255));
							g.DrawRectEdge(rect, colour, colour);
						}
					}
				}
			}

			deferredRenderQueue.clear();

			RenderDebugInfo(g);
		}

		IGRSystemSubRenderer* focusOverlayRenderer = nullptr;

		void RenderFocus(IGRPanel& panel, IGRRenderContext& g, const GuiRect& clipRect) override
		{
			if (focusOverlayRenderer)
			{
				focusOverlayRenderer->Render(panel, g, clipRect);
			}
		}

		void SetFocusOverlayRenderer(IGRSystemSubRenderer* subRenderer)
		{
			focusOverlayRenderer = subRenderer;
		}

		void RenderDebugInfo(IGRRenderContext& g)
		{
			Vec2i pos = g.CursorHoverPoint();

			GRFontId debugFontId = GRFontId::NONE;

			GRAlignmentFlags alignment;
			alignment.Add(EGRAlignment::Right);

			char cursorLine[32];
			Strings::SafeFormat(cursorLine, "%d      %d", pos.x, pos.y);

			GuiRect debugRect;
			debugRect.right = screenDimensions.right - 10;
			debugRect.left = debugRect.right - 160;
			debugRect.top = screenDimensions.top + 10;
			debugRect.bottom = debugRect.top + 30;
			g.DrawRect(debugRect, RGBAb(0, 0, 0, 128));
			g.DrawText(debugFontId, debugRect, alignment, { 10, 0 }, to_fstring(cursorLine), RGBAb(255, 255, 255));
		}

		void MakeFirstToRender(GRIdWidget id) override
		{
			auto matchesId = [&id](const FrameDesc& desc)
			{
				return desc.Eq(id);
			};

			auto i = std::find_if(frameDescriptors.begin(), frameDescriptors.end(), matchesId);
			if (i != frameDescriptors.end())
			{
				TFrames::iterator firstOne = frameDescriptors.begin();
				std::swap(i, firstOne);
			}
		}

		void MakeLastToRender(GRIdWidget id) override
		{
			auto matchesId = [&id](const FrameDesc& desc)
			{
				return desc.Eq(id);
			};
			
			auto i = std::find_if(frameDescriptors.begin(), frameDescriptors.end(), matchesId);
			if (i != frameDescriptors.end())
			{
				TFrames::iterator lastOne = frameDescriptors.begin();
				std::advance(i, frameDescriptors.size() - 1);
				std::swap(i, lastOne);
			}
		}

		IGRPanelRoot& Root() override
		{
			return *this;
		}

		IGRWidget& AddWidget(IGRPanel& parent, IGRWidgetFactory& factory)
		{
			auto& panel = parent.AddChild();
			auto& widget = factory.CreateWidget(panel);
			auto& superPanel = static_cast<IGRPanelSupervisor&>(panel);
			superPanel.SetWidget(widget.Supervisor());
			mapIdToPanel.try_emplace(panel.Id(), &panel);
			return widget;
		}

		IGRSystem& GR()
		{
			return *this;
		}

		bool isVisible = true;

		void SetVisible(bool isVisible) override
		{
			this->isVisible = isVisible;
		}

		bool IsVisible() const override
		{
			return isVisible && !frameDescriptors.empty();
		}

		EGREventRouting RouteCursorClickEvent(GRCursorEvent& ev) override
		{
			RecursionGuard guard(*this);

			if (captureId >= 0)
			{
				auto* widget = FindWidget(captureId);
				if (widget)
				{
					auto& panelSupervisor = static_cast<IGRPanelSupervisor&>(widget->Panel());
					if (panelSupervisor.RouteCursorClickEvent(ev, false) == EGREventRouting::NextHandler)
					{
						return widget->Manager().OnCursorClick(ev);
					}
					else
					{
						return EGREventRouting::Terminate;
					}
				}
			}

			for (auto d = frameDescriptors.rbegin(); d != frameDescriptors.rend(); ++d)
			{
				auto routing = d->panel->RouteCursorClickEvent(ev, true);
				if (routing == EGREventRouting::Terminate)
				{
					return EGREventRouting::Terminate;
				}
			}

			return EGREventRouting::NextHandler;
		}

		int64 captureId = -1;
		int64 focusId = -1;

		void CaptureCursor(IGRPanel& panel) override
		{
			captureId = panel.Id();
		}

		int64 CapturedPanelId() const override
		{
			return captureId;
		}

		void ReleaseCursor() override
		{
			captureId = -1;
		}

		typedef std::vector<GRPanelEvent> TPanelHistory;

		TPanelHistory movementCallstack;
		TPanelHistory previousMovementCallstack;

		TPanelHistory keypressCallstack;

		class PanelEventBuilder : public IGRPanelEventBuilder
		{
			TPanelHistory& history;
		public:
			PanelEventBuilder(TPanelHistory& _history): history(_history)
			{
			}

			IGRPanelEventBuilder& operator += (const GRPanelEvent& ev) override
			{
				history.push_back(ev);
				return *this;
			}
		};

		void RouteOnLeaveEvent()
		{
			// Suppose our movement callstack at time t + dt is A, B, C; but our previous callstack at time t was A, E, F, then we need to notify E and F that the cursor has left their domain
			for (int i = 0; i < previousMovementCallstack.size(); ++i)
			{
				auto& previousEvent = previousMovementCallstack[i];

				if (i >= movementCallstack.size() || previousEvent.panelId != movementCallstack[i].panelId)
				{
					for (int j = i; j < previousMovementCallstack.size(); ++j)
					{
						IGRWidget* widget = FindWidget(previousMovementCallstack[j].panelId);
						if (widget)
						{
							widget->Manager().OnCursorLeave();
						}
					}

					return;
				}
			}
		}

		void RouteOnEnterEvent()
		{
			// Suppose our movement callstack at time t + dt is A, B, C; but our previous callstack at time t was A, E, then we need to notify that B and C that the cursor has entered their domain
			for (int i = 0; i < movementCallstack.size(); ++i)
			{
				auto& moveEvent = movementCallstack[i];
				if (i >= previousMovementCallstack.size() || moveEvent.panelId != previousMovementCallstack[i].panelId)
				{
					for (int j = i; j < movementCallstack.size(); ++j)
					{
						IGRWidget* widget = FindWidget(movementCallstack[j].panelId);
						if (widget)
						{
							widget->Manager().OnCursorEnter();
						}
					}

					return;
				}
			}
		}

		bool TryAppendWidgetsUnderCursorToMovementCallstack(TPanelHistory& callstack, GRCursorEvent& ev)
		{
			if (captureId >= 0)
			{
				auto* widget = FindWidget(captureId);
				if (widget)
				{
					callstack.push_back({ captureId, & widget->Panel(), widget->Panel().AbsRect() });
				}
				else
				{
					captureId = -1;
					return false;
				}
			}
			else
			{
				PanelEventBuilder pb(callstack);

				for (auto d = frameDescriptors.rbegin(); d != frameDescriptors.rend(); ++d)
				{
					d->panel->BuildCursorMovementHistoryRecursive(ev, pb);
					if (!callstack.empty())
					{
						break;
					}
				}
			}

			return true;
		}

		bool TryAppendWidgetsUnderCursorCallstack(TPanelHistory& callstack)
		{
			if (captureId >= 0)
			{
				auto* widget = FindWidget(captureId);
				if (widget)
				{
					callstack.push_back({ captureId, &widget->Panel(), widget->Panel().AbsRect() });
				}
				else
				{
					captureId = -1;
					return false;
				}
			}
			else
			{
				PanelEventBuilder pb(callstack);

				for (auto d = frameDescriptors.rbegin(); d != frameDescriptors.rend(); ++d)
				{
					d->panel->BuildWidgetCallstackRecursiveUnderPoint(lastRenderedCursorPosition, pb);
					if (!callstack.empty())
					{
						break;
					}
				}
			}

			return true;
		}

		EGREventRouting RouteCursorMoveEvent(GRCursorEvent& ev) override
		{
			movementCallstack.clear();

			if (!TryAppendWidgetsUnderCursorToMovementCallstack(movementCallstack, ev) || movementCallstack.empty())
			{
				return EGREventRouting::Terminate;
			}

			EGREventRouting result = EGREventRouting::NextHandler;

			RecursionGuard guard(*this);

			if (movementCallstack.size() == 1 && movementCallstack[0].panelId == captureId)
			{
				auto* target = movementCallstack[0].panel;
				while (target)
				{
					if (target->Widget().Manager().OnCursorMove(ev) == EGREventRouting::Terminate)
					{
						break;
					}
					target = target->Parent();
				}
			}
			else
			{
				for (auto i = movementCallstack.rbegin(); i != movementCallstack.rend(); ++i)
				{
					if (i->panel->Widget().Manager().OnCursorMove(ev) == EGREventRouting::Terminate)
					{
						result = EGREventRouting::Terminate;
					}
				}
			}

			if (captureId == -1)
			{
				RouteOnLeaveEvent();
				RouteOnEnterEvent();
			}

			std::swap(movementCallstack, previousMovementCallstack);

			return result;
		}

		IGRWidgetSupervisor* TopMostFrame()
		{
			if (frameDescriptors.empty())
			{
				return nullptr;
			}

			return &frameDescriptors.back().frame->Widget().Supervisor();
		}

		EGREventRouting RouteKeyEventToPanelThenAncestors(IGRPanel& panel, GRKeyEvent& keyEvent)
		{
			auto result = panel.Widget().Manager().OnKeyEvent(keyEvent);
			if (result == EGREventRouting::Terminate)
			{
				return result;
			}

			for (auto* ancestor = panel.Parent(); ancestor != nullptr; ancestor = ancestor->Parent())
			{
				result = RouteKeyEventToPanelThenAncestors(*ancestor, keyEvent);
				if (result == EGREventRouting::Terminate)
				{
					return result;
				}
			}

			return EGREventRouting::NextHandler;
		}

		EGREventRouting RouteKeyEvent(GRKeyEvent& keyEvent) override
		{
			RecursionGuard guard(*this);

			if (focusId < 0)
			{
				IGRWidgetManager* frame = TopMostFrame();
				return frame ? frame->OnKeyEvent(keyEvent) : EGREventRouting::NextHandler;
			}

			auto* focusWidget = FindWidget(focusId);
			if (!focusWidget)
			{
				return EGREventRouting::Terminate;
			}

			return RouteKeyEventToPanelThenAncestors(focusWidget->Panel(), keyEvent);
		}

		IGRCustodian& Custodian() override
		{
			return custodian;
		}

		int64 GetFocusId() const override
		{
			return focusId;
		}

		void SetFocus(int64 id = -1) override
		{
			focusId = id;

			if (id == -1)
			{
				custodian.OnFocusChanged(nullptr);
			}
			else
			{
				auto* focusWidget = FindWidget(id);
				custodian.OnFocusChanged(focusWidget ? &focusWidget->Panel() : nullptr);
			}
		}

		IGREventHandler* eventHandler = nullptr;

		IGREventHandler* SetEventHandler(IGREventHandler* eventHandler) override
		{
			IGREventHandler* oldEventHandler = eventHandler;
			this->eventHandler = eventHandler;
			return oldEventHandler;
		}

		EGREventRouting OnGREvent(GRWidgetEvent& ev) override
		{
			auto* back = eventQueue->GetBackSlot();
			if (!back)
			{
				GRWidgetEvent discarded;
				eventQueue->TryPopFront(OUT discarded);
				back = eventQueue->GetBackSlot();
				if (!back)
				{
					Throw(0, "%s: Expected back slot after front was popped", __ROCOCO_FUNCTION__);
				}
			}

			*back = ev;

			eventQueue->WriteBack();
			
			return EGREventRouting::Terminate;
		}

		void DispatchMessages() override
		{
			if (queryDepth > 0)
			{
				this->custodian.RaiseError(nullptr, EGRErrorCode::RecursionLocked, __ROCOCO_FUNCTION__, "Error, API consumer attempted to DispatchMessages from within a GR locked section.");
			}

			std::swap(dispatchQueue, eventQueue);

			GRWidgetEvent ev;
			while (dispatchQueue->TryPopFront(OUT ev))
			{
				eventHandler->OnGREvent(ev);
			}
		}

		GRRealtimeConfig realtimeConfig;

		const GRRealtimeConfig& Config() const override
		{
			return realtimeConfig;
		}

		GRRealtimeConfig& MutableConfig() override
		{
			return realtimeConfig;
		}

		[[nodiscard]] IGRFonts& Fonts() override
		{
			return custodian.Fonts();
		}

		void OnNavigate(EGRNavigationDirective directive)
		{
			auto* focusedWidget = FindWidget(focusId);
			if (!focusedWidget)
			{
				return;
			}

			for(IGRPanel* panel = &focusedWidget->Panel(); panel != nullptr; panel = panel->Parent())
			{
				IGRNavigator* navigator = Cast<IGRNavigator>(panel->Widget());
				if (navigator)
				{
					if (EGREventRouting::Terminate == navigator->OnNavigate(directive))
					{
						return;
					}
				}
			}
		}

		void FocusDefaultTab() override
		{
			if (focusId > 0)
			{
				OnNavigate(EGRNavigationDirective::Tab);
			}
		}

		void ApplyKeyGlobally(GRKeyEvent& keyEvent) override
		{
			switch (keyEvent.osKeyEvent.VKey)
			{
			case IO::VirtualKeys::VKCode_TAB:
				if (keyEvent.osKeyEvent.IsUp())
				{
					FocusDefaultTab();
				}
			}
		}

		void NotifySelectionChanged(IGRPanel& panel, EGRSelectionChangeOrigin origin) override
		{
			if (changeHandler)
			{
				changeHandler->OnSelectionChanged(panel, origin);
			}
		}

		IGRSelectionChangeHandler* changeHandler = nullptr;

		void SetSelectionChangeHandler(Rococo::Gui::IGRSelectionChangeHandler* handler) override
		{
			changeHandler = handler;
		}
	};
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API IGRSystemSupervisor* CreateGRSystem(GRConfig& config, IGRCustodian& custodian)
	{
		return new ANON::GRSystem(config, custodian);
	}

	ROCOCO_GUI_RETAINED_API EGREventRouting RouteEventToHandler(IGRPanel& panel, GRWidgetEvent& ev)
	{
		auto& supervisor = static_cast<IGRSystemSupervisor&>(panel.Root().GR());
		return supervisor.OnGREvent(ev);
	}

	ROCOCO_GUI_RETAINED_API [[nodiscard]] bool DoInterfaceNamesMatch(cstr a, cstr b)
	{
		return Strings::EqI(a, b);
	}

	static bool Is(cstr a, cstr b)
	{
		return Strings::EqI(a, b);
	}

	ROCOCO_GUI_RETAINED_API GRAlignmentFlags::GRAlignmentFlags(cstr textRepresentation)
	{
		if (textRepresentation == nullptr)
		{
			Rococo::Throw(0, "%s: (nullptr)", __ROCOCO_FUNCTION__);
		}

		if (Is(textRepresentation, "left"))
		{
			Add(EGRAlignment::Left);
			return;
		}

		if (Is(textRepresentation, "right"))
		{
			Add(EGRAlignment::Right);
			return;
		}

		if (Is(textRepresentation, "top"))
		{
			Add(EGRAlignment::Top);
			return;
		}

		if (Is(textRepresentation, "bottom"))
		{
			Add(EGRAlignment::Bottom);
			return;
		}

		if (Is(textRepresentation, "topleft"))
		{
			Add(EGRAlignment::Left).Add(EGRAlignment::Top);
			return;
		}

		if (Is(textRepresentation, "topright"))
		{
			Add(EGRAlignment::Right).Add(EGRAlignment::Top);;
			return;
		}

		if (Is(textRepresentation, "bottomleft"))
		{
			Add(EGRAlignment::Left).Add(EGRAlignment::Top);
			return;
		}

		if (Is(textRepresentation, "bottomright"))
		{
			Add(EGRAlignment::Right).Add(EGRAlignment::Top);;
			return;
		}

		if (Is(textRepresentation, "centre"))
		{
			return;
		}

		Rococo::Throw(0, "Expecting one of [Left, Right, Top, Bottom, TopLeft, TopRight, BottomLeft, BottomRight, Centre]");
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetMainFrame* FindOwner(IGRWidget& widget)
	{
		IGRPanel* p = &widget.Panel(); 

		for (;;)
		{
			if (p->Parent() == nullptr)
			{
				return Cast<IGRWidgetMainFrame>(p->Widget());
			}

			p = p->Parent();
		}
	}

	ROCOCO_GUI_RETAINED_API [[nodiscard]] IGRWidgetManager& IGRWidget::Manager()
	{
		return static_cast<IGRWidgetManager&>(*this);
	}

	ROCOCO_GUI_RETAINED_API [[nodiscard]] IGRWidgetSupervisor& IGRWidget::Supervisor()
	{
		return static_cast<IGRWidgetSupervisor&>(*this);
	}

	ROCOCO_GUI_RETAINED_API void SetFocusWithNoCallback(IGRPanel& panel)
	{
		panel.Root().GR().SetFocus(panel.Id());
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.table.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <rococo.strings.h>
#include <vector>

using namespace Rococo;
using namespace Rococo::Strings;
using namespace Rococo::Gui;

namespace GRANON
{
	struct GRCell
	{
		IGRWidgetDivision* div = nullptr;
	};

	struct GRColumn
	{
		HString name;
		int minWidth;
		int defaultWidth;
		int maxWidth;
		int width;
	};

	struct GRTableRow
	{
		std::vector<GRCell> cellsInThisRow;
		int32 rowHeight;
	};

	struct GRTable : IGRWidgetTable, IGRWidgetSupervisor, IGRNavigator
	{
		IGRPanel& panel;

		std::vector<GRColumn> columnHeaders;
		std::vector<GRTableRow> rows;

		GRTable(IGRPanel& owningPanel) : panel(owningPanel)
		{
		}

		virtual ~GRTable()
		{

		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		int32 AddColumn(const GRColumnSpec& spec) override
		{
			columnHeaders.push_back(GRColumn{ spec.name, spec.minWidth, spec.defaultWidth, spec.maxWidth, spec.defaultWidth });

			for (auto& row : rows)
			{
				row.cellsInThisRow.push_back(GRCell{ &CreateDivision(*this) });
			}

			return (int32) columnHeaders.size() - 1;
		}

		void SetColumnWidth(int columnIndex, int pixelWidth) override
		{
			if (columnIndex < 0 || columnIndex > (int) columnHeaders.size())
			{
				RaiseError(panel, EGRErrorCode::InvalidArg, __ROCOCO_FUNCTION__, "column index %d out of bounds. Array size is %llu", columnIndex, columnHeaders.size());
			}

			int oldWidth = columnHeaders[columnIndex].width;
			if (oldWidth != pixelWidth)
			{
				columnHeaders[columnIndex].width = pixelWidth;
			}

			for (auto& row : rows)
			{
				auto& cell = row.cellsInThisRow[columnIndex];
				cell.div->Panel().SetConstantWidth(pixelWidth);
			}
		}

		void ExpandToFit()
		{
			int height = 0;

			for (auto& row : rows)
			{
				height += row.rowHeight;
			}

			panel.Resize({ panel.Span().x, height });
		}

		// Adds a new row and returns the row index of the new row
		int32 AddRow(const GRRowSpec& spec) override
		{
			rows.push_back(GRTableRow{});
			rows.back().cellsInThisRow.resize(columnHeaders.size());
			rows.back().rowHeight = spec.rowHeight;

			auto& row = CreateDivision(*this);
			row.Panel().SetConstantHeight(spec.rowHeight);
			row.Panel().SetExpandToParentHorizontally();
			row.Panel().SetLayoutDirection(ELayoutDirection::LeftToRight);

			for (auto& cell : rows.back().cellsInThisRow)
			{
				cell.div = &CreateDivision(row.Widget());
				cell.div->Panel().SetExpandToParentHorizontally();
				cell.div->Panel().SetConstantHeight(spec.rowHeight);
				cell.div->Panel().SetLayoutDirection(ELayoutDirection::LeftToRight);
			}

			ExpandToFit();

			return (int32) rows.size() - 1;
		}

		// Returns a reference to the cell at the given location. If the location indices are out of bounds, the method returns nullptr
		IGRWidgetDivision* GetCell(int32 column, int32 row) override
		{
			if (column < 0 || column >= (int32)columnHeaders.size())
			{
				return nullptr;
			}

			if (row < 0 || row >= (int32)rows.size())
			{
				return nullptr;
			}

			auto& cell = rows[row].cellsInThisRow[column];
			return cell.div;
		}

		int EstimateHeight() const override
		{
			int totalHeight = 0;

			for (auto& row : rows)
			{
				totalHeight += row.rowHeight;
			}

			return totalHeight;
		}

		void Free() override
		{
			delete this;
		}

		EGREventRouting OnCursorClick(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnCursorMove(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{

		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		void Render(IGRRenderContext&) override
		{
			// g.DrawRectEdge(panel.AbsRect(), RGBAb(255, 0, 0, 255), RGBAb(255, 0, 0, 255));
		}

		EGREventRouting OnChildEvent(GRWidgetEvent&, IGRWidget&)
		{
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnKeyEvent(GRKeyEvent&) override
		{
			return EGREventRouting::NextHandler;
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			if (ppOutputArg) *ppOutputArg = nullptr;
			if (!interfaceId || *interfaceId == 0) return EGRQueryInterfaceResult::INVALID_ID;

			if (DoInterfaceNamesMatch(interfaceId, IGRWidgetTable::InterfaceId()))
			{
				if (ppOutputArg)
				{
					*ppOutputArg = static_cast<IGRWidgetTable*>(this);					
				}

				return EGRQueryInterfaceResult::SUCCESS;
			}
			else if (DoInterfaceNamesMatch(interfaceId, IGRNavigator::InterfaceId()))
			{
				if (ppOutputArg)
				{
					*ppOutputArg = static_cast<IGRNavigator*>(this);
				}

				return EGRQueryInterfaceResult::SUCCESS;
			}

			return EGRQueryInterfaceResult::NOT_IMPLEMENTED;
		}

		struct RowAndColumn
		{
			int row;
			int column;

			bool operator == (RowAndColumn other) const
			{
				return row == other.row && column == other.column;
			}

			bool operator !=  (RowAndColumn other) const
			{
				return !(*this == other);
			}
		};

		RowAndColumn FindRowAndColumnOfChild(IGRPanel& childlId)
		{
			int y = 0;
			for (auto& row : rows)
			{
				int x = 0;
				for (auto& cell : row.cellsInThisRow)
				{
					if (cell.div && IsCandidateDescendantOfParent(cell.div->Panel(), childlId))
					{
						return { y, x };
					}
					x++;
				}
				y++;
			}

			return { -1,-1 };
		}

		RowAndColumn GetNextCell(RowAndColumn cellId, bool cycleToFirstRow)
		{
			int32 nColumns = (int32)columnHeaders.size();
			int32 nRows = (int32)rows.size();

			if (nColumns == 0 || nRows == 0 || cellId.column < 0 || cellId.row < 0)
			{
				return { -1, -1 };
			}

			int nextColumn = cellId.column + 1;
			int nextRow = cellId.row;

			if (nextColumn >= columnHeaders.size())
			{
				nextColumn = 0;
				nextRow++;
			}

			if (nextRow >= nRows)
			{
				if (cycleToFirstRow)
				{
					nextRow = 0;
				}
				else
				{
					return { -1, -1 };
				}
			}

			return { nextRow, nextColumn };
		}

		EGREventRouting OnNavigate(EGRNavigationDirective directive) override
		{
			auto* child = panel.Root().GR().FindFocusWidget();
			if (!child)
			{
				return EGREventRouting::Terminate;
			}

			RowAndColumn cellId = FindRowAndColumnOfChild(child->Panel());

			bool cycleToFirstRow = panel.HasFlag(EGRPanelFlags::CycleTabsEndlessly);

			if (directive == EGRNavigationDirective::Tab)
			{
				for (RowAndColumn nextCellId = GetNextCell(cellId, cycleToFirstRow); nextCellId != cellId; nextCellId = GetNextCell(nextCellId, cycleToFirstRow))
				{
					if (nextCellId.column < 0)
					{
						break;
					}

					auto* div = rows[nextCellId.row].cellsInThisRow[nextCellId.column].div;
					if (div)
					{
						if (TrySetDeepFocus(div->Panel()))
						{
							return EGREventRouting::Terminate;
						}
					}
				}
			}

			return EGREventRouting::NextHandler;
		}

		IGRWidget& Widget() override
		{
			return *this;
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRTable";
		}
	};

	struct GRTableFactory : IGRWidgetFactory
	{
		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			return *new GRTable(panel);
		}
	} s_TableFactory;
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetTable::InterfaceId()
	{
		return "IGRWidgetTable";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetTable& CreateTable(IGRWidget& parent)
	{
		auto& gr = parent.Panel().Root().GR();
		auto* table = Cast<IGRWidgetTable>(gr.AddWidget(parent.Panel(), GRANON::s_TableFactory));
		return *table;
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.toolbar.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <string>

using namespace Rococo;
using namespace Rococo::Gui;

namespace GRANON
{
	struct GRToolbar : IGRWidgetToolbar, IGRWidgetSupervisor
	{
		IGRPanel& panel;
		EGRAlignment childAlignment = EGRAlignment::Left;
		int32 interChildPadding = 4;
		int32 borderPadding = 1;

		GRToolbar(IGRPanel& owningPanel) : panel(owningPanel)
		{
		}

		virtual ~GRToolbar()
		{

		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		void Free() override
		{
			delete this;
		}

		void LayoutWithLeftAlignment(const GuiRect& panelDimensions)
		{
			int x = 1;

			int32 index = 0;
			while (auto* child = panel.GetChild(index++))
			{
				child->Resize({ child->Span().x, Height(panelDimensions) - 2 });
				x += child->Span().x;
				child->SetParentOffset({ x, 1 });
				x += interChildPadding;
			}
		}

		void LayoutWithRightAlignment(const GuiRect& panelDimensions)
		{
			int32 nChildren = panel.EnumerateChildren(nullptr);
			if (nChildren == 0)
			{
				return;
			}

			int x = Width(panelDimensions) - 1;

			for (int32 i = nChildren - 1; i >= 0; i--)
			{
				auto* child = panel.GetChild(i);
				child->Resize({ child->Span().x, Height(panelDimensions) - 2 });
				x -= child->Span().x;
				child->SetParentOffset({ x, 1 });
				x -= interChildPadding;
			}
		}

		void Layout(const GuiRect& panelDimensions)
		{
			if (childAlignment == EGRAlignment::Left)
			{
				LayoutWithLeftAlignment(panelDimensions);
			}
			else
			{
				LayoutWithRightAlignment(panelDimensions);
			}
		}

		EGREventRouting OnCursorClick(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnCursorMove(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{

		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		void Render(IGRRenderContext& g) override
		{
			auto rect = panel.AbsRect();

			bool isHovered = g.IsHovered(panel);
			GRWidgetRenderState rs(false, isHovered, false);

			RGBAb backColour = panel.GetColour(EGRSchemeColourSurface::CONTAINER_BACKGROUND, rs);
			g.DrawRect(rect, backColour);

			RGBAb edge1Colour = panel.GetColour(EGRSchemeColourSurface::CONTAINER_TOP_LEFT, rs);
			RGBAb edge2Colour = panel.GetColour(EGRSchemeColourSurface::CONTAINER_BOTTOM_RIGHT, rs);
			g.DrawRectEdge(rect, edge1Colour, edge2Colour);
		}

		Vec2i ResizeToFitChildren() override
		{
			return { 0,0 };
		}

		void SetChildAlignment(EGRAlignment alignment, int32 interChildPadding, int32 borderPadding) override
		{
			this->childAlignment = alignment;
			this->interChildPadding = interChildPadding;
			this->borderPadding = borderPadding;
		}

		EGREventRouting OnChildEvent(GRWidgetEvent&, IGRWidget&)
		{
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnKeyEvent(GRKeyEvent&) override
		{
			return EGREventRouting::NextHandler;
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			return Gui::QueryForParticularInterface<IGRWidgetToolbar>(this, ppOutputArg, interfaceId);
		}

		IGRWidget& Widget() override
		{
			return *this;
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRToolbar";
		}
	};

	struct GRToolbarFactory : IGRWidgetFactory
	{
		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			return *new GRToolbar(panel);
		}
	} s_ToolbarFactory;
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetToolbar::InterfaceId()
	{
		return "IGRWidgetToolbar";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetToolbar& CreateToolbar(IGRWidget& parent)
	{
		auto& gr = parent.Panel().Root().GR();
		auto* tools = Cast<IGRWidgetToolbar>(gr.AddWidget(parent.Panel(), GRANON::s_ToolbarFactory));
		return* tools;
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.vertical-list.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>

using namespace Rococo;
using namespace Rococo::Gui;

namespace GRANON
{
	// Note - this is not that much different from a division widget, and was used for vertical layout before
	// the panels had such layouts embedded in them.
	struct GRVerticalList : IGRWidgetVerticalList, IGRNavigator, IGRWidgetSupervisor
	{
		IGRPanel& panel;
		bool enforcePositiveChildHeights;

		GRVerticalList(IGRPanel& owningPanel, bool _enforcePositiveChildHeights) :
			panel(owningPanel), 
			enforcePositiveChildHeights(_enforcePositiveChildHeights)
		{
			owningPanel.SetLayoutDirection(ELayoutDirection::TopToBottom);
		}

		virtual ~GRVerticalList()
		{

		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		void Free() override
		{
			delete this;
		}

		IGRWidget& Widget() override
		{
			return *this;
		}

		EGREventRouting OnCursorClick(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnCursorMove(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{

		}

		EGREventRouting OnKeyEvent(GRKeyEvent&) override
		{
			return EGREventRouting::NextHandler;
		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		void Render(IGRRenderContext& g) override
		{
			auto rect = panel.AbsRect();

			bool isHovered = g.IsHovered(panel);
			GRWidgetRenderState rs(false, isHovered, false);
			RGBAb backColour = panel.GetColour(EGRSchemeColourSurface::CONTAINER_BACKGROUND, rs);
			g.DrawRect(rect, backColour);

			RGBAb edge1Colour = panel.GetColour(EGRSchemeColourSurface::CONTAINER_TOP_LEFT, rs);
			RGBAb edge2Colour = panel.GetColour(EGRSchemeColourSurface::CONTAINER_BOTTOM_RIGHT, rs);
			g.DrawRectEdge(rect, edge1Colour, edge2Colour);

			// g.DrawRectEdge(panel.AbsRect(), RGBAb(255, 0, 0, 255), RGBAb(255, 0, 0, 255));
		}

		EGREventRouting OnChildEvent(GRWidgetEvent&, IGRWidget&) override
		{
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnTab()
		{
			auto* focus = panel.Root().GR().FindFocusWidget();
			if (!focus)
			{
				return EGREventRouting::Terminate;
			}

			int32 childIndex = 0;
			while (auto* child = panel.GetChild(childIndex++))
			{
				if (IsCandidateDescendantOfParent(*child, focus->Panel()))
				{
					auto* nextChild = panel.GetChild(childIndex++);
					if (nextChild == nullptr && panel.HasFlag(EGRPanelFlags::CycleTabsEndlessly))
					{
						nextChild = panel.GetChild(0);
					}
					
					if (nextChild && TrySetDeepFocus(*nextChild))
					{
						return EGREventRouting::Terminate;
					}
				}
			}

			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnNavigate(EGRNavigationDirective directive) override
		{
			if (directive == EGRNavigationDirective::Tab)
			{
				return OnTab();
			}

			return EGREventRouting::NextHandler;
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			if (ppOutputArg) *ppOutputArg = nullptr;
			if (!interfaceId || *interfaceId == 0) return EGRQueryInterfaceResult::INVALID_ID;

			if (DoInterfaceNamesMatch(interfaceId, IGRWidgetVerticalList::InterfaceId()))
			{
				if (ppOutputArg)
				{
					*ppOutputArg = static_cast<IGRWidgetVerticalList*>(this);
				}

				return EGRQueryInterfaceResult::SUCCESS;
			}
			else if (DoInterfaceNamesMatch(interfaceId, IGRNavigator::InterfaceId()))
			{
				if (ppOutputArg)
				{
					*ppOutputArg = static_cast<IGRNavigator*>(this);
				}

				return EGRQueryInterfaceResult::SUCCESS;
			}

			return EGRQueryInterfaceResult::NOT_IMPLEMENTED;
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRVerticalList";
		}
	};

	struct GRVerticalListFactory : IGRWidgetFactory
	{
		bool enforcePositiveChildHeights;

		GRVerticalListFactory(bool _enforcePositiveChildHeights): enforcePositiveChildHeights(_enforcePositiveChildHeights)
		{

		}

		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			return *new GRVerticalList(panel, enforcePositiveChildHeights);
		}
	};
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetVerticalList::InterfaceId()
	{
		return "IGRWidgetVerticalList";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetVerticalList& CreateVerticalList(IGRWidget& parent, bool enforcePositiveChildHeights)
	{
		GRANON::GRVerticalListFactory factory(enforcePositiveChildHeights);
		auto& gr = parent.Panel().Root().GR();
		auto* list = Cast<IGRWidgetVerticalList>(gr.AddWidget(parent.Panel(), factory));
		return *list;
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.vertical.scroller.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <rococo.maths.h>
#include <rococo.ui.h>
#include <rococo.vkeys.h>

namespace Rococo::Windows
{
	// Translates wheelDelta changes from the mouse wheel into MoveLine deltas, and emits a boolean true, if the deltas should be interpreted as page deltas
	ROCOCO_API int32 WheelDeltaToScrollLines(int32 wheelDelta, bool& scrollByPage);
}

using namespace Rococo;
using namespace Rococo::Gui;

namespace ANON
{
	struct GRVerticalScroller : IGRWidgetVerticalScroller, IGRWidgetSupervisor, IGRWidgetLayout
	{
		IGRPanel& panel;
		IGRScrollerEvents& events;

		GuiRect sliderZone{ 0,0,0,0 };

		int32 sliderPosition = 0; // Number of pixels below the top of the slider bar that the slider is set at.
		int32 sliderHeight = 10; // Number of pixels from the top to the bottom of the slider button

		GRVerticalScroller(IGRPanel& owningPanel, IGRScrollerEvents& argEvents) : panel(owningPanel), events(argEvents)
		{
		}

		virtual ~GRVerticalScroller()
		{

		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		void Free() override
		{
			delete this;
		}

		void LayoutBeforeFit() override
		{

		}

		void LayoutBeforeExpand() override
		{


		}

		void LayoutAfterExpand() override
		{
			int vpadding = 1;
			auto spec = events.OnCalculateSliderRect(panel.Span().y - (2 * vpadding), *this);
			sliderHeight = spec.sliderSpanInPixels;
		}

		enum class EClick
		{
			None,
			Slider,
			Bar,
		} clickTarget = EClick::None;

		EClick ClassifyTarget(Vec2i pos)
		{
			GuiRect sliderRect = ComputeSliderRect();

			if (IsPointInRect(pos, sliderRect))
			{
				return EClick::Slider;
			}
			else if (IsPointInRect(pos, sliderZone))
			{
				return EClick::Bar;
			}
			else
			{
				return EClick::None;
			}
		}

		void MovePage(int delta) override
		{
			events.OnScrollPages(delta, *this);
		}

		void ActivateTarget(int y)
		{
			switch (clickTarget)
			{
			case EClick::Bar:
				{
					GuiRect sliderRect = ComputeSliderRect();
					if (y < sliderRect.top)
					{
						MovePage(-1);
					}
					else if (y > sliderRect.bottom)
					{
						MovePage(1);
					}
				}
				break;
			}
		}

		bool isDragging = false;
		int clickPosition = -1;
		int deltaClickPosition = 0;

		void BeginDrag(GRCursorEvent& ce)
		{
			isDragging = true;
			clickPosition = ce.position.y;
			panel.CaptureCursor();
		}

		int ComputeDraggedSliderPosition() const
		{
			return clamp(sliderPosition + deltaClickPosition, 0, Height(sliderZone) - sliderHeight);
		}

		EGREventRouting OnCursorClick(GRCursorEvent& ce) override
		{
			GuiRect sliderRect = ComputeSliderRect();

			if (ce.click.LeftButtonDown)
			{
				panel.FocusAndNotifyAncestors();
				clickTarget = ClassifyTarget(ce.position);
				if (clickTarget == EClick::Slider)
				{
					BeginDrag(ce);
				}
			}
			else if (ce.click.LeftButtonUp)
			{
				isDragging = false;

				panel.Root().ReleaseCursor();

				if (deltaClickPosition != 0)
				{
					sliderPosition = ComputeDraggedSliderPosition();
				}

				deltaClickPosition = 0;

				if (clickTarget == ClassifyTarget(ce.position))
				{
					ActivateTarget(ce.position.y);
				}
				clickTarget = EClick::None;

				GRWidgetEvent sliderReleased;
				sliderReleased.eventType = EGRWidgetEventType::SCROLLER_RELEASED;
				sliderReleased.isCppOnly = true;
				sliderReleased.iMetaData = sliderPosition;
				sliderReleased.sMetaData = nullptr;
				panel.NotifyAncestors(sliderReleased, *this);
			}
			else if (ce.click.MouseVWheel)
			{
				if (!ce.context.isShiftHeld)
				{
					bool scrollByPage = false;
					int32 delta = Rococo::Windows::WheelDeltaToScrollLines(ce.wheelDelta, OUT scrollByPage) * panel.Root().GR().Config().VerticalScrollerWheelScaling;
					if (scrollByPage)
					{
						events.OnScrollPages(delta, *this);
					}
					else
					{
						events.OnScrollLines(delta, *this);
					}
				}
				else
				{
					return EGREventRouting::NextHandler;
				}
			}

			return EGREventRouting::Terminate;
		}

		EGREventRouting OnCursorMove(GRCursorEvent& ce) override
		{
			if (isDragging)
			{
				int32 oldPosition = deltaClickPosition;
				deltaClickPosition = ce.position.y - clickPosition;
				
				if (oldPosition != deltaClickPosition)
				{
					events.OnScrollerNewPositionCalculated(ComputeDraggedSliderPosition(), *this);
				}
			}
			return EGREventRouting::Terminate;
		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		void RenderScrollerButton(IGRRenderContext& g, const GuiRect& rect, bool isUp)
		{
			GRWidgetRenderState rs(g.IsHovered(panel), IsPointInRect(g.CursorHoverPoint(), rect), panel.HasFocus() && IsPointInRect(g.CursorHoverPoint(), rect));

			RGBAb backColour = panel.GetColour(EGRSchemeColourSurface::SCROLLER_BUTTON_BACKGROUND, rs);
			g.DrawRect(rect, backColour);

			GuiRect triangleRect = { rect.left + 2, rect.top + 2, rect.right - 2, rect.bottom - 2 };

			RGBAb triangleColour = panel.GetColour(EGRSchemeColourSurface::SCROLLER_TRIANGLE_NORMAL, rs);
			g.DrawDirectionArrow(triangleRect, triangleColour, isUp ? 0.0_degrees : 180.0_degrees);

			RGBAb edge1Colour = panel.GetColour(EGRSchemeColourSurface::SCROLLER_BUTTON_TOP_LEFT, rs);
			RGBAb edge2Colour = panel.GetColour(EGRSchemeColourSurface::SCROLLER_BUTTON_BOTTOM_RIGHT, rs);
			g.DrawRectEdge(rect, edge1Colour, edge2Colour);
		}

		void RenderScrollerSlider(IGRRenderContext& g, const GuiRect& rect)
		{
			GRWidgetRenderState rs(g.IsHovered(panel), IsPointInRect(g.CursorHoverPoint(), rect), panel.HasFocus());

			RGBAb backColour = panel.GetColour(EGRSchemeColourSurface::SCROLLER_SLIDER_BACKGROUND, rs);
			g.DrawRect(rect, backColour);

			RGBAb edge1Colour = panel.GetColour(EGRSchemeColourSurface::SCROLLER_SLIDER_TOP_LEFT, rs);
			RGBAb edge2Colour = panel.GetColour(EGRSchemeColourSurface::SCROLLER_SLIDER_BOTTOM_RIGHT, rs);
			g.DrawRectEdge(rect, edge1Colour, edge2Colour);
		}

		GuiRect ComputeSliderRect() const
		{
			if (sliderHeight <= 0 || sliderHeight > Height(sliderZone) - 3)
			{
				return { 0,0,0,0 };
			}

			int32 dy = clamp(sliderPosition + deltaClickPosition, 0, Height(sliderZone) - sliderHeight);
			int32 y = sliderZone.top + 1 + dy;
			return { sliderZone.left + 1, y, sliderZone.right - 1, y + sliderHeight };
		}

		void Render(IGRRenderContext& g) override
		{
			auto rect = panel.AbsRect();

			GRWidgetRenderState rs(false, g.IsHovered(panel), false);

			RGBAb backColour = panel.GetColour(EGRSchemeColourSurface::SCROLLER_BAR_BACKGROUND, rs);
			g.DrawRect(rect, backColour);

			RGBAb edge1Colour = panel.GetColour(EGRSchemeColourSurface::SCROLLER_BAR_TOP_LEFT, rs);
			RGBAb edge2Colour = panel.GetColour(EGRSchemeColourSurface::SCROLLER_BAR_BOTTOM_RIGHT, rs);
			g.DrawRectEdge(rect, edge1Colour, edge2Colour);

			sliderZone.left = rect.left + 1;
			sliderZone.right = rect.right - 1;
			sliderZone.top = rect.top + 1;
			sliderZone.bottom = rect.bottom - 1;

			if (rs.value.intValue != 0)
			{
				g.DrawRectEdge(sliderZone, edge1Colour, edge2Colour);
			}

			GuiRect renderedSliderRect = ComputeSliderRect();
			renderedSliderRect.bottom = min(rect.bottom - 2, renderedSliderRect.bottom);
			
			RenderScrollerSlider(g, renderedSliderRect);
		}

		EGREventRouting OnChildEvent(GRWidgetEvent&, IGRWidget&) override
		{
			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{
		}

		void OnCursorLeave() override
		{
			clickTarget = EClick::None;
			clickPosition = -1;
			isDragging = false;
		}

		EGREventRouting OnKeyEvent(GRKeyEvent& keyEvent) override
		{
			switch (keyEvent.osKeyEvent.VKey)
			{
			case IO::VirtualKeys::VKCode_PGUP:
				if (!keyEvent.osKeyEvent.IsUp()) events.OnScrollPages(-1, *this);
				break;
			case IO::VirtualKeys::VKCode_PGDOWN:
				if (!keyEvent.osKeyEvent.IsUp()) events.OnScrollPages(1, *this);
				break;
			case IO::VirtualKeys::VKCode_UP:
				if (!keyEvent.osKeyEvent.IsUp()) events.OnScrollLines(-1, *this);
				break;
			case IO::VirtualKeys::VKCode_DOWN:
				if (!keyEvent.osKeyEvent.IsUp()) events.OnScrollLines(1, *this);
				break;
			case IO::VirtualKeys::VKCode_HOME:
				if (!keyEvent.osKeyEvent.IsUp()) events.OnScrollPages(-100, *this);
				break;
			case IO::VirtualKeys::VKCode_END:
				if (!keyEvent.osKeyEvent.IsUp()) events.OnScrollPages(100, *this);
				break;
			default:
				return EGREventRouting::NextHandler;
			}
			return EGREventRouting::Terminate;
		}

		enum { MAX_SCROLL_INT = 1 << 30 };

		GRScrollerMetrics GetMetrics() const override
		{
			GRScrollerMetrics m;
			m.SliderTopPosition = sliderPosition;
			m.SliderZoneSpan = Height(sliderZone);
			m.PixelRange = clamp(m.SliderZoneSpan - sliderHeight, 0, (int32) MAX_SCROLL_INT);
			return m;
		}

		void SetSliderPosition(int position) override
		{
			if (position < 0)
			{
				auto m = GetMetrics();
				this->sliderPosition = m.PixelRange;
			}

			if (position > MAX_SCROLL_INT)
			{
				RaiseError(panel, EGRErrorCode::InvalidArg, __ROCOCO_FUNCTION__, "Position was out of bounds");
				return;
			}
			this->sliderPosition = position;
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			auto result = Gui::QueryForParticularInterface<IGRWidgetLayout>(this, ppOutputArg, interfaceId);
			if (result == EGRQueryInterfaceResult::SUCCESS)
			{
				return result;
			}

			return Gui::QueryForParticularInterface<IGRWidgetVerticalScroller>(this, ppOutputArg, interfaceId);
		}

		IGRWidget& Widget() override
		{
			return *this;
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRVerticalScroller";
		}
	};

	struct VerticalScrollerFactory : IGRWidgetFactory
	{
		IGRScrollerEvents& events;

		VerticalScrollerFactory(IGRScrollerEvents& argEvents): events(argEvents)
		{

		}

		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			return *new GRVerticalScroller(panel, events);
		}
	};
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetVerticalScroller::InterfaceId()
	{
		return "IGRWidgetVerticalScroller";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetVerticalScroller& CreateVerticalScroller(IGRWidget& parent, IGRScrollerEvents& events)
	{
		ANON::VerticalScrollerFactory factory(events);

		auto& gr = parent.Panel().Root().GR();
		auto* scroller = Cast<IGRWidgetVerticalScroller>(gr.AddWidget(parent.Panel(), factory));
		return *scroller;
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.vertical.scroller.with.buttons.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <rococo.maths.h>

using namespace Rococo;
using namespace Rococo::Gui;

namespace ANON
{
	struct ScrollerButtonRenderer : IGRPanelRenderer
	{
		Degrees orientation;

		void PreRender(IGRPanel& panel, const GuiRect& absRect, IGRRenderContext& g) override
		{
			auto* button = Cast<IGRWidgetButton>(panel.Widget());

			GRWidgetRenderState rs{ !button->ButtonFlags().isRaised,  g.IsHovered(panel), panel.HasFocus()};

			RGBAb colour = panel.GetColour(EGRSchemeColourSurface::BUTTON, rs);

			if (orientation == 0)
			{
				// Up
				GuiRect bottomHalf = absRect;
				bottomHalf.top += Width(absRect) / 2;
				g.DrawRect(bottomHalf, colour);
			}
			else
			{
				// Down
				GuiRect topHalf = absRect;
				topHalf.bottom -= Width(absRect) / 2;
				g.DrawRect(topHalf, colour);
			}
		}

		void PostRender(IGRPanel& panel, const GuiRect& absRect, IGRRenderContext& g) override
		{
			GuiRect triangleRect;

			if (panel.RectStyle() == EGRRectStyle::SHARP)
			{
				triangleRect = { absRect.left + 3, absRect.top + 3, absRect.right - 3, absRect.bottom - 3 };
			}
			else
			{
				int R = panel.CornerRadius() / 2;

				if (orientation == 0)
				{
					triangleRect = { absRect.left + R, absRect.top + R, absRect.right - R, absRect.bottom - R };
				}
				else
				{
					triangleRect = { absRect.left + R, absRect.top + R, absRect.right - R, absRect.bottom - R };
				}
			}

			bool isHovered = g.IsHovered(panel);

			GRWidgetRenderState rs(false, isHovered, panel.HasFocus());

			RGBAb triangleColour = panel.GetColour(EGRSchemeColourSurface::SCROLLER_TRIANGLE_NORMAL, rs);
			g.DrawDirectionArrow(triangleRect, triangleColour, orientation);
		}

		bool IsReplacementForWidgetRendering(IGRPanel&) const override
		{
			return false;
		}
	};

	struct GRVerticalScrollerWithButtons : IGRWidgetVerticalScrollerWithButtons, IGRWidgetSupervisor, IGRWidgetLayout
	{
		IGRPanel& panel;
		IGRWidgetButton* topButton = nullptr;
		IGRWidgetButton* bottomButton = nullptr;
		IGRWidgetVerticalScroller* scroller = nullptr;
		IGRScrollerEvents& events;

		ScrollerButtonRenderer upRenderer;
		ScrollerButtonRenderer downRenderer;

		GRVerticalScrollerWithButtons(IGRPanel& owningPanel, IGRScrollerEvents& argEvents) : panel(owningPanel), events(argEvents)
		{
			upRenderer.orientation = 0_degrees;
			downRenderer.orientation = 180_degrees;
		}

		virtual ~GRVerticalScrollerWithButtons()
		{

		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		void PostConstruct()
		{
			panel.SetLayoutDirection(ELayoutDirection::None);
			topButton = &CreateButton(*this);
			bottomButton = &CreateButton(*this);
			scroller = &CreateVerticalScroller(*this, events);
			scroller->Widget().Panel().SetExpandToParentHorizontally();
			topButton->Widget().Panel().SetPanelRenderer(&upRenderer);
			topButton->SetEventPolicy(EGREventPolicy::NotifyAncestors);
			bottomButton->Widget().Panel().SetPanelRenderer(&downRenderer);
			bottomButton->SetEventPolicy(EGREventPolicy::NotifyAncestors);
		}

		void Free() override
		{
			delete this;
		}

		IGRWidgetButton& BottomButton() override
		{
			return *bottomButton;
		}

		IGRWidgetVerticalScroller& Scroller() override
		{
			return *scroller;
		}

		IGRWidgetButton& TopButton() override
		{
			return *topButton;
		}

		void LayoutBeforeFit() override
		{
		}

		void LayoutBeforeExpand() override
		{
			

		}

		void InitButtonStyle(IGRWidgetButton& button)
		{
			int buttonSpan = panel.Span().x;
			button.Panel().
				SetConstantSpan(Vec2i{ buttonSpan, buttonSpan }).
				SetCornerRadius(panel.CornerRadius()).
				SetRectStyle(panel.RectStyle()).
				Set(EGRSchemeColourSurface::BUTTON_EDGE_TOP_LEFT, RGBAb(0, 0, 0, 0), EGRColourSpec::ForAllRenderStates).
				Set(EGRSchemeColourSurface::BUTTON_EDGE_BOTTOM_RIGHT, RGBAb(0, 0, 0, 0), EGRColourSpec::ForAllRenderStates);
			button.Panel().Remove(EGRPanelFlags::AcceptsFocus);
		}

		void LayoutAfterExpand() override
		{
			InitButtonStyle(*topButton);
			InitButtonStyle(*bottomButton);

			int buttonSpan = panel.Span().x;

			scroller->Widget().Panel().SetConstantHeight(panel.Span().y - 2 * buttonSpan).SetParentOffset({ 0, buttonSpan });

			bottomButton->Widget().Panel().SetParentOffset({ 0, panel.Span().y - buttonSpan });

			CopyAllColours(panel, panel, EGRSchemeColourSurface::SCROLLER_BUTTON_BACKGROUND, EGRSchemeColourSurface::BUTTON);
			CopyAllColours(panel, panel, EGRSchemeColourSurface::SCROLLER_BUTTON_TOP_LEFT, EGRSchemeColourSurface::BUTTON_EDGE_TOP_LEFT);
			CopyAllColours(panel, panel, EGRSchemeColourSurface::SCROLLER_BUTTON_BOTTOM_RIGHT, EGRSchemeColourSurface::BUTTON_EDGE_BOTTOM_RIGHT);
		}

		EGREventRouting OnCursorClick(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnCursorMove(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		void Render(IGRRenderContext&) override
		{
		}

		EGREventRouting OnChildEvent(GRWidgetEvent& widgetEvent, IGRWidget& sourceWidget) override
		{
			if (widgetEvent.eventType == EGRWidgetEventType::BUTTON_CLICK)
			{
				if (&sourceWidget == &topButton->Widget())
				{
					events.OnScrollLines(-1, *this->scroller);
					// The top button was clicked
					return EGREventRouting::Terminate;
				}
				else if (&sourceWidget == &bottomButton->Widget())
				{
					events.OnScrollLines(1, *this->scroller);
					// The bottom button was clicked
					return EGREventRouting::Terminate;
				}
			}
			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{
		}

		void OnCursorLeave() override
		{
		}

		EGREventRouting OnKeyEvent(GRKeyEvent&) override
		{
			return EGREventRouting::NextHandler;
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			auto result = Gui::QueryForParticularInterface<IGRWidgetLayout>(this, ppOutputArg, interfaceId);
			if (result == EGRQueryInterfaceResult::SUCCESS)
			{
				return result;
			}

			return Gui::QueryForParticularInterface<IGRWidgetVerticalScrollerWithButtons>(this, ppOutputArg, interfaceId);
		}

		IGRWidget& Widget() override
		{
			return *this;
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRVerticalScrollerWithButtons";
		}
	};

	struct VerticalScrollerWithButtonsFactory : IGRWidgetFactory
	{
		IGRScrollerEvents& events;
		VerticalScrollerWithButtonsFactory(IGRScrollerEvents& argEvents): events(argEvents)
		{

		}

		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			return *new GRVerticalScrollerWithButtons(panel, events);
		}
	};
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetVerticalScrollerWithButtons::InterfaceId()
	{
		return "IGRWidgetVerticalScrollerWithButtons";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetVerticalScrollerWithButtons& CreateVerticalScrollerWithButtons(IGRWidget& parent, IGRScrollerEvents& events)
	{
		ANON::VerticalScrollerWithButtonsFactory factory(events);

		auto& gr = parent.Panel().Root().GR();
		auto* scroller = Cast<IGRWidgetVerticalScrollerWithButtons>(gr.AddWidget(parent.Panel(), factory));
		auto* scrollerClass = static_cast<ANON::GRVerticalScrollerWithButtons*>(scroller);
		scrollerClass->PostConstruct();
		return *scroller;
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.gui.retained/rococo.gr.viewport.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.gui.retained.ex.h>
#include <rococo.maths.i32.h>
#include <stdio.h>

using namespace Rococo;
using namespace Rococo::Gui;

namespace ANON
{
	enum { scrollbarWidth = 16 };

	struct GRViewportWidget : IGRWidgetViewport, IGRWidgetSupervisor, IGRScrollerEvents, IGRFocusNotifier, IGRWidgetLayout
	{
		IGRPanel& panel;
		IGRWidgetDivision* clipArea = nullptr; // Represents the rectangle to the left of the scroller
		IGRWidgetDivision* clientOffsetArea = nullptr; // Represents the scrolled data inside the clipArea
		IGRWidgetVerticalScrollerWithButtons* vscroller = nullptr;
		int clientOffsetAreaParentOffset = 0;

		GRViewportWidget(IGRPanel& owningPanel) : panel(owningPanel)
		{
			owningPanel.SetLayoutDirection(ELayoutDirection::None);
		}

		virtual ~GRViewportWidget()
		{

		}

		void OnTick(float dt) override
		{
			UNUSED(dt);
		}

		void PostConstruct()
		{
			clipArea = &CreateDivision(*this);
			clipArea->Panel().SetExpandToParentVertically();
			clipArea->Panel().SetExpandToParentHorizontally();
			clipArea->Panel().SetLayoutDirection(ELayoutDirection::None);
			clientOffsetArea = &CreateDivision(clipArea->Widget());
			clientOffsetArea->Panel().SetExpandToParentVertically();
			clientOffsetArea->Panel().SetExpandToParentHorizontally();
			clientOffsetArea->Panel().SetClippingPanel(&clipArea->Panel());
			vscroller = &CreateVerticalScrollerWithButtons(*this, *this);
			vscroller->Widget().Panel().SetExpandToParentVertically();
			vscroller->Widget().Panel().SetConstantWidth(scrollbarWidth);
		}

		void Free() override
		{
			delete this;
		}

		void LayoutBeforeFit() override
		{
			if (syncDomainToChildren)
			{
				auto& clientPanel = ClientArea().Panel();

				nextDomain = clientPanel.Padding().top;

				int nChildren = clientPanel.EnumerateChildren(nullptr);

				for (int i = 0; i < nChildren; i++)
				{
					auto* child = clientPanel.GetChild(i);
					nextDomain += child->Span().y;
				}

				if (nChildren > 1)
				{
					nextDomain += (nChildren - 1) * clientPanel.ChildPadding();
				}

				nextDomain += clientPanel.Padding().bottom;
			}

			SetDomainHeight(nextDomain);
		}

		void LayoutBeforeExpand() override
		{

		}

		void LayoutAfterExpand() override
		{
			auto span = panel.Span();

			int trueScrollBarWidth = scrollbarWidth;

			if (nextDomain <= panel.Span().y)
			{
				vscroller->Panel().SetCollapsed(true);
				trueScrollBarWidth = 0;
				ClientArea().Panel().SetRectStyle(notScrollableRectStyle);
				panel.SetRectStyle(notScrollableRectStyle);
			}
			else
			{
				vscroller->Panel().SetCollapsed(false);
				ClientArea().Panel().SetRectStyle(scrollableRectStyle);
				panel.SetRectStyle(scrollableRectStyle);
			}

			Vec2i roundedOffset = { 0,0 };

			Vec2i clipSpan{ span.x - trueScrollBarWidth, span.y };

			if (panel.RectStyle() != EGRRectStyle::SHARP)
			{
				roundedOffset = { panel.CornerRadius(), 0 };
				trueScrollBarWidth = 2 * roundedOffset.x;

				clipSpan.x -= trueScrollBarWidth;
			}

			auto& clipPanel = clipArea->Panel();
			clipPanel.SetConstantWidth(clipSpan.x);
			clipPanel.SetConstantHeight(clipSpan.y);
			clipPanel.SetParentOffset({roundedOffset.x,0});
			
			Vec2i clientOffsetSpan{ clipSpan.x, max(lastKnownDomainHeight, clipSpan.y) };

			auto& coaPanel = clientOffsetArea->Panel();
			coaPanel.SetConstantWidth(clientOffsetSpan.x);
			coaPanel.SetConstantHeight(clientOffsetSpan.y);
			coaPanel.SetParentOffset({0, -clientOffsetAreaParentOffset });
			
			auto& vswp = vscroller->Widget().Panel();
			vswp.SetConstantWidth(trueScrollBarWidth);
			vswp.SetConstantHeight(clipSpan.y);

			vswp.SetCornerRadius(panel.CornerRadius());
			vswp.SetRectStyle(panel.RectStyle());

			int scrollerX = panel.Span().x - trueScrollBarWidth;
			vswp.SetParentOffset({ scrollerX, 1});
		}

		GRSliderSpec OnCalculateSliderRect(int32 scrollerSpan, IGRWidgetScroller&) override
		{
			double sliderSpanToScrollerSpan = scrollerSpan / (double)lastKnownDomainHeight;

			GRSliderSpec spec;
			spec.sliderSpanInPixels = (int) (clipArea->Panel().Span().y * sliderSpanToScrollerSpan);
			return spec;
		}

		// Check the interface method IGRWidgetViewport::SetMovePageScale(...) for documentation on this variable
		double pageDeltaScale = 0.75;

		// Check the interface method IGRWidgetViewport::SetLineDeltaPixels(...) for documentation on this variable
		int lineDeltaPixels = 10;

		void SetLineDeltaPixels(int lineDeltaPixels) override
		{
			this->lineDeltaPixels = clamp(lineDeltaPixels, 1, 1000'000);
		}

		int GetOffset() const override
		{
			return clientOffsetAreaParentOffset;
		}

		void SetOffset(int offset, bool fromStart) override
		{
			int span = lastKnownDomainHeight - Height(clipArea->Panel().AbsRect());

			if (span < 0)
			{
				clientOffsetAreaParentOffset = 0;
				return;
			}

			if (offset < 0)
			{
				clientOffsetAreaParentOffset = max(0, span);
				return;
			}

			if (fromStart)
			{
				clientOffsetAreaParentOffset = offset;
			}
			else
			{
				clientOffsetAreaParentOffset = span - offset;
			}

			clientOffsetAreaParentOffset = clamp(clientOffsetAreaParentOffset, 0, span);
		}

		EGRRectStyle notScrollableRectStyle = EGRRectStyle::SHARP;

		void SetClientAreaRectStyleWhenNotScrollable(EGRRectStyle style) override
		{
			notScrollableRectStyle = style;
		}

		EGRRectStyle scrollableRectStyle = EGRRectStyle::SHARP;

		void SetClientAreaRectStyleWhenScrollable(EGRRectStyle style) override
		{
			scrollableRectStyle = style;
		}

		bool syncDomainToChildren = false;

		void SyncDomainToChildren()
		{
			syncDomainToChildren = true;
		}

		void SetMovePageScale(double scaleFactor) override
		{
			pageDeltaScale = clamp(scaleFactor, 0.0, 2.0);
		}

		void ScrollDeltaPixels(int deltaPixels, IGRWidgetScroller& scroller)
		{
			// panel.Root().GR().SetFocus(-1);

			int clipAreaHeight = clipArea->Panel().Span().y;

			GRScrollerMetrics m = scroller.GetMetrics();
			if (m.PixelRange > 0 && lastKnownDomainHeight > clipAreaHeight)
			{
				double scale = m.PixelRange / (double)(lastKnownDomainHeight - clipAreaHeight);
				int32 newOffset = deltaPixels + clientOffsetAreaParentOffset;

				if (lineDeltaPixels > 0 && lineDeltaPixels < deltaPixels)
				{
					newOffset = (newOffset / lineDeltaPixels) * lineDeltaPixels;
				}

				clientOffsetAreaParentOffset = clamp(0, newOffset, lastKnownDomainHeight - clipAreaHeight);

				int newPosition = (int)(newOffset * scale);
				newPosition = clamp(newPosition, 0, m.PixelRange);

				scroller.SetSliderPosition(newPosition);
			}
		}

		void OnScrollLines(int delta, IGRWidgetScroller& scroller)
		{
			if (lineDeltaPixels <= 0) return;
			int32 deltaPixels = delta * lineDeltaPixels;
			ScrollDeltaPixels(deltaPixels, scroller);
		}

		void OnScrollPages(int delta, IGRWidgetScroller& scroller) override
		{
			int clipAreaHeight = clipArea->Panel().Span().y;
			int deltaPixels = (int)(pageDeltaScale * delta * clipAreaHeight);
			ScrollDeltaPixels(deltaPixels, scroller);
		}

		void AdjustClientOffsetAreaAccordingToNewPosition(int newPosition, const GRScrollerMetrics m)
		{
			int clipAreaHeight = clipArea->Panel().Span().y;

			if (m.PixelRange == 0)
			{
				clientOffsetAreaParentOffset = 0;
			}
			else if (m.PixelRange > 0 && lastKnownDomainHeight > clipAreaHeight)
			{
				double cursor = clamp(newPosition / (double)(m.PixelRange), 0.0, 1.0);
				clientOffsetAreaParentOffset = (int)(cursor * (lastKnownDomainHeight - clipAreaHeight));
			}
		}

		void OnScrollerNewPositionCalculated(int32 newPosition, IGRWidgetScroller& scroller) override
		{
			GRScrollerMetrics m = scroller.GetMetrics();
			AdjustClientOffsetAreaAccordingToNewPosition(newPosition, m);
		}

		EGREventRouting OnCursorClick(GRCursorEvent& ce) override
		{
			if (ce.wheelDelta != 0)
			{
				return vscroller->Scroller().Widget().Supervisor().OnCursorClick(ce);
			}

			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnCursorMove(GRCursorEvent& ce) override
		{
			UNUSED(ce);
			return EGREventRouting::NextHandler;
		}

		void OnCursorEnter() override
		{

		}

		void OnCursorLeave() override
		{

		}

		void ScrollIntoView(const GuiRect& rect)
		{
			auto clipRect = clipArea->Panel().AbsRect();

			int32 dOffset = 0;
			if (rect.top < clipArea->Panel().AbsRect().top)
			{
				dOffset = rect.top - clipArea->Panel().AbsRect().top;
			}
			else if (rect.top >= clipArea->Panel().AbsRect().bottom)
			{
				if (Height(rect) < Height(clipRect))
				{
					dOffset = rect.bottom - clipArea->Panel().AbsRect().bottom;
				}
				else
				{
					dOffset = rect.top - clipArea->Panel().AbsRect().bottom;
				}
			}
			else if (rect.bottom > clipArea->Panel().AbsRect().bottom)
			{
				if (Height(rect) < Height(clipRect))
				{
					dOffset = rect.bottom - clipArea->Panel().AbsRect().bottom;
				}
			}
			else
			{
				return;
			}

			clientOffsetAreaParentOffset = - clientOffsetArea->Panel().ParentOffset().y + dOffset;

			GRScrollerMetrics m = vscroller->Scroller().GetMetrics();
			if (m.PixelRange > 0 && lastKnownDomainHeight > m.SliderZoneSpan)
			{
				double sliderPixelOffset = (double) (m.PixelRange * clientOffsetAreaParentOffset) / (double) (lastKnownDomainHeight - Span(clipArea->Panel().AbsRect()).y);
				vscroller->Scroller().SetSliderPosition(clamp((int32)sliderPixelOffset, 0, m.PixelRange));
			}
		}

		void PropagateFocusChangesToParent(bool value) override
		{
			propagateFocusChangesToParent = value;
		}

		bool propagateFocusChangesToParent = true;

		EFlowLogic OnDeepChildFocusSet(int64 panelId) override
		{
			auto* w = panel.Root().GR().FindWidget(panelId);
			if (!w)
			{
				return EFlowLogic::BREAK;
			}

			if (IsCandidateDescendantOfParent(clientOffsetArea->Panel(), w->Panel()))
			{
				auto rect = w->Panel().AbsRect();
				ScrollIntoView(rect);
			}

			return propagateFocusChangesToParent ? EFlowLogic::CONTINUE : EFlowLogic::BREAK;
		}

		IGRPanel& Panel() override
		{
			return panel;
		}

		IGRWidgetDivision& ClientArea() override
		{
			return *clientOffsetArea;
		}

		IGRWidgetVerticalScrollerWithButtons& VScroller() override
		{
			return *vscroller;
		}

		Vec2i lastSpan{ 0,0 };

		void Render(IGRRenderContext& g) override
		{
			Vec2i newSpan = Span(panel.AbsRect());
			if (newSpan != lastSpan)
			{
				lastSpan = newSpan;
				clientOffsetAreaParentOffset = 0;
			}

			DrawPanelBackgroundEx(panel, g, EGRSchemeColourSurface::BACKGROUND, EGRSchemeColourSurface::CONTAINER_TOP_LEFT, EGRSchemeColourSurface::CONTAINER_BOTTOM_RIGHT);
		}

		int nextDomain = 0;

		EGREventRouting OnChildEvent(GRWidgetEvent& ev, IGRWidget&) override
		{
			switch (ev.eventType)
			{
			case EGRWidgetEventType::UPDATED_CLIENTAREA_HEIGHT:
				nextDomain = (int) ev.iMetaData;
				return EGREventRouting::Terminate;
			}
			return EGREventRouting::NextHandler;
		}

		EGREventRouting OnKeyEvent(GRKeyEvent&) override
		{
			return EGREventRouting::NextHandler;
		}

		EGRQueryInterfaceResult QueryInterface(IGRBase** ppOutputArg, cstr interfaceId) override
		{
			if (ppOutputArg) *ppOutputArg = nullptr;
			if (!interfaceId || *interfaceId == 0) return EGRQueryInterfaceResult::INVALID_ID;

			auto result = Gui::QueryForParticularInterface<IGRWidgetLayout>(this, ppOutputArg, interfaceId);
			if (result == EGRQueryInterfaceResult::SUCCESS)
			{
				return result;
			}

			if (DoInterfaceNamesMatch(interfaceId, IGRWidgetViewport::InterfaceId()))
			{
				if (ppOutputArg)
				{
					*ppOutputArg = static_cast<IGRWidgetViewport*>(this);
				}

				return EGRQueryInterfaceResult::SUCCESS;
			}
			else if (DoInterfaceNamesMatch(interfaceId, IGRFocusNotifier::InterfaceId()))
			{
				if (ppOutputArg)
				{
					*ppOutputArg = static_cast<IGRFocusNotifier*>(this);
				}

				return EGRQueryInterfaceResult::SUCCESS;
			}

			return EGRQueryInterfaceResult::NOT_IMPLEMENTED;
		}

		int lastKnownDomainHeight = 0;

		void SetDomainHeight(int32 heightInPixels) override
		{
			if (lastKnownDomainHeight != heightInPixels)
			{
				nextDomain = heightInPixels;
				lastKnownDomainHeight = heightInPixels;
				clientOffsetArea->Panel().SetConstantHeight(max(1, heightInPixels));
			}
		}

		IGRWidget& Widget() override
		{
			return *this;
		}

		cstr GetImplementationTypeName() const override
		{
			return "GRViewportWidget";
		}
	};

	struct : IGRWidgetFactory
	{
		IGRWidget& CreateWidget(IGRPanel& panel)
		{
			auto* instance = new GRViewportWidget(panel);
			instance->PostConstruct();
			return *instance;
		}
	} s_ViewportWidgetFactory;
}

namespace Rococo::Gui
{
	ROCOCO_GUI_RETAINED_API cstr IGRWidgetViewport::InterfaceId()
	{
		return "IGRViewportWidget";
	}

	ROCOCO_GUI_RETAINED_API IGRWidgetViewport& CreateViewportWidget(IGRWidget& parent)
	{
		auto& gr = parent.Panel().Root().GR();
		auto* scroller = Cast<IGRWidgetViewport>(gr.AddWidget(parent.Panel(), ANON::s_ViewportWidgetFactory));
		return *scroller;
	}
}
#ifdef _WIN32
# pragma warning(default: 4458)
# pragma warning(default: 4265)
#else
# pragma clang diagnostic pop
#endif
