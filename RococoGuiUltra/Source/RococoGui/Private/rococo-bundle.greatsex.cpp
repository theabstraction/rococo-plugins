// Copyright (c) 2025 Mark Anthony Taylor. All rights reserved. Email: mark.anthony.taylor@gmail.com.
// Bundle generated by Build.Rococo.GUI.cs on Oct 2025 UTC
#include "rococo.UE5.cpp.h"
// Origin: D:/work/rococo/source/rococo/rococo.great.sex/great.sex.colour.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.great.sex.h>
#include <sexy.types.h>
#include <Sexy.S-Parser.h>
#include <rococo.sexml.h>
#include <new>
#include <rococo.hashtable.h>
#include <rococo.functional.h>
#include <rococo.strings.h>
#include <rococo.formatting.h>

using namespace Rococo::Gui;
using namespace Rococo::Sex;
using namespace Rococo::Sex::SEXML;
using namespace Rococo::Strings;

namespace Rococo::GreatSex
{
	RGBAb GetColour(const Rococo::Sex::SEXML::ISEXMLDirective& colourDirective);

	uint8 GetColourUByteValue(cstr value, cr_sex S)
	{
		Formatting::TryParseResult<int32> iValue = Formatting::TryParseInt32FromDecimalStringSkippingCetera(value);
		if (iValue.code != Formatting::ETryParseResultCode::Success)
		{
			Throw(S, "RGBAb colour components are decimal integers 0 to 255 inclusive");
		}

		if (iValue.Value < 0 || iValue.Value > 255)
		{
			Throw(S, "Domain of a RGBAb colour component is 0 to 255 inclusive");
		}
		return (uint8)iValue.Value;
	}

	struct ColourFactory : ISEXMLWidgetFactorySupervisor
	{
		ISEXMLColourSchemeBuilder& builder;

		ColourFactory(ISEXMLColourSchemeBuilder& _builder): builder(_builder)
		{

		}

		virtual ~ColourFactory()
		{

		}

		void Free() override
		{
			delete this;
		}

		bool IsValidFrom(const Rococo::Sex::SEXML::ISEXMLDirective& widgetDefinition) const override
		{
			return widgetDefinition.Parent() == nullptr;
		}

		void OnColourSpec(cstr id, const Rococo::Sex::SEXML::ISEXMLDirective& spec)
		{
			auto aFor = spec.FindAttributeByName("For");
			if (!aFor)
			{
				Throw(spec.S(), "Expecting attribute For");
			}

			RGBAb colour;
			GRWidgetRenderState rs(false, false, false);

			auto& renderStateValue = AsStringList(aFor->Value());
			for (size_t i = 0; i < renderStateValue.NumberOfElements(); i++)
			{
				cstr rsString = renderStateValue[i];
				if (Eq(rsString, "pressed") || Eq(rsString, "p"))
				{
					rs.value.bitValues.pressed = 1;
				}
				else if (Eq(rsString, "hovered") || Eq(rsString, "h"))
				{
					rs.value.bitValues.hovered = 1;
				}
				else if (Eq(rsString, "focused") || Eq(rsString, "f"))
				{
					rs.value.bitValues.focused = 1;
				}
				else if (Eq(rsString, "default") || Eq(rsString, "d"))
				{
				}
				else
				{
					Throw(aFor->S()[(int)i + 2], "Expecting one of pressed, hovered, focused, default, p, h, f, d.");
				}
			}

			colour = GetColour(spec);

			builder.AddColour(id, colour, rs);
		}

		void OnUniformColourSpec(cstr id, const ISEXMLAttribute& uniformSpec)
		{
			RGBAb colour;
			auto& rgbaList = AsStringList(uniformSpec.Value());
			if (rgbaList.NumberOfElements() != 3 && rgbaList.NumberOfElements() != 4)
			{
				Throw(uniformSpec.S(), "Expecting 3 or 4 elements, each of which is 0-255, representing red, green, blue and (optionally) alpha components in that order.");
			}

			colour.red = GetColourUByteValue(rgbaList[0], uniformSpec.S()[2]);
			colour.green = GetColourUByteValue(rgbaList[1], uniformSpec.S()[3]);
			colour.blue = GetColourUByteValue(rgbaList[2], uniformSpec.S()[4]);	

			if (rgbaList.NumberOfElements() == 3)
			{
				colour.alpha = 255;
			}
			else
			{
				colour.alpha = GetColourUByteValue(rgbaList[3], uniformSpec.S()[5]);
			}

			GRWidgetRenderState::ForEachPermutation([this, id, colour](GRWidgetRenderState rs)
				{
					builder.AddColour(id, colour, rs);
				}
			);
		}

		void Generate(IGreatSexGenerator& generator, const Rococo::Sex::SEXML::ISEXMLDirective& colourDirective, Rococo::Gui::IGRWidget&) override
		{
			UNUSED(generator);

			if (colourDirective.Parent() != nullptr)
			{
				Throw(colourDirective.S(), "Colour directives must occur as top-level directives, never children of other directives");
			}

			auto aId = colourDirective.FindAttributeByName("Id");

			if (aId == nullptr)
			{
				Throw(colourDirective.S(), "Expecting attribute Id");
			}

			auto& sID = AsString(aId->Value());
			cstr id = sID.c_str();

			auto aUniformSpec = colourDirective.FindAttributeByName("Uniform.RGBAb");

			if (aUniformSpec != nullptr)
			{
				OnUniformColourSpec(id, *aUniformSpec);
			}

			for (int j = 0; j < colourDirective.NumberOfChildren(); j++)
			{
				auto& directive = colourDirective[j];
				if (Eq(directive.FQName(), "Spec"))
				{
					OnColourSpec(id, directive);
				}
				else
				{
					Throw(directive.S(), "Unknown directive, expecting Spec");
				}
			}
		}
	};

	ROCOCO_GREAT_SEX_API ISEXMLWidgetFactorySupervisor* CreateColourHandler(ISEXMLColourSchemeBuilder& builder)
	{
		return new ColourFactory(builder);
	}
}

// Origin: D:/work/rococo/source/rococo/rococo.great.sex/great.sex.scheme.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.great.sex.h>
#include <sexy.types.h>
#include <Sexy.S-Parser.h>
#include <rococo.sexml.h>
#include <new>
#include <rococo.hashtable.h>
#include <rococo.functional.h>
#include <rococo.strings.h>

using namespace Rococo::Gui;
using namespace Rococo::Sex;
using namespace Rococo::Sex::SEXML;
using namespace Rococo::Strings;

namespace Rococo::GreatSex
{
	uint8 GetUByteValue(const Rococo::Sex::SEXML::ISEXMLDirective& directive, cstr attributeName)
	{
		int value = SEXML::AsAtomicInt32(directive[attributeName]);
		if (value < 0 || value > 255)
		{
			Throw(directive.S(), "Domain of %s is [0,255]", attributeName);
		}
		return (uint8)value;
	}

	RGBAb GetColour(const Rococo::Sex::SEXML::ISEXMLDirective& colourDirective)
	{
		uint8 red = GetUByteValue(colourDirective, "Red");
		uint8 green = GetUByteValue(colourDirective, "Green");
		uint8 blue = GetUByteValue(colourDirective, "Blue");
		uint8 alpha = GetUByteValue(colourDirective, "Alpha");
		return RGBAb(red, green, blue, alpha);
	}


	bool ApplyColourFromDirective(cstr colourName, EGRSchemeColourSurface surface, Gui::GRWidgetRenderState state, Rococo::Gui::IGRWidget& widget, const Rococo::Sex::SEXML::ISEXMLDirective& schemeDirective)
	{
		size_t startIndex = 0;
		auto* colourDirective = schemeDirective.FindFirstChild(REF startIndex, colourName);
		if (colourDirective)
		{
			RGBAb colour = GetColour(*colourDirective);
			widget.Panel().Set(surface, colour, state);
			return true;
		}

		return false;
	}

	const ColourDirectiveBind colourDirectiveBindings[] =
	{
		{"Colour.Background", EGRSchemeColourSurface::BACKGROUND },
		{"Colour.Button", EGRSchemeColourSurface::BUTTON },
		{"Colour.Button.Edge.Top.Left", EGRSchemeColourSurface::BUTTON_EDGE_TOP_LEFT },
		{"Colour.Button.Edge.Bottom.Right", EGRSchemeColourSurface::BUTTON_EDGE_BOTTOM_RIGHT },
		{"Colour.Button.Image.Fog", EGRSchemeColourSurface::BUTTON_IMAGE_FOG },
		{"Colour.Button.Shadow", EGRSchemeColourSurface::BUTTON_SHADOW },
		{"Colour.Button.Text", EGRSchemeColourSurface::BUTTON_TEXT },

		{"Colour.Menu.Button", EGRSchemeColourSurface::MENU_BUTTON },
		{"Colour.Menu.Button.Edge.Top.Left", EGRSchemeColourSurface::MENU_BUTTON_EDGE_TOP_LEFT },
		{"Colour.Menu.Button.Edge.Bottom.Right", EGRSchemeColourSurface::MENU_BUTTON_EDGE_BOTTOM_RIGHT },
		{"Colour.Menu.Button.Edge.Bottom.Right", EGRSchemeColourSurface::MENU_BUTTON_EDGE_BOTTOM_RIGHT },

		{"Colour.Container.Background", EGRSchemeColourSurface::CONTAINER_BACKGROUND },
		{"Colour.Container.Top.Left", EGRSchemeColourSurface::CONTAINER_TOP_LEFT },
		{"Colour.Container.Bottom.Right", EGRSchemeColourSurface::CONTAINER_BOTTOM_RIGHT },

		{"Colour.Scroller.Button.Background", EGRSchemeColourSurface::SCROLLER_BUTTON_BACKGROUND },
		{"Colour.Scroller.Button.Top.Left", EGRSchemeColourSurface::SCROLLER_BUTTON_TOP_LEFT },
		{"Colour.Scroller.Button.Bottom.Right", EGRSchemeColourSurface::SCROLLER_BUTTON_BOTTOM_RIGHT },

		{"Colour.Scroller.Bar.Background", EGRSchemeColourSurface::SCROLLER_BAR_BACKGROUND },
		{"Colour.Scroller.Bar.Top.Left", EGRSchemeColourSurface::SCROLLER_BAR_TOP_LEFT },
		{"Colour.Scroller.Bar.Bottom.Right", EGRSchemeColourSurface::SCROLLER_BAR_BOTTOM_RIGHT },

		{"Colour.Scroller.Slider.Background", EGRSchemeColourSurface::SCROLLER_SLIDER_BACKGROUND },
		{"Colour.Scroller.Slider.Top.Left", EGRSchemeColourSurface::SCROLLER_SLIDER_TOP_LEFT },
		{"Colour.Scroller.Slider.Bottom.Right", EGRSchemeColourSurface::SCROLLER_SLIDER_BOTTOM_RIGHT },

		{"Colour.Editor", EGRSchemeColourSurface::EDITOR },
		{"Colour.Text", EGRSchemeColourSurface::TEXT },
		{"Colour.Focus", EGRSchemeColourSurface::FOCUS_RECTANGLE },
		{"Colour.EditText", EGRSchemeColourSurface::EDIT_TEXT },
		{"Colour.Label", EGRSchemeColourSurface::LABEL_BACKGROUND },
		{"Colour.Label.Shadow", EGRSchemeColourSurface::LABEL_SHADOW },

		{"Colour.Splitter.Background", EGRSchemeColourSurface::SPLITTER_BACKGROUND },
		{"Colour.Splitter.Edge", EGRSchemeColourSurface::SPLITTER_EDGE },

		{"Colour.Carousel.Text", EGRSchemeColourSurface::CAROUSEL_TEXT },
		{"Colour.Carousel.Background", EGRSchemeColourSurface::CAROUSEL_BACKGROUND },
		{"Colour.Carousel.Top.Left", EGRSchemeColourSurface::CAROUSEL_TOP_LEFT },
		{"Colour.Carousel.Bottom.Right", EGRSchemeColourSurface::CAROUSEL_BOTTOM_RIGHT },

		{"Colour.GameOption.Background", EGRSchemeColourSurface::GAME_OPTION_BACKGROUND },
		{"Colour.GameOption.Disabled.Background", EGRSchemeColourSurface::GAME_OPTION_DISABLED_BACKGROUND },
		{"Colour.GameOption.Disabled.Text", EGRSchemeColourSurface::GAME_OPTION_DISABLED_TEXT },

		{"Colour.GameOption.Top.Left", EGRSchemeColourSurface::GAME_OPTION_TOP_LEFT },
		{"Colour.GameOption.Bottom.Right", EGRSchemeColourSurface::GAME_OPTION_BOTTOM_RIGHT },
		{"Colour.GameOption.ChildSpacer", EGRSchemeColourSurface::GAME_OPTION_CHILD_SPACER},
		{"Colour.Carousel.DropDown", EGRSchemeColourSurface::CAROUSEL_DROP_DOWN_BACKGROUND},
		{"Colour.Carousel.DropDown.Text", EGRSchemeColourSurface::CAROUSEL_DROP_DOWN_TEXT},
		{"Colour.Portrait.Band", EGRSchemeColourSurface::PORTRAIT_BAND_COLOUR },

		{"Colour.Slider.Guage", EGRSchemeColourSurface::SLIDER_GUAGE },
		{"Colour.Slider",		EGRSchemeColourSurface::SLIDER_BACKGROUND },
		{"Colour.Slider.Slot",	EGRSchemeColourSurface::SLIDER_SLOT_BACKGROUND },
		{"Colour.Slider.Slot.Edge.1", EGRSchemeColourSurface::SLIDER_SLOT_EDGE_1 },
		{"Colour.Slider.Slot.Edge.2", EGRSchemeColourSurface::SLIDER_SLOT_EDGE_2 },
		{"Colour.Occlusion.Surface", EGRSchemeColourSurface::OCCLUSION_SURFACE }
	};

	const ColourDirectiveBind* GetColourBindings(OUT size_t& nElements)
	{
		nElements = sizeof(colourDirectiveBindings) / sizeof(ColourDirectiveBind);
		return colourDirectiveBindings;
	}

	void ApplyToRenderState(const Rococo::Sex::SEXML::ISEXMLDirective& schemeDirective, Gui::GRWidgetRenderState state, Rococo::Gui::IGRWidget& widget)
	{
		for (auto& binding : colourDirectiveBindings)
		{
			ApplyColourFromDirective(binding.name, binding.surface, state, widget, schemeDirective);
		}
	}

	struct OnScheme : ISEXMLWidgetFactorySupervisor
	{
		virtual ~OnScheme()
		{
		}

		void Free() override
		{
			delete this;
		}

		bool IsValidFrom(const Rococo::Sex::SEXML::ISEXMLDirective& widgetDefinition) const override
		{
			return widgetDefinition.Parent() == nullptr;
		}

		void Generate(IGreatSexGenerator& generator, const Rococo::Sex::SEXML::ISEXMLDirective& schemeDirective, Rococo::Gui::IGRWidget& widget) override
		{
			UNUSED(generator);

			if (schemeDirective.Parent() != nullptr)
			{
				Throw(schemeDirective.S(), "Scheme directives must be top-level directives, not children of other directives");
			}

			for (int j = 0; j < schemeDirective.NumberOfChildren(); j++)
			{
				auto& directive = schemeDirective[j];
				if (Eq(directive.FQName(), "ApplyTo"))
				{
					Gui::GRWidgetRenderState state(0, 0, 0);
					auto& states = SEXML::AsStringList(directive.GetAttributeByName("RenderStates").Value());
					for (int i = 0; i < states.NumberOfElements(); ++i)
					{
						if (Eq(states[i], "focused"_fstring))
						{
							state.value.bitValues.focused = true;
						}
						else if (Eq(states[i], "hovered"_fstring))
						{
							state.value.bitValues.hovered = true;
						}
						else if (Eq(states[i], "pressed"_fstring))
						{
							state.value.bitValues.pressed = true;
						}
						else if (Eq(states[i], "default"_fstring))
						{

						}
						else
						{
							Throw(directive.S(), "Unknown render state: %s", (cstr)states[i]);
						}
					}

					ApplyToRenderState(schemeDirective, state, widget);
				}
				else
				{
					bool foundColour = false;
					for (auto& bind : colourDirectiveBindings)
					{
						if (Eq(bind.name, directive.FQName()))
						{
							// Recognized as a colour directive
							foundColour = true;
							break;
						}
					}

					if (foundColour == false)
					{
						char possibilities[2048];
						StackStringBuilder sb(possibilities, sizeof(possibilities));
						sb << "\n\tApplyTo";

						for (auto& bind : colourDirectiveBindings)
						{
							sb << "\n\t" << bind.name;
						}

						Throw(directive.S(), "Unknown directive. Expecting one of %s", possibilities);
					}
				}
			}
		}
	};

	ROCOCO_GREAT_SEX_API ISEXMLWidgetFactorySupervisor* CreateSchemeHandler()
	{
		return new OnScheme();
	}
}

// Origin: D:/work/rococo/source/rococo/rococo.great.sex/great.sex.main.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#define ROCOCO_USE_SAFE_V_FORMAT
#include <rococo.great.sex.h>
#include <sexy.types.h>
#include <Sexy.S-Parser.h>
#include <rococo.sexml.h>
#include <new>
#include <rococo.hashtable.h>
#include <rococo.functional.h>
#include <rococo.strings.h>
#include <rococo.io.h>
#include <rococo.game.options.h>
#include <vector>

#define MATCH(text, value, numericEquivalent) if (Strings::EqI(text,value)) return numericEquivalent;

#include "sexml.widgets.simple.inl"

using namespace Rococo;
using namespace Rococo::Gui;
using namespace Rococo::Sex;
using namespace Rococo::Sex::SEXML;
using namespace Rococo::Strings;

namespace Rococo
{
	template<class T>
	cstr AppendKeys(const stringmap<T>& map, StringBuilder& sb, cstr separator = ",")
	{
		bool first = true;

		for (auto& i : map)
		{
			if (first)
			{
				first = false;
			}
			else
			{
				sb << separator;
			}

			sb << (cstr)i.first;
		}

		return (*sb).buffer;
	}
}

namespace Rococo::Game::Options
{
	namespace Implementation
	{
		struct MissingOptDatabase : IOptionDatabase
		{
			void Invoke(cstr, cstr, IGameOptionChangeNotifier&) override {}
			void Invoke(cstr, bool, IGameOptionChangeNotifier&) override {}
			void Invoke(cstr, double, IGameOptionChangeNotifier&)  override {}
		};

		struct MissingOptions : IMissingOptions
		{
			MissingOptDatabase db;

			struct Err
			{
				bool indicator;
				HString msg;
			};

			std::vector<Err> errs;

			MissingOptions(cstr msg)
			{
				errs.push_back({ false, msg });
			}

			virtual ~MissingOptions()
			{

			}

			void AddLine(bool indicator, cstr msg) override
			{
				errs.push_back({ indicator, msg });
			}

			void Free() override
			{
				delete this;
			}

			void AddOptions(IGameOptionsBuilder& builder)
			{
				char name[24];
				int index = 0;
				for (auto& err : errs)
				{
					SafeFormat(name, "err_%d", index++);
					auto& b = builder.AddBool(name);
					b.SetTitle(err.msg);
					b.SetActiveValue(err.indicator);
				}
			}

			void Refresh(IGameOptionsBuilder&) override
			{

			}

			void OnTick(float dt, IGameOptionChangeNotifier& notifier)
			{
				UNUSED(dt);
				UNUSED(notifier);
			}

			IOptionDatabase& DB() { return db; }
			void Accept(IGameOptionChangeNotifier&) {}
			void Revert(IGameOptionChangeNotifier&) {}
			bool IsModified() const { return false; }
		};
	}

	IMissingOptions* CreateMissingOptions(const char* format, ...)
	{
		va_list args;
		va_start(args, format);

		char msg[1024];
		SafeVFormat(msg, sizeof msg, format, args);

		va_end(args);

		return new Implementation::MissingOptions(msg);
	}
}

namespace Rococo::GreatSex
{
	const ColourDirectiveBind* GetColourBindings(OUT size_t& nElements);

	namespace Implementation
	{
		struct ColourBinding
		{
			GRWidgetRenderState rs;
			RGBAb colour;
		};

		static std::vector<Game::Options::IMissingOptions*>* missingOptionsArray = nullptr;

		void CleanupAtExit()
		{
			if (missingOptionsArray)
			{
				for (auto* opt : *missingOptionsArray)
				{
					opt->Free();
				}

				delete missingOptionsArray;
				missingOptionsArray = nullptr;
			}
		}

		void ManageGlobalMissingOptions(Game::Options::IMissingOptions* options)
		{
			if (!missingOptionsArray)
			{
				missingOptionsArray = new std::vector<Game::Options::IMissingOptions*>();
				atexit(CleanupAtExit);
			}

			missingOptionsArray->push_back(options);
		}

		struct GreatSexGenerator : IGreatSexGeneratorSupervisor, ISEXMLColourSchemeBuilder, ISEXMLInserter, ISEXMLGameOptionsList
		{
			IAllocator& sexmlAllocator;
			IGreatSexResourceLoader& loader;

			DivisionFactory onDivision;
			AutoFree<ISEXMLWidgetFactorySupervisor> onScheme;
			AutoFree<ISEXMLWidgetFactorySupervisor> onColour;
			VerticalListFactory onVerticalList;
			TextLabelFactory onTextLabel;
			ButtonFactory onButton;
			ToolbarFactory onToolbar;
			FrameFactory onFrame;
			FrameClientAreaFactory onFrameClientArea;
			InsertFactory onInsert;
			GameOptionsFactory onGameOptions;
			ViewportFactory onViewport;
			FontFactory onFont;
			PortraitFactory onPortrait;
			GradientFillFactory onGradientFill;
			HintBoxFactory onHintBox;
			RadioButtonsFactory onRadioButtons;
			TabFactory onTab;
			IconFactory onIcon;
			ControlPromptFactory onControlPrompt;
			PromptFactory onPrompt;
			DefIconFactory onDefIcon;
			ViewportClientFactory onViewportClient;
			ViewportOffsetFactory onViewportOffset;
			ZoomFactory onZoom;

			Auto<ISParser> insertParser;

			stringmap<ISEXMLWidgetFactory*> widgetHandlers;

			typedef void(GreatSexGenerator::* MethodForAttribute)(IGRPanel& panel, const ISEXMLAttributeValue& value);

			stringmap<MethodForAttribute> attributeHandlers;

			stringmap<std::vector<ColourBinding>> colourSpecs;

			stringmap<EGRSchemeColourSurface> nameToColourSurface;

			GreatSexGenerator(IAllocator& _sexmlAllocator, IGreatSexResourceLoader& _loader) :
				sexmlAllocator(_sexmlAllocator),
				loader(_loader),
				onScheme(CreateSchemeHandler()),
				onColour(CreateColourHandler(*this)),
				onInsert(*this),
				onGameOptions(*this)
			{
				insertParser = CreateSexParser_2_0(sexmlAllocator);

				AddHandler("Frame", onFrame);
				AddHandler("Frame.ClientArea", onFrameClientArea);
				AddHandler("GameOptions", onGameOptions);
				AddHandler("Colour", *onColour);
				AddHandler("Button", onButton);
				AddHandler("Div", onDivision);
				AddHandler("Scheme", *onScheme);
				AddHandler("VerticalList", onVerticalList);
				AddHandler("Label", onTextLabel);
				AddHandler("Toolbar", onToolbar);
				AddHandler("Insert", onInsert);
				AddHandler("Viewport", onViewport);
				AddHandler("Font", onFont);
				AddHandler("Portrait", onPortrait);
				AddHandler("GradientFill", onGradientFill);
				AddHandler("HintBox", onHintBox);
				AddHandler("RadioButtons", onRadioButtons);
				AddHandler("Tab", onTab);
				AddHandler("Icon", onIcon);
				AddHandler("ControlPrompt", onControlPrompt);
				AddHandler("Prompt", onPrompt);
				AddHandler("DefIcon", onDefIcon);
				AddHandler("Viewport.ClientArea", onViewportClient);
				AddHandler("Viewport.Offset", onViewportOffset);
				AddHandler("Zoom", onZoom);

				size_t nElements;
				const ColourDirectiveBind* bindings = GetColourBindings(OUT nElements);

				for (size_t i = 0; i < nElements; i++)
				{
					nameToColourSurface.insert(bindings[i].name, bindings[i].surface);
				}
			}

			virtual ~GreatSexGenerator()
			{
				
			}

			struct GRSexInsertCache
			{
				std::vector<char> buffer;
				Auto<ISourceCode> proxy;
			};

			stringmap<GRSexInsertCache> inserts;

			void OnInsertLoaded(cr_sex src, GRSexInsertCache& cache, IGRWidget& owner)
			{
				Auto<ISParserTree> tree;

				try
				{
					tree = insertParser->CreateTree(*cache.proxy);
				}
				catch (ParseException& ex)
				{
					char message[1024];
					SafeFormat(message, "Error loading sexml from directive at line %d in %s: %s", src.Start().y, src.Tree().Source().Name(), ex.Message());
					ParseException deepEx(ex.Start(), ex.End(), ex.Name(), message, ex.Specimen(), ex.Source());
					throw deepEx;
				}
				catch (IException& ex)
				{
					char message[1024];
					SafeFormat(message, "Error loading sexml from directive at line %d in %s: %s", src.Start().y, src.Tree().Source().Name(), ex.Message());
					ParseException deepEx(src.Start(), src.End(), src.Tree().Source().Name(), message, "", &src);
					throw deepEx;
				}

				try
				{
					AppendWidgetTreeFromSexML(tree->Root(), owner);
				}
				catch (ParseException& ex)
				{
					char message[1024];
					SafeFormat(message, "Error loading sexml from directive at line %d in %s: %s", src.Start().y, src.Tree().Source().Name(), ex.Message());
					ParseException deepEx(ex.Start(), ex.End(), ex.Name(), message, ex.Specimen(), ex.Source());
					throw deepEx;
				}
				catch (IException& ex)
				{
					char message[1024];
					SafeFormat(message, "Error loading sexml from directive at line %d in %s: %s", src.Start().y, src.Tree().Source().Name(), ex.Message());
					ParseException deepEx(tree->Root().Start(), tree->Root().End(), cache.proxy->Name(), message, "", &src);
					throw deepEx;
				}
			}

			void Insert(cstr filePath, cr_sex src, IGRWidget& owner) override
			{
				if (inserts.find(filePath) != inserts.end())
				{
					Throw(src, "Duplicate insert of %s", filePath);
				}

				struct : Rococo::IO::ILoadEventsCallback
				{
					cstr filePath = nullptr;
					GreatSexGenerator* This = nullptr;
					GRSexInsertCache* cache = nullptr;
	
					void OnFileOpen(int64 fileLength) override
					{
						if (fileLength == 0)
						{
							Throw(0, "%s: file empty", filePath);
						}

						if (fileLength > (int64) 1_megabytes)
						{
							Throw(0, "%s: max length > 1 MB", filePath);
						}

						auto i = This->inserts.insert(filePath, GRSexInsertCache()).first;
						cache = &i->second;
						cache->buffer.resize(fileLength + 1);
					}

					void OnDataAvailable(IO::ILoadEventReader& reader) override
					{
						uint32 bytesRead;
						uint32 nBytesToRead = (uint32)(cache->buffer.size() - 1);
						reader.ReadData(&cache->buffer[0], nBytesToRead, OUT bytesRead);
						cache->buffer[cache->buffer.size()-1] = 0;
					}
				} onLoad;

				onLoad.filePath = filePath;
				onLoad.This = this;

				loader.LoadGreatSexResource(filePath, onLoad);

				cstr buffer = onLoad.cache->buffer.data();
				onLoad.cache->proxy = insertParser->ProxySourceBuffer(buffer, (int) strlen(buffer), { 0,0 }, filePath, nullptr);

				OnInsertLoaded(src, *onLoad.cache, owner);
			}

			stringmap<Game::Options::IGameOptions*> mapNameToOptions;

			void AddOptions(Game::Options::IGameOptions& options, cstr key) override
			{
				auto i = mapNameToOptions.insert(key, &options);
				if (!i.second)
				{
					Throw(0, "Duplicate key '%s': %s", key, __ROCOCO_FUNCTION__);
				}
			}

			Game::Options::IGameOptions& GetOptions(cstr key, cr_sex src) override
			{
				UNUSED(src);

				auto i = mapNameToOptions.find(key);
				if (i != mapNameToOptions.end())
				{
					return *i->second;
				}

				if (mapNameToOptions.empty())
				{
					auto* options = Game::Options::CreateMissingOptions("%s? - No options", key);
					options->AddLine(true, "C++ developer should use");
					options->AddLine(true, "IGreatSexGenerator::AddOptions(...)");
					ManageGlobalMissingOptions(options);
					mapNameToOptions.insert(key, options);
					return *options;
				}

				auto* options = Game::Options::CreateMissingOptions("Ayup! Unknown option '%s'", key);

				char info[256];
				SafeFormat(info, "great.sex.main.cpp #%d", __LINE__);
				options->AddLine(false, info);

				for (auto j : mapNameToOptions)
				{
					options->AddLine(true, j.first);
				}

				ManageGlobalMissingOptions(options);
				mapNameToOptions.insert(key, options);
				return *options;
			}

			struct FontDef
			{
				HString id;
				HString family;
				int height = 11;
				bool isBold = false;
				bool isItalic = false;
			};

			stringmap<FontDef> fonts;

			void AddFont(cstr id, cstr family, int height, bool isBold, bool isItalic) override
			{
				FontDef def;
				def.id = id;
				def.family = family;
				def.height = height;
				def.isBold = isBold;
				def.isItalic = isItalic;
				fonts[id] = def;
			}

			FontQuery GetFont(cstr id, const Sex::ISExpression& s) const override
			{
				auto i = fonts.find(id);
				if (i == fonts.end())
				{
					char err[4096];
					StackStringBuilder sb(err, sizeof(err));
					sb << "Unknown Font " << id << ". Known fonts :";

					int count = 0;
					for (auto h : fonts)
					{
						if (count > 0)
						{
							sb << ", ";
						}

						sb << (cstr)h.first;
						count++;
					}

					Throw(s, "%s", err);
				}

				FontQuery q;
				q.id = i->first;
				q.height = i->second.height;
				q.familyName = i->second.family;
				q.isBold = i->second.isBold;
				q.isItalic = i->second.isItalic;
				return q;
			}

			void AddHandler(cstr fqName, ISEXMLWidgetFactory& f) override
			{
				auto i = widgetHandlers.find(fqName);
				if (i != widgetHandlers.end())
				{
					Throw(0, "%s: Duplicate fqName: %s", __ROCOCO_FUNCTION__, fqName);
				}

				widgetHandlers.insert(fqName, &f);
			}

			void Free() override
			{
				auto& allocator = sexmlAllocator;
				this->~GreatSexGenerator();
				allocator.FreeData(this);
			}

			void AppendWidgetTreeFromSexML(const ISEXMLDirective& directive, IGRWidget& branch) override
			{
				cstr fqName = directive.FQName();

				auto i = widgetHandlers.find(fqName);
				if (i == widgetHandlers.end())
				{
					AutoFree<IDynamicStringBuilder> dsb = CreateDynamicStringBuilder(256);
					auto& sb = dsb->Builder();
					sb << "Known directives: ";

					bool first = true;
					for (auto h : widgetHandlers)
					{
						if (!h.second->IsValidFrom(directive))
						{
							continue;
						}

						if (!first)
						{
							sb << ", ";
						}
						else
						{
							first = false;
						}

						sb << (cstr)h.first;
					}

					cstr knownDirectives = *sb;

					Throw(directive.S(), "Unhandled widget directive: %s.\n%s", fqName, knownDirectives);
				}

				auto factory = i->second;
				factory->Generate(*this, directive, branch);
			}

			void AppendWidgetTreeFromSexML(cr_sex s, IGRWidget& branch) override
			{
				AutoFree<ISEXMLRootSupervisor> sexmlParser = CreateSEXMLParser(sexmlAllocator, s);
				auto& sp = *sexmlParser;

				/* Our Sexml is a list of directives that looks like this:
				*
				* (<widget-type> (<attribute-type-1> <attribute-value-1>) ...  (<attribute-type-N> <attribute-value-N>)
				*     :                 // The colon marks the end of attributes and the beginning of sub-directives
				*     (...child-1...) ...
				*     (...child-N...)
				* )
				*
				* The items are recursive so every child of a widget has the same structure as defined above. Widgets thus form are arbitrarily deep tree.
				*/

				for (int i = 0; i < sp.NumberOfDirectives(); i++)
				{
					auto& widgetDirective = sp[i];
					AppendWidgetTreeFromSexML(widgetDirective, branch);
				}
			}

			void GenerateChildren(const ISEXMLDirective& widgetDirective, Rococo::Gui::IGRWidget& widget) override
			{
				for (size_t i = 0; i < widgetDirective.NumberOfChildren(); i++)
				{
					auto& child = widgetDirective[i];
					AppendWidgetTreeFromSexML(child, widget);
				}
			}

			void OnAttribute_Offset(IGRPanel& panel, const ISEXMLAttributeValue& value)
			{
				Vec2i offset = SEXML::AsVec2i(value);
				panel.SetParentOffset(offset);
			}

			void OnAttribute_Span(IGRPanel& panel, const ISEXMLAttributeValue& value)
			{
				Vec2i initialSpan = SEXML::AsVec2i(value);
				panel.SetConstantSpan(initialSpan);
			}

			void OnAttribute_FixedHeight(IGRPanel& panel, const ISEXMLAttributeValue& value)
			{
				cstr raw = AsString(value).c_str();
				if (EndsWith(raw, "%"))
				{
					char intBuffer[16];
					SafeFormat(intBuffer, "%s", raw);
					int height = atoi(intBuffer);
					panel.SetConstantHeight(height, true);
				}
				else
				{
					int height = SEXML::AsAtomicInt32(value);
					panel.SetConstantHeight(height);
				}
			}

			void OnAttribute_FixedWidth(IGRPanel& panel, const ISEXMLAttributeValue& value)
			{
				cstr raw = AsString(value).c_str();
				if (EndsWith(raw, "%"))
				{
					char intBuffer[16];
					SafeFormat(intBuffer, "%s", raw);
					int width = atoi(intBuffer);
					panel.SetConstantWidth(width, true);
				}
				else
				{
					int width = SEXML::AsAtomicInt32(value);
					panel.SetConstantWidth(width);
				}
			}

			void OnAttribute_Description(IGRPanel& panel, const ISEXMLAttributeValue& value)
			{
				fstring desc = AsString(value).ToFString();
				if (desc.length > 0) panel.SetDesc(desc);
			}

			void OnAttribute_TabsCycle(IGRPanel& panel, const ISEXMLAttributeValue& value)
			{
				bool tabsCycle = AsBool(value);
				if (tabsCycle)
				{
					panel.Add(EGRPanelFlags::CycleTabsEndlessly);
				}
			}

			void OnAttribute_Padding(IGRPanel& panel, const ISEXMLAttributeValue& value)
			{
				GuiRect padding = AsGuiRect(value);
				panel.Set(GRAnchorPadding{ padding.left, padding.right, padding.top, padding.bottom });

				// (Recti Panel.Padding <left> <right> <top> <bottom>)
				cstr left = value.S()[2].c_str();
				cstr right = value.S()[3].c_str();
				cstr top = value.S()[4].c_str();
				cstr bottom = value.S()[5].c_str();

				panel.SetPaddingAsPercentage(EndsWith(left, "%"), EndsWith(right, "%"), EndsWith(top, "%"), EndsWith(bottom, "%"));
			}

			void OnAttribute_ChildPadding(IGRPanel& panel, const ISEXMLAttributeValue& value)
			{
				int padding = AsAtomicInt32(value);
				panel.SetChildPadding(padding);
			}

			void OnAttribute_Fit(IGRPanel& panel, const ISEXMLAttributeValue& value)
			{
				auto& fit = AsStringList(value);
				for (size_t i = 0; i < fit.NumberOfElements(); ++i)
				{
					cstr f = fit[i];
					if (Eq(f, "Horizontal") || Eq(f, "H"))
					{
						panel.SetFitChildrenHorizontally();
					}
					else if (Eq(f, "Vertical") || Eq(f, "V"))
					{
						panel.SetFitChildrenVertically();
					}
				}
			}

			void OnAttribute_RectStyle(IGRPanel& panel, const ISEXMLAttributeValue& value)
			{
				cstr style = AsString(value).c_str();

				if (EqI(style, "SHARP"))
				{
					panel.SetRectStyle(EGRRectStyle::SHARP);
				}
				else if (EqI(style, "ROUNDED"))
				{
					panel.SetRectStyle(EGRRectStyle::ROUNDED);
				}
				else if (EqI(style, "BLUR"))
				{
					panel.SetRectStyle(EGRRectStyle::ROUNDED_WITH_BLUR);
				}
				else
				{
					Throw(value.S(), "Expecting either SHARP, BLUR or ROUNDED");
				}
			}

			void OnAttribute_CornerRadius(IGRPanel& panel, const ISEXMLAttributeValue& value)
			{
				int radius = AsAtomicInt32(value);
				panel.SetCornerRadius(radius);
			}

			void OnAttribute_AcceptsFocus(IGRPanel& panel, const ISEXMLAttributeValue& value)
			{
				if (value.S().NumberOfElements() != 1)
				{
					Throw(value.S(), "Panel.AcceptsFocus expected to take no arguments");
				}

				panel.Add(EGRPanelFlags::AcceptsFocus);
			}

			void OnAttribute_Navigate(IGRPanel& panel, const ISEXMLAttributeValue& value)
			{
				auto& items = AsStringList(value);

				for (int i = 0; i < items.NumberOfElements(); ++i)
				{
					cstr item = items[i];
					panel.AddNavigationTarget(item);
				}
			}

			void OnAttribute_Hint(IGRPanel& panel, const ISEXMLAttributeValue& value)
			{
				auto& hint = AsString(value);
				panel.SetHint(hint.c_str());
			}

			void OnAttribute_Collapsed(IGRPanel& panel, const ISEXMLAttributeValue& value)
			{
				if (value.Type() != SEXMLValueType::Null)
				{
					Throw(value.S(), "No values permitted on a Collapsed attribute");
				}
				
				panel.SetCollapsed(true);
			}

			void OnAttribute_NavLeft(IGRPanel& panel, const ISEXMLAttributeValue& value)
			{
				cstr desc = AsString(value).c_str();
				panel.Set(EGRNavigationDirection::Left, desc);
			}

			void OnAttribute_NavRight(IGRPanel& panel, const ISEXMLAttributeValue& value)
			{
				cstr desc = AsString(value).c_str();
				panel.Set(EGRNavigationDirection::Right, desc);
			}

			void OnAttribute_NavUp(IGRPanel& panel, const ISEXMLAttributeValue& value)
			{
				cstr desc = AsString(value).c_str();
				panel.Set(EGRNavigationDirection::Up, desc);
			}

			void OnAttribute_NavDown(IGRPanel& panel, const ISEXMLAttributeValue& value)
			{
				cstr desc = AsString(value).c_str();
				panel.Set(EGRNavigationDirection::Down, desc);
			}

			void ParseExpansion(IGRPanel& panel, cstr item, cr_sex source)
			{
				if (Eq(item, "Horizontal") || Eq(item, "H"))
				{
					panel.SetExpandToParentHorizontally();
				}
				else if (Eq(item, "Vertical") || Eq(item, "V"))
				{
					panel.SetExpandToParentVertically();
				}
				else
				{
					Throw(source, "Unknown expansion argument. Expecting one of H, V, Horizontal, Vertical");
				}
			}

			void OnAttribute_ExpandH(IGRPanel& panel, const ISEXMLAttributeValue&)
			{
				panel.SetExpandToParentHorizontally();
			}

			void OnAttribute_ExpandV(IGRPanel& panel, const ISEXMLAttributeValue&)
			{
				panel.SetExpandToParentVertically();
			}

			void OnAttribute_Layout(IGRPanel& panel, const ISEXMLAttributeValue& value)
			{
				auto& avLayout = AsString(value);
				cstr sLayout = avLayout.c_str();

				ELayoutDirection layout = ELayoutDirection::None;
				
				if (Eq(sLayout, "None"))
				{
				}
				else if (Eq(sLayout, "LeftToRight"))
				{
					layout = ELayoutDirection::LeftToRight;
				}
				else if (Eq(sLayout, "TopToBottom"))
				{
					layout = ELayoutDirection::TopToBottom;
				}
				else if (Eq(sLayout, "RightToLeft"))
				{
					layout = ELayoutDirection::RightToLeft;
				}
				else if (Eq(sLayout, "BottomToTop"))
				{
					layout = ELayoutDirection::BottomToTop;
				}
				else
				{
					Throw(value.S(), "Could not interpret %s as a layout. Permitted values are: None, LeftToRight, TopToBottom, RightToLeft, BottomToTop", sLayout);
				}

				panel.SetLayoutDirection(layout);
			}

			RGBAb GetColour(cstr key, GRWidgetRenderState rs, cr_sex s) override
			{
				auto spec = colourSpecs.find(key);
				if (spec == colourSpecs.end())
				{
					Throw(s, "Could not find colour '%s'. Ensure a (Colour (Id %s)...) definition is in the root directives", key, key);
				}

				for (auto& colourSpec : spec->second)
				{
					if (colourSpec.rs == rs)
					{
						return colourSpec.colour;
					}
				}

				return RGBAb(255, 0, 0, 255);
			}

			void OnAttributePrefix_Colour(IGRPanel& panel, cstr name, const ISEXMLAttributeStringValue& value)
			{
				auto i = nameToColourSurface.find(name);
				if (i == nameToColourSurface.end())
				{
					AutoFree<IDynamicStringBuilder> dsb = CreateDynamicStringBuilder(256);
					Throw(value.S(), "No such colour surface: %s. Known:\t\n%s", name, AppendKeys(nameToColourSurface, dsb->Builder(), "\t\n"));
				}

				cstr key = value.c_str();

				auto spec = colourSpecs.find(key);
				if (spec == colourSpecs.end())
				{
					Throw(value.S(), "Could not find colour '%s'. Ensure a (Colour (Id %s)...) definition is in the root directives", key, key);
				}

				for (auto& colourSpec : spec->second)
				{
					panel.Set(i->second, colourSpec.colour, colourSpec.rs);
				}
			}

			void OnAttribute_OcclusionSurface(IGRPanel& panel, const ISEXMLAttributeValue& value)
			{
				bool isOccluder = AsBool(value);
				if (isOccluder)
				{
					panel.Add(EGRPanelFlags::OcclusionSurface);
				}
				else
				{
					panel.Remove(EGRPanelFlags::OcclusionSurface);
				}
			}

			void SetPanelAttributes(IGRWidget& widget, const ISEXMLDirective& widgetDirective) override
			{
				auto& panel = widget.Panel();
				panel.SetAssociatedSExpression(widgetDirective.S());

				if (attributeHandlers.empty())
				{
					attributeHandlers["Panel.Offset"] = &GreatSexGenerator::OnAttribute_Offset;
					attributeHandlers["Panel.Span"] = &GreatSexGenerator::OnAttribute_Span;
					attributeHandlers["Panel.FixedWidth"] = &GreatSexGenerator::OnAttribute_FixedWidth;
					attributeHandlers["Panel.FixedHeight"] = &GreatSexGenerator::OnAttribute_FixedHeight;
					attributeHandlers["Panel.Description"] = &GreatSexGenerator::OnAttribute_Description;
					attributeHandlers["Panel.TabsCycle"] = &GreatSexGenerator::OnAttribute_TabsCycle;
					attributeHandlers["Panel.Padding"] = &GreatSexGenerator::OnAttribute_Padding;
					attributeHandlers["Panel.Layout"] = &GreatSexGenerator::OnAttribute_Layout;
					attributeHandlers["Panel.ExpandH"] = &GreatSexGenerator::OnAttribute_ExpandH;
					attributeHandlers["Panel.ExpandV"] = &GreatSexGenerator::OnAttribute_ExpandV;
					attributeHandlers["Panel.ChildPadding"] = &GreatSexGenerator::OnAttribute_ChildPadding;
					attributeHandlers["Panel.Fit"] = &GreatSexGenerator::OnAttribute_Fit;
					attributeHandlers["Panel.RectStyle"] = &GreatSexGenerator::OnAttribute_RectStyle;
					attributeHandlers["Panel.CornerRadius"] = &GreatSexGenerator::OnAttribute_CornerRadius;
					attributeHandlers["Panel.AcceptsFocus"] = &GreatSexGenerator::OnAttribute_AcceptsFocus;
					attributeHandlers["Panel.Navigate"] = &GreatSexGenerator::OnAttribute_Navigate;
					attributeHandlers["Panel.Hint"] = &GreatSexGenerator::OnAttribute_Hint;
					attributeHandlers["Panel.Collapsed"] = &GreatSexGenerator::OnAttribute_Collapsed;
					attributeHandlers["Panel.NavLeft"] = &GreatSexGenerator::OnAttribute_NavLeft;
					attributeHandlers["Panel.NavRight"] = &GreatSexGenerator::OnAttribute_NavRight;
					attributeHandlers["Panel.NavUp"] = &GreatSexGenerator::OnAttribute_NavUp;
					attributeHandlers["Panel.NavDown"] = &GreatSexGenerator::OnAttribute_NavDown;
					attributeHandlers["Panel.OcclusionSurface"] = &GreatSexGenerator::OnAttribute_OcclusionSurface;
				}

				for (size_t i = 0; i < widgetDirective.NumberOfAttributes(); i++)
				{
					auto& a = widgetDirective.GetAttributeByIndex(i);
					cstr name = a.Name();

					if (StartsWith(name, "Colour."))
					{
						OnAttributePrefix_Colour(panel, name, AsString(a.Value()));
					}

					if (!StartsWith(name, "Panel."))
					{
						continue;
					}

					auto attributeMethod = attributeHandlers.find(name);
					if (attributeMethod != attributeHandlers.end())
					{
						auto method = attributeMethod->second;
						(this->*method)(panel, a.Value());
					}
					else
					{
						char err[4096];
						StackStringBuilder sb(err, sizeof(err));
						sb << "Unknown Panel attribute " << name << ". Known attributes: ";

						int count = 0;
						for (auto h : attributeHandlers)
						{
							if (count > 0)
							{
								sb << ", ";
							}

							sb << (cstr)h.first;
							count++;
						}

						Throw(a.S(), "%s", err);
					}
				}
			}

			void AddColour(cstr id, RGBAb colour, GRWidgetRenderState rs) override
			{
				auto i = colourSpecs.find(id);
				if (i == colourSpecs.end())
				{
					i = colourSpecs.insert(id, std::vector<ColourBinding>()).first;
				}

				i->second.push_back({ rs, colour });
			}
		};
	}

	ROCOCO_GREAT_SEX_API IGreatSexGeneratorSupervisor* CreateGreatSexGenerator(IAllocator& sexmlAllocator, IGreatSexResourceLoader& loader)
	{
		void* pData = sexmlAllocator.Allocate(sizeof(Implementation::GreatSexGenerator));
		return new (pData) Implementation::GreatSexGenerator(sexmlAllocator, loader);
	}

	ROCOCO_GREAT_SEX_API bool LoadFrame(
		IO::IInstallation& installation, 
		IAllocator& allocator, 
		cstr sexmlPath, 
		Gui::IGRWidgetMainFrame& frame, 
		IEventCallback<IGreatSexGenerator>& onConstruct,
		IEventCallback<LoadFrameException>& onException)
	{
		struct RococoDefaultResourceLoader : IGreatSexResourceLoader
		{
			IO::IInstallation* installation = nullptr;
			void LoadGreatSexResource(cstr resourcePath, Rococo::IO::ILoadEventsCallback& onLoad) override
			{
				installation->LoadResource(resourcePath, onLoad);
			}
		} resourceLoader;
		resourceLoader.installation = &installation;

		try
		{
			AutoFree<IGreatSexGeneratorSupervisor> greatSex = CreateGreatSexGenerator(allocator, resourceLoader);
			onConstruct.OnEvent(*greatSex);

			Auto<ISParser> sParser = Sex::CreateSexParser_2_0(allocator);
			AutoFree<IExpandingBuffer> buffer = CreateExpandingBuffer(4_kilobytes);

			installation.LoadResource(sexmlPath, *buffer, 16_megabytes);

			Auto<ISourceCode> src = sParser->ProxySourceBuffer((cstr)buffer->GetData(), (int)buffer->Length(), { 1,1 }, sexmlPath, nullptr);

			try
			{
				Auto<ISParserTree> tree = sParser->CreateTree(*src);
				cr_sex s = tree->Root();

				frame.ClearZoomsScenarios();

				greatSex->AppendWidgetTreeFromSexML(s, frame.ClientArea().Widget());
				frame.Panel().PrepPanelAndDescendants();
				frame.Panel().ClearAssociatedExpressions();
				return true;
			}
			catch (ParseException& pex)
			{
				LoadFrameException lfe;
				lfe.startPos = pex.Start();
				lfe.endPos = pex.End();
				lfe.errorCode = pex.ErrorCode();
				lfe.message = pex.Message();
				lfe.fileData = buffer->Length() > 0 ? (cstr)buffer->GetData() : nullptr;
				lfe.filename = sexmlPath;
				onException.OnEvent(lfe);
				return false;
			}
		}
		catch (IException& ex)
		{
			LoadFrameException lfe;
			lfe.startPos = { 0,0 };
			lfe.endPos = { 0, 0 };
			lfe.errorCode = ex.ErrorCode();
			lfe.message = ex.Message();
			lfe.fileData = "<none>";
			lfe.filename = sexmlPath;
			onException.OnEvent(lfe);
			return false;
		}
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.great.sex/great.sex.test-data.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.great.sex.h>
#include <rococo.game.options.ex.h>
#include <rococo.strings.h>

using namespace Rococo::GreatSex;
using namespace Rococo::Strings;
using namespace Rococo::Game::Options;

static const char* GEN_HINT_FROM_PARENT_AND_CHOICE = "$*$: ";


namespace Rococo::GreatSex::TestData
{
	struct AudioOptions : IGameOptions
	{
		OptionDatabase<AudioOptions> db;

		double acceptedMusicVoluem = 25;
		double acceptedFXVolume = 20;
		double acceptedNarrationVolume = 40;

		double musicVolume = 25;
		double fxVolume = 20;
		double narrationVolume = 40;
		HString speakerConfig = "2";

		AudioOptions() : db(*this)
		{

		}

		virtual ~AudioOptions()
		{

		}

		IOptionDatabase& DB() override
		{
			return db;
		}

		void Accept(IGameOptionChangeNotifier&) override
		{
			acceptedMusicVoluem = musicVolume;
			acceptedFXVolume = fxVolume;
			acceptedNarrationVolume = narrationVolume;
		}

		void Revert(IGameOptionChangeNotifier& notifier) override
		{
			musicVolume = acceptedMusicVoluem;
			fxVolume = acceptedFXVolume;
			narrationVolume = acceptedNarrationVolume;
			notifier.OnSupervenientOptionChanged(*this);
		}

		void OnTick(float dt, IGameOptionChangeNotifier& notifier)
		{
			UNUSED(dt);
			UNUSED(notifier);
		}


		bool IsModified() const override
		{
			return true;
		}

		void GetMusicVolume(IScalarInquiry& inquiry)
		{
			inquiry.SetTitle("Music Volume");
			inquiry.SetRange(0, 100.0, 1.0);
			inquiry.SetActiveValue(musicVolume);
			inquiry.SetHint("Set music volume. 0 is off, 100.0 is maximum");
			inquiry.SetDecimalPlaces(0);
			inquiry.HideBackgroundWhenPopulated(true);
		}

		void SetMusicVolume(double value, IGameOptionChangeNotifier&)
		{
			musicVolume = value;
		}

		void GetFXVolume(IScalarInquiry& inquiry)
		{
			inquiry.SetTitle("FX Volume");
			inquiry.SetRange(0, 100.0, 1.0);
			inquiry.SetActiveValue(fxVolume);
			inquiry.SetHint("Set Special FX volume. 0 is off, 100.0 is maximum");
			inquiry.SetDecimalPlaces(0);
			inquiry.HideBackgroundWhenPopulated(true);
		}

		void SetFXVolume(double value, IGameOptionChangeNotifier&)
		{
			fxVolume = value;
		}

		void GetNarrationVolume(IScalarInquiry& inquiry)
		{
			inquiry.SetTitle("Narration Volume");
			inquiry.SetRange(0, 100.0, 0.5);
			inquiry.SetActiveValue(narrationVolume);
			inquiry.SetHint("Set narrator's voice volume. 0 is off, 100.0 is maximum");
			inquiry.SetDecimalPlaces(0);
			inquiry.HideBackgroundWhenPopulated(true);
		}

		void SetNarrationVolume(double value, IGameOptionChangeNotifier&)
		{
			narrationVolume = value;
		}

		void GetSpeakerConfiguration(IChoiceInquiry& inquiry)
		{
			inquiry.SetTitle("Speaker Configuration");
			inquiry.AddChoice("2", "2 (Stereo speakers)", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("2_1", "2.1 (Stereo + Subwoofer)", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("5_1", "5.1 Dolby Surround", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("7_1", "7.1 Dolby Surround", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("2H", "Stereo Headphones", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.SetActiveChoice(speakerConfig);
			inquiry.SetHint("Set sound set-up.");
		}

		void SetSpeakerConfiguration(cstr choice, IGameOptionChangeNotifier&)
		{
			speakerConfig = choice;
		}

		void AddOptions(IGameOptionsBuilder& builder) override
		{
			ADD_GAME_OPTIONS(db, AudioOptions, MusicVolume)
			ADD_GAME_OPTIONS(db, AudioOptions, FXVolume)
			ADD_GAME_OPTIONS(db, AudioOptions, NarrationVolume)
			ADD_GAME_OPTIONS(db, AudioOptions, SpeakerConfiguration)
			db.Build(builder);
		}

		void Refresh(IGameOptionsBuilder& builder) override
		{
			db.Refresh(builder);
		}
	};

	struct GraphicsOptions : IGameOptions
	{
		OptionDatabase<GraphicsOptions> db;

		virtual ~GraphicsOptions()
		{

		}

		IOptionDatabase& DB() override
		{
			return db;
		}

		void Accept(IGameOptionChangeNotifier&) override
		{

		}

		void Revert(IGameOptionChangeNotifier&) override
		{

		}

		bool IsModified() const override
		{
			return true;
		}

		void OnTick(float dt, IGameOptionChangeNotifier& notifier)
		{
			UNUSED(dt);
			UNUSED(notifier);
		}

		HString activeScreenMode = "Fullscreen";
		HString shadowQuality = "2";
		HString landscapeQuality = "1";
		HString reflectionAlgorithm = "1";
		HString monitor = "1";
		HString resolution = "1920x1080";
		HString textureQuality = "1";
		HString waterQuality = "1";
		bool isFSAAEnabled = false;

		// Zero based, 0 = lowest, 1 = low, 2 = medium, 3  = high, 4 = very high, 5 = extreme

		enum EGlobalQuality
		{
			GlobalQuality_Lowest = 0,
			GlobalQuality_Low,
			GlobalQuality_Medium,
			GlobalQuality_High,
			GlobalQuality_VeryHigh,
			GlobalQuality_Extreme
		};

		EGlobalQuality globalQuality = GlobalQuality_Lowest;

		GraphicsOptions() : db(*this)
		{

		}

		void GetScreenMode(IChoiceInquiry& inquiry)
		{
			inquiry.SetTitle("Screen Mode");
			inquiry.AddChoice("Fullscreen", "Fullscreen", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("Windowed", "Windowed", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("Fullscreen Windowed", "Fullscreen Windowed", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.SetActiveChoice(activeScreenMode);
			inquiry.SetHint("Set screen mode");
		}

		void SetScreenMode(cstr choice, IGameOptionChangeNotifier&)
		{
			activeScreenMode = choice;
		}

		void GetFSAA(IBoolInquiry& inquiry)
		{
			inquiry.SetTitle("Fullscreen Anti-Aliasing");
			inquiry.SetActiveValue(isFSAAEnabled);
			inquiry.SetHint("Enable or disable full screen anti-aliasing");
		}

		void SetGlobalQuality(cstr value, IGameOptionChangeNotifier& notifier)
		{
			auto eValue = static_cast<EGlobalQuality>(atoi(value));

			if (eValue == globalQuality)
			{
				return;
			}

			globalQuality = clamp(eValue, GlobalQuality_Lowest, GlobalQuality_Extreme);

			isFSAAEnabled = false;

			switch (eValue)
			{
			case GlobalQuality_Low:
				shadowQuality = "1";
				landscapeQuality = "1";
				break;
			case GlobalQuality_Lowest:
				shadowQuality = "2";
				landscapeQuality = "2";
				break;
			case GlobalQuality_Medium:
				shadowQuality = "3";
				landscapeQuality = "3";
				break;
			case GlobalQuality_High:
				shadowQuality = "4";
				landscapeQuality = "4";
				break;
			case GlobalQuality_VeryHigh:
				shadowQuality = "4";
				landscapeQuality = "5";
				break;
			case GlobalQuality_Extreme:
				shadowQuality = "5";
				isFSAAEnabled = true;
				landscapeQuality = "5";
				break;
			}

			notifier.OnSupervenientOptionChanged(*this);
		}

		void GetGlobalQuality(IChoiceInquiry& inquiry)
		{
			inquiry.SetTitle("Global Quality");

			inquiry.AddChoice("0", "Lowest", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("1", "Low", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("2", "Medium", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("3", "High", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("4", "Very-High", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("5", "Extreme", GEN_HINT_FROM_PARENT_AND_CHOICE);

			char value[8];
			SafeFormat(value, "%d", static_cast<int>(globalQuality));
			inquiry.SetActiveChoice(value);
			inquiry.SetHint("Set all quality settings");
		}

		void SetFSAA(bool value, IGameOptionChangeNotifier&)
		{
			isFSAAEnabled = value;
		}

		void GetShadowQuality(IChoiceInquiry& inquiry)
		{
			inquiry.SetTitle("Shadow Quality");
			inquiry.AddChoice("1", "512 x 512 1pt (low)", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("2", "1024 x 1024 4pt (medium)", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("3", "1024 x 1024 16pt (high)", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("4", "2048 x 2048 4pt (very high)", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("5", "2048 x 2048 16pt (ultra)", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.SetActiveChoice(shadowQuality);
			inquiry.SetHint("Set the quality of shadows. Higher settings may reduce frame-rate");
		}

		void SetShadowQuality(cstr value, IGameOptionChangeNotifier&)
		{
			shadowQuality = value;
		}

		void GetLandscapeQuality(IChoiceInquiry& inquiry)
		{
			inquiry.SetTitle("Landscape Quality");
			inquiry.AddChoice("1", "Low", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("2", "Medium", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("3", "High", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("4", "Ultra", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("5", "Ultra (Experimental)", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.SetActiveChoice(landscapeQuality);
			inquiry.SetHint("Set the quality of landscape rendering. Higher settings may reduce frame-rate");
		}

		void SetLandscapeQuality(cstr value, IGameOptionChangeNotifier&)
		{
			landscapeQuality = value;
		}

		void GetReflectionAlgorithm(IChoiceInquiry& inquiry)
		{
			inquiry.SetTitle("Reflection Algorithm");
			inquiry.AddChoice("1", "Gloss (Minimal)", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("2", "Global Environmental Mapping (Low)", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("3", "Local Environmental Mapping (Medium)", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("4", "Dynamic Environmental Mapping (High)", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("5", "Raytracing (Ultra)", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.SetActiveChoice(reflectionAlgorithm);
			inquiry.SetHint("Set the quality of reflections. Higher settings may reduce frame-rate");
		}

		void SetReflectionAlgorithm(cstr value, IGameOptionChangeNotifier&)
		{
			reflectionAlgorithm = value;
		}

		void GetActiveMonitor(IChoiceInquiry& inquiry)
		{
			inquiry.SetTitle("Active Monitor");
			inquiry.AddChoice("1", "1 - 1920x1080", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("2", "2 - 3840x2160", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.SetActiveChoice(monitor);
			inquiry.SetHint("Set which monitor to present the game in fullscreen");
		}

		void SetActiveMonitor(cstr value, IGameOptionChangeNotifier&)
		{
			monitor = value;
		}

		void GetFullscreenResolution(IChoiceInquiry& inquiry)
		{
			inquiry.SetTitle("Fullscreen Resolution");
			inquiry.AddChoice("1.1920x1080", "1920 x 1080 60Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("2.1920x1200", "1920 x 1200 60Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("3.2560x1536", "2560 x 1536 60Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("4.3840x2160", "3840 x 2160 60Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("5.1366x768", "1366 x 768 60Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("6.1280x1024", "1280 x 1024 60Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("7.1024x768", "1024 x 768 60Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("8.800x600", "800 x 600 60Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("9.640x480", "640 x 480 60Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("10.1920x1080", "1920 x 1080 144Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("11.1920x1200", "1920 x 1200 144Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("12.2560x1536", "2560 x 1536 144Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("13.3840x2160", "3840 x 2160 144Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("14.1366x768", "1366 x 768 144Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("15.1280x1024", "1280 x 1024 144Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("16.1024x768", "1024 x 768 144Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("17.800x600", "800 x 600 144Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("18.640x480", "640 x 480 144Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("19.1920x1080", "1920 x 1080 200Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("20.1920x1200", "1920 x 1200 200Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("21.2560x1536", "2560 x 1536 200Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("22.3840x2160", "3840 x 2160 200Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("23.1366x768", "1366 x 768 200Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("24.1280x1024", "1280 x 1024 200Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("25.1024x768", "1024 x 768 200Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("26.800x600", "800 x 600 200Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("27.640x480", "640 x 480 200Hz", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.SetActiveChoice(resolution);
			inquiry.SetHint("Set full screen resolution and frame rate");
		}

		void SetFullscreenResolution(cstr choice, IGameOptionChangeNotifier&)
		{
			resolution = choice;
		}

		void GetTextureQuality(IChoiceInquiry& inquiry)
		{
			inquiry.SetTitle("Texture Quality");
			inquiry.AddChoice("1", "Low 256x256", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("2", "Medium 512x512", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("3", "High 1024x1024 ", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("4", "Very High 2048x2048", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("5", "Ultra 4096x2096", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.SetActiveChoice(textureQuality);
			inquiry.SetHint("Set the texture sizes. Higher settings may slow frame rate");
		}

		void SetTextureQuality(cstr choice, IGameOptionChangeNotifier&)
		{
			textureQuality = choice;
		}

		void GetWaterQuality(IChoiceInquiry& inquiry)
		{
			inquiry.SetTitle("Water Quality");
			inquiry.AddChoice("1", "Low - flat", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("2", "Medium - ripples", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("3", "High - ripples & refraction", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("4", "Very High - full physics", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.AddChoice("5", "Ultra - physics and reflections", GEN_HINT_FROM_PARENT_AND_CHOICE);
			inquiry.SetActiveChoice(waterQuality);
			inquiry.SetHint("Set the quality of water rendering. Higher settings may slow frame rate");
		}

		void SetWaterQuality(cstr choice, IGameOptionChangeNotifier&)
		{
			waterQuality = choice;
		}

		void AddOptions(IGameOptionsBuilder& builder) override
		{
			ADD_GAME_OPTIONS(db, GraphicsOptions, ScreenMode)
			ADD_GAME_OPTIONS(db, GraphicsOptions, GlobalQuality);
			ADD_GAME_OPTIONS(db, GraphicsOptions, FSAA)
			ADD_GAME_OPTIONS(db, GraphicsOptions, ShadowQuality)
			ADD_GAME_OPTIONS(db, GraphicsOptions, LandscapeQuality)
			ADD_GAME_OPTIONS(db, GraphicsOptions, ReflectionAlgorithm)
			ADD_GAME_OPTIONS(db, GraphicsOptions, ActiveMonitor)
			ADD_GAME_OPTIONS(db, GraphicsOptions, FullscreenResolution)
			ADD_GAME_OPTIONS(db, GraphicsOptions, TextureQuality)
			ADD_GAME_OPTIONS(db, GraphicsOptions, WaterQuality)
			db.Build(builder);
		}

		void Refresh(IGameOptionsBuilder& builder) override
		{
			db.Refresh(builder);
		}
	};

	struct UIOptions : IGameOptions
	{
		OptionDatabase<UIOptions> db;

		double cursorResponsiveness = 3.0;
		bool isYAxisInverted = false;

		UIOptions() : db(*this)
		{

		}

		virtual ~UIOptions()
		{

		}

		IOptionDatabase& DB() override
		{
			return db;
		}

		void Accept(IGameOptionChangeNotifier&) override
		{

		}

		void Revert(IGameOptionChangeNotifier&) override
		{

		}

		void OnTick(float dt, IGameOptionChangeNotifier& notifier)
		{
			UNUSED(dt);
			UNUSED(notifier);
		}


		bool IsModified() const override
		{
			return true;
		}

		void GetCursorResponsiveness(IScalarInquiry& inquiry)
		{
			inquiry.SetTitle("Mouse Sensitivity");
			inquiry.SetRange(1, 10, 0.5);
			inquiry.SetActiveValue(cursorResponsiveness);
			inquiry.SetHint("Set scaling of mouse movement to cursor movement");
			inquiry.SetDecimalPlaces(1);
		}

		void SetCursorResponsiveness(double value, IGameOptionChangeNotifier&)
		{
			cursorResponsiveness = value;
		}

		void GetInvertYAxis(IBoolInquiry& inquiry)
		{
			inquiry.SetTitle("Invert Y-Axis");
			inquiry.SetActiveValue(isYAxisInverted);
			inquiry.SetHint("Reverse the response to player ascent to the joystick direction");
		}

		void SetInvertYAxis(bool value, IGameOptionChangeNotifier&)
		{
			isYAxisInverted = value;
		}

		void AddOptions(IGameOptionsBuilder& builder) override
		{
			ADD_GAME_OPTIONS(db, UIOptions, CursorResponsiveness)
			ADD_GAME_OPTIONS(db, UIOptions, InvertYAxis)
			db.Build(builder);
		}

		void Refresh(IGameOptionsBuilder&) override
		{

		}
	};

	struct GameplayOptions : IGameOptions
	{
		OptionDatabase<GameplayOptions> db;

		HString startDifficulty = "Easy";
		HString gameDifficulty = "Easy";
		HString playerName = "Geoff";

		GameplayOptions() : db(*this)
		{

		}

		virtual ~GameplayOptions()
		{

		}

		IOptionDatabase& DB() override
		{
			return db;
		}

		void Accept(IGameOptionChangeNotifier&) override
		{

		}

		void Revert(IGameOptionChangeNotifier&) override
		{

		}

		bool IsModified() const override
		{
			return true;
		}

		void GetStartingDifficulty(IChoiceInquiry& inquiry)
		{
			inquiry.SetTitle("Starting Difficulty");
			inquiry.AddChoice("Easy", "Easy", "Recruits cannot die during training");
			inquiry.AddChoice("Medium", "Medium", "Recruits have three lives to complete training");
			inquiry.AddChoice("Hard", "Realistic", "Recruits can die during training");
			inquiry.AddChoice("Ironman", "Ironman", "No save game slots during training");

			inquiry.SetActiveChoice(startDifficulty);
			inquiry.SetHint("Set the difficulty of the training mission");
		}

		void SetStartingDifficulty(cstr value, IGameOptionChangeNotifier&)
		{
			startDifficulty = value;
		}

		void GetGameDifficulty(IChoiceInquiry& inquiry)
		{
			inquiry.SetTitle("Game Difficulty");
			inquiry.AddChoice("Easy", "Easy", "On death you respawn at the last checkpoint");
			inquiry.AddChoice("Medium", "Medium", "You respawn on death, but lose 25% xp");
			inquiry.AddChoice("Hard", "Realistic", "No respawns on death");
			inquiry.AddChoice("Ironman", "Ironman", "Save game deleted on death... and no respawn on death");

			inquiry.SetActiveChoice(gameDifficulty);
			inquiry.SetHint("Set the difficulty of the main game");
		}

		void SetGameDifficulty(cstr value, IGameOptionChangeNotifier&)
		{
			gameDifficulty = value;
		}

		void SetPlayerName(cstr value, IGameOptionChangeNotifier&)
		{
			if (*value == 0)
			{
				playerName = "Geoff";
				return;
			}

			playerName = value;
		}

		void GetPlayerName(IStringInquiry& inquiry)
		{
			inquiry.SetTitle("Player Name");
			inquiry.SetActiveValue(playerName);
			inquiry.SetHint("Set the name of your player's avatar");
		}

		void AddOptions(IGameOptionsBuilder& builder) override
		{
			ADD_GAME_OPTIONS(db, GameplayOptions, StartingDifficulty)
			ADD_GAME_OPTIONS(db, GameplayOptions, GameDifficulty)
			ADD_GAME_OPTIONS_STRING(db, GameplayOptions, PlayerName, 32)

			db.Build(builder);
		}

		void Refresh(IGameOptionsBuilder&) override
		{

		}

		void OnTick(float dt, IGameOptionChangeNotifier& notifier)
		{
			UNUSED(dt);
			UNUSED(notifier);
		}
	};

	struct MultiplayerOptions : IGameOptions
	{
		OptionDatabase<MultiplayerOptions> db;

		bool hostGame = false;
		bool useUDP = true;

		MultiplayerOptions() : db(*this)
		{

		}

		virtual ~MultiplayerOptions()
		{

		}

		IOptionDatabase& DB() override
		{
			return db;
		}

		void Accept(IGameOptionChangeNotifier&) override
		{

		}

		void Revert(IGameOptionChangeNotifier&) override
		{

		}

		bool IsModified() const override
		{
			return true;
		}

		void GetHostGame(IBoolInquiry& inquiry)
		{
			inquiry.SetTitle("Host Game");
			inquiry.SetActiveValue(hostGame);
		}

		void SetHostGame(bool value, IGameOptionChangeNotifier&)
		{
			hostGame = value;
		}

		void GetUseUDP(IBoolInquiry& inquiry)
		{
			inquiry.SetTitle("UDP");
			inquiry.SetActiveValue(useUDP);
		}

		void SetUseUDP(bool value, IGameOptionChangeNotifier&)
		{
			useUDP = value;
		}

		void AddOptions(IGameOptionsBuilder& builder) override
		{
			ADD_GAME_OPTIONS(db, MultiplayerOptions, HostGame)
			ADD_GAME_OPTIONS(db, MultiplayerOptions, UseUDP)
			db.Build(builder);
		}

		void Refresh(IGameOptionsBuilder&) override
		{

		}

		void OnTick(float dt, IGameOptionChangeNotifier& notifier)
		{
			UNUSED(dt);
			UNUSED(notifier);
		}
	};

	GraphicsOptions s_GraphicsOptions;
	AudioOptions s_AudioOptions;
	UIOptions s_UIOptions;
	GameplayOptions s_gameplayOptions;
	MultiplayerOptions s_MultiplayerOptions;

	IGameOptions& GetUIOptions()
	{
		return s_UIOptions;
	}

	IGameOptions& GetGraphicsOptions()
	{
		return s_GraphicsOptions;
	}

	IGameOptions& GetAudioOptions()
	{
		return s_AudioOptions;
	}

	IGameOptions& GetGameplayOptions()
	{
		return s_gameplayOptions;
	}

	IGameOptions& GetMultiplayerOptions()
	{
		return s_MultiplayerOptions;
	}
}

namespace Rococo::GreatSex
{
	ROCOCO_GREAT_SEX_API void AddTestOptions(IGreatSexGenerator& generator)
	{
		generator.AddOptions(TestData::GetGraphicsOptions(), "GraphicsOptions");
		generator.AddOptions(TestData::GetAudioOptions(), "AudioOptions");
		generator.AddOptions(TestData::GetUIOptions(), "UIOptions");
		generator.AddOptions(TestData::GetGameplayOptions(), "GameplayOptions");
		generator.AddOptions(TestData::GetMultiplayerOptions(), "MultiplayerOptions");
	}
}
