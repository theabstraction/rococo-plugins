// Copyright (c) 2025 Mark Anthony Taylor. All rights reserved. Email: mark.anthony.taylor@gmail.com.
// Bundle generated by Build.Rococo.GUI.cs on Oct 2025 UTC
#include "rococo.os.UE5.h"
// Copyright (c)2025 Mark Anthony Taylor (mark.anthony.taylor@gmail.com). All rights reserved.
// This software is open source, but not free. Check the rococo master branch for the latest Copyright rules that applies to this software

#include <HAL/Platform.h>

#ifdef _WIN32
# pragma warning(disable: 4458) // this is my coding style and I don't see many errors arising out of the choice of style
# pragma warning(disable: 4265) // virtualized destructors are irrelevant for these classes using the Free() pattern
#else
# pragma clang diagnostic push
# pragma clang diagnostic ignored "-Wshadow"
# pragma clang diagnostic ignored "-Wdelete-non-abstract-non-virtual-dtor"
# pragma clang diagnostic ignored "-Woverloaded-virtual"
# pragma clang diagnostic ignored "-Wmissing-braces"
#endif
// Origin: D:/work/rococo/source/rococo/rococo.util/rococo.strings.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.types.h>

#define _CRT_NONSTDC_NO_WARNINGS

#ifdef ROCOCO_WIDECHAR_IS_CHAR_16_T
#include "rococo.char16.inl"
#endif

#include <stdarg.h>
#include <rococo.functional.h>
#include <rococo.debugging.h>

#ifdef _WIN32
# include <malloc.h>
#else 
# include <alloca.h>
# define strtok_s strtok_r
#endif

#include <vector>
#include <rococo.io.h>

#define ROCOCO_USE_SAFE_V_FORMAT
#include <rococo.strings.h>
#include <rococo.reflector.h>

#ifdef __APPLE__
# define _stricmp strcasecmp
#endif

using namespace Rococo;
using namespace Rococo::Strings;

#ifndef ROCOCO_API
# define ROCOCO_API __declspec(dllexport)
#endif

namespace Rococo
{
	ROCOCO_API bool DoesModifiedFilenameMatchResourceName(cstr modifiedFilename, cstr resourceName)
	{
		cstr p = modifiedFilename;
		cstr q = resourceName + 1;

		while (*p != 0)
		{
			if (*p != *q)
			{
				if (*p == '\\' && *q == '/')
				{
					// ok
				}
				else
				{
					return false;
				}
			}

			p++;
			q++;
		}

		return *q == 0;
	}
}

namespace StringsAnon
{
	class ExpandingBuffer : public IExpandingBuffer
	{
		std::vector<uint8> internalBuffer;
	public:
		ExpandingBuffer(size_t capacity) : internalBuffer(capacity)
		{
		}

		virtual ~ExpandingBuffer()
		{

		}

		const uint8* GetData() const override
		{
			if (internalBuffer.capacity() == 0) return nullptr;
			else return &internalBuffer[0];
		}

		uint8* GetData() override
		{
			if (internalBuffer.capacity() == 0) return nullptr;
			else return &internalBuffer[0];
		}

		size_t Length() const override
		{
			return internalBuffer.size();
		}

		void Resize(size_t length) override
		{
			internalBuffer.resize(length);
		}

		void Free() override
		{
			delete this;
		}
	};

	struct DynamicStringBuilder : StringBuilder, public IDynamicStringBuilder
	{
		std::vector<char> internalBuffer;

		DynamicStringBuilder(size_t initCapacity)
		{
			internalBuffer.resize(initCapacity);
			Clear();
		}

		virtual ~DynamicStringBuilder()
		{

		}

		StringBuilder& Builder() override
		{
			return *this;
		}

		StringBuilder& AppendFormat(const char* format, ...) override
		{
			size_t startSize = internalBuffer.size()-1;

			internalBuffer.pop_back(); // Get rid of the zero

			bool isDone = false;

			for (size_t sublen = 256; sublen <= 128_megabytes; sublen *= 2)
			{
				internalBuffer.resize(startSize + sublen);

				va_list args;
				va_start(args, format);
				int nChars = SafeVFormat(internalBuffer.data() + startSize, sublen, format, args);

				if (nChars < 0 || nChars >= (sublen - 1))
				{
					// overflow, so retry
					continue;
				}
				else
				{
					internalBuffer.resize(startSize + nChars);
					internalBuffer.push_back(0);
					isDone = true;
					break;
				}
			}

			if (!isDone)
			{
				Throw(0, "Cannot append formatted string. It was in excess of 128 megabytes");
			}

			return *this;
		}

		StringBuilder& operator << (cstr text) override
		{
			size_t len = strlen(text);
			size_t containerLen = internalBuffer.size();

			internalBuffer.resize(containerLen + len);
			memcpy(internalBuffer.data() + containerLen - 1, text, len);
			internalBuffer[containerLen + len - 1] = 0;

			return *this;
		}

		StringBuilder& AppendChar(char c) override
		{
			char data[2];
			data[0] = c;
			data[1] = 0;
			return *this << data;
		}

		StringBuilder& operator << (int32 value) override
		{
			return AppendFormat("%d", value);
		}

		StringBuilder& operator << (uint32 value) override
		{
			return AppendFormat("%u", value);
		}

		StringBuilder& operator << (int64 value) override
		{
			return AppendFormat("%lld", value);
		}

		StringBuilder& operator << (uint64 value)  override
		{
			return AppendFormat("%llu", value);
		}

		StringBuilder& operator << (float value) override
		{
			return AppendFormat("%f", value);
		}

		StringBuilder& operator << (double value)  override
		{
			return AppendFormat("%lf", value);
		}

		fstring operator * () const override
		{
			if (internalBuffer.size() >= 0x80000000LL) Throw(0, "DynamicStringBuilder: Cannot convert to fstring. Buffer too large ");
			return fstring{ internalBuffer.data(), Length() };
		}

		void Clear() override
		{
			internalBuffer.resize(0);
			internalBuffer.push_back(0);
		}

		int32 Length() const override
		{
			return (int32)(internalBuffer.size()-1);
		}

		void Free() override
		{
			delete this;
		}
	};
}

namespace Rococo::Strings
{
	char ToHex(int32 c)
	{
		static const char* const digits = "01234567890ABCDEF";
		return digits[c & 0xF];
	}

	ROCOCO_API void AppendAsciiCode(StringBuilder& sb, char c)
	{
		char buf[3] = { 0,0,0 };
		buf[0] = ToHex(c >> 16);
		buf[1] = ToHex(c);
		sb << buf;
	}

	ROCOCO_API void AppendEscapedSexyString(StringBuilder& sb, cstr text)
	{
		for (const char* s = text; *s != 0; s++)
		{
			char c = *s;
			switch (c)
			{
			case '\a': sb << "&a"; break;
			case '\b': sb << "&b"; break;
			case '\f': sb << "&f"; break;
			case '\r': sb << "&r"; break;
			case '\n': sb << "&n"; break;
			case '\t': sb << "&t"; break;
			default:
				if (c < 31 || c > 127)
				{
					sb << "&x";
					AppendAsciiCode(sb, c);
				}
				else
				{
					char buf[2] = { c,0 };
					sb << buf;
				}
				break;
			}
		}
	}

#ifndef _WIN32

	void Format(OUT HString& target, cstr format, ...)
	{
		thread_local std::vector<char> buffer;

		if (buffer.size() < 64)
		{
			buffer.resize(64);
		}

		va_list args;
		va_start(args, format);

		for (;;)
		{
			int count = vsnprintf(buffer.data(), buffer.size(), format, args);
			if (count >= buffer.size() - 1)
			{
				// Truncated, so double the buffer size and try again
				buffer.resize(buffer.size() * 2ULL);
				continue;
			}
			else if (count < 0)
			{
				Throw(0, "vsnprintf_s failed");
			}
			else
			{
				// No truncation
				target = buffer.data();
				return;
			}
		}
	}
#else
	void Format(OUT HString& target, cstr format, ...)
	{
		thread_local std::vector<char> buffer;

		if (buffer.size() == 0)
		{
			buffer.resize(64);
		}

		va_list args;
		va_start(args, format);
		
		for (;;)
		{
			_set_errno(0);
			int count = vsnprintf_s(buffer.data(), buffer.size(), _TRUNCATE, format, args);
			if (count == -1)
			{
				int err;
				_get_errno(&err);
				if (err != 0)
				{
					char errBuf[256];
					strerror_s(errBuf, err);
					Throw(0, "%s returned an error code %d. %s", __ROCOCO_FUNCTION__, err, errBuf);
				}
				else // Truncated, so double the buffer size and try again
				{
					buffer.resize(buffer.size() * 2ULL);
				}
			}
			else
			{
				// No truncation
				target = buffer.data();
				return;
			}
		}
	}
#endif
	ROCOCO_API int32 MakePath(U8FilePath& combinedPath, cstr rootPath, cstr subdirectory)
	{
		auto len = strlen(rootPath);
		if (len > 0)
		{
			if (rootPath[len - 1] != IO::GetFileSeparator())
			{
				return SecureFormat(combinedPath.buf, "%s%s%s", rootPath, IO::GetFileSeparatorString(), subdirectory);
			}
			else
			{
				return SecureFormat(combinedPath.buf, "%s%s", rootPath, subdirectory);
			} 
		}
		else
		{
			return SecureFormat(combinedPath.buf, "%s%s", IO::GetFileSeparatorString(), subdirectory);
		}
	}

	ROCOCO_API int32 Format(U8FilePath& path, cstr format, ...)
	{
		va_list args;
		va_start(args, format);
		int count = SafeVFormat(path.buf, path.CAPACITY, format, args);
		if (count == -1)
		{
			Throw(0, "%s failed. Buffer length exceeded. Format String: %s", __ROCOCO_FUNCTION__, format);
		}
		return count;
	}

	ROCOCO_API int32 Format(WideFilePath& path, crwstr format, ...)
	{
		va_list args;
		va_start(args, format);
		int count = SafeVFormat(path.buf, path.CAPACITY, format, args);
		if (count == -1)
		{
			Throw(0, "%s failed. Buffer length exceeded. Format String: %ls", __ROCOCO_FUNCTION__, format);
		}
		return count;
	}

	ROCOCO_API cstr FindSubstring(cr_substring bigText, const fstring& searchTerm)
	{
		if (bigText.Length() < searchTerm.length)
		{
			return nullptr;
		}

		cstr end = bigText.finish - searchTerm.length;

		for (cstr s = bigText.start; s <= end; s++)
		{
			if (memcmp(s, searchTerm, searchTerm.length) == 0)
			{
				return s;
			}
		}

		return nullptr;
	}

	ROCOCO_API cstr FindSubstring(cr_substring bigText, cr_substring searchTerm)
	{
		if (bigText.Length() < searchTerm.Length())
		{
			return nullptr;
		}

		cstr end = bigText.finish - searchTerm.Length();

		for (cstr s = bigText.start; s <= end; s++)
		{
			if (memcmp(s, searchTerm.start, searchTerm.Length()) == 0)
			{
				return s;
			}
		}

		return nullptr;
	}

	ROCOCO_API int ForEachOccurence(cr_substring text, cr_substring searchTerm, Rococo::Function<void(cr_substring match)> lambda)
	{
		int count = 0;

		Substring specimen = text;
		for (;;)
		{
			cstr nextOccurence = FindSubstring(specimen, searchTerm);
			if (!nextOccurence)
			{
				break;
			}

			count++;

			Substring result{ nextOccurence, nextOccurence + searchTerm.Length() };
			lambda(result);

			specimen = { result.finish, specimen.finish };
		}

		return count;
	}

	ROCOCO_API cstr FindSubstring(cstr bigText, cstr searchTerm)
	{
		return strstr(bigText, searchTerm);
	}

#ifdef ROCOCO_WIDECHAR_IS_WCHAR_T
	ROCOCO_API crwstr FindSubstring(const wchar_t* bigText, crwstr searchTerm)
	{
		return wcsstr(bigText, searchTerm);
	}
#endif

	ROCOCO_API cstr ForwardFind(char c, cr_substring text)
	{
		if (text.empty()) return nullptr;

		for (cstr p = text.start; p != text.finish; p++)
		{
			if (*p == c)
			{
				return p;
			}
		}

		return nullptr;
	}

	ROCOCO_API bool IsCapital(char c)
	{
		return c >= 'A' && c <= 'Z';
	}

	ROCOCO_API bool IsLowerCase(char c)
	{
		return c >= 'a' && c <= 'z';
	}

	ROCOCO_API bool IsAlphabetical(char c)
	{
		return IsCapital(c) || IsLowerCase(c);
	}

	ROCOCO_API bool IsNumeric(char c)
	{
		return c >= '0' && c <= '9';
	}

	ROCOCO_API bool IsAlphaNumeric(char c)
	{
		return IsAlphabetical(c) || IsNumeric(c);
	}

	ROCOCO_API bool IsAlphaNumeric(cr_substring s)
	{
		for (auto c : s)
		{
			if (!IsAlphaNumeric(c))
			{
				return false;
			}
		}

		return true;
	}

	ROCOCO_API int32 HashArg(int32 x)
	{
		struct ANON
		{
			static int robert_jenkins_32bit_hash(int32 key)
			{
				key = ~key + (key << 15); // key = (key << 15) - key - 1;
				key = key ^ (key >> 12);
				key = key + (key << 2);
				key = key ^ (key >> 4);
				key = key * 2057; // key = (key + (key << 3)) + (key << 11);
				key = key ^ (key >> 16);
				return key;
			}
		};

		return ANON::robert_jenkins_32bit_hash(x);
	}

	ROCOCO_API int32 HashArg(int64 x)
	{
		struct ANON
		{
			static int robert_jenkins_64bit_hash(int64 key)
			{
				key = (~key) + (key << 18); // key = (key << 18) - key - 1;
				key = key ^ (key >> 31);
				key = key * 21; // key = (key + (key << 2)) + (key << 4);
				key = key ^ (key >> 11);
				key = key + (key << 6);
				key = key ^ (key >> 22);
				return (int)key;
			}
		};

		return ANON::robert_jenkins_64bit_hash(x);
	}

	ROCOCO_API size_t HashArg(cstr s)
	{
		struct ANON
		{
			static size_t jenkins_one_at_a_time_hash(cstr s, size_t len)
			{
				size_t hash, i;
				for (hash = i = 0; i < len; ++i)
				{
					hash += s[i];
					hash += (hash << 10);
					hash ^= (hash >> 6);
				}
				hash += (hash << 3);
				hash ^= (hash >> 11);
				hash += (hash << 15);
				return hash;
			}
		};

		if (s == nullptr) return (size_t) -1LL;
		return ANON::jenkins_one_at_a_time_hash(s, StringLength(s));
	}

	ROCOCO_API int32 HashArg(cstr s, int64 length)
	{
		struct ANON
		{
			static int jenkins_one_at_a_time_hash(cstr s, int64 len)
			{
				int32 hash = 0;
				for (int64 i = 0; i < len; ++i)
				{
					hash += s[i];
					hash += (hash << 10);
					hash ^= (hash >> 6);
				}
				hash += (hash << 3);
				hash ^= (hash >> 11);
				hash += (hash << 15);
				return hash;
			}
		};

		if (s == nullptr) return -1LL;
		return ANON::jenkins_one_at_a_time_hash(s, length);
	}

	ROCOCO_API void Populate(cr_substring item, IStringPopulator& populator)
	{
		if (!item) return;

		auto len = Length(item);
		char* stackbuffer = (char*)alloca(len + 1);
		memcpy_s(stackbuffer, len + 1, item.start, len);
		stackbuffer[len] = 0;

		populator.Populate(stackbuffer);
	}

	ROCOCO_API cstr ReverseFind(char c, cr_substring token)
	{
		if (!token) return nullptr;

		for (cstr p = token.finish - 1; p >= token.start; p--)
		{
			if (*p == c)
			{
				return p;
			}
		}

		return nullptr;
	}

	ROCOCO_API cstr FindChar(cstr token, char c)
	{
		for (cstr p = token; *p != 0; p++)
		{
			if (*p == c)
			{
				return p;
			}
		}

		return nullptr;
	}

	ROCOCO_API cstr SkipBlankspace(cr_substring token)
	{
		for (cstr p = token.start; p != token.finish; p++)
		{
			if (*p > 32)
			{
				return p;
			}
		}

		return token.finish;
	}

	ROCOCO_API cstr SkipNotBlankspace(cr_substring token)
	{
		for (cstr p = token.start; p != token.finish; p++)
		{
			if (*p <= 32)
			{
				return p;
			}
		}

		return token.finish;
	}

	ROCOCO_API Substring RightOfFirstChar(char c, cr_substring token)
	{
		if (token)
		{
			for (cstr p = token.start; p < token.finish; ++p)
			{
				if (*p == c)
				{
					return Substring{ p + 1, token.finish };
				}
			}
		}

		return Substring::Null();
	}

	ROCOCO_API void Substring::CopyWithTruncate(char* buffer, size_t capacity) const
	{
		if (!buffer || capacity == 0)
		{
			return;
		}

		if (empty())
		{
			*buffer = 0;
			return;
		}

		size_t len = Length();
		size_t writeLength = min(len, capacity - 1);
		memcpy(buffer, start, writeLength);
		buffer[writeLength] = 0;
	}

	ROCOCO_API Substring Substring::ToSubstring(cstr text)
	{
		return text ? Substring{ text, strlen(text) + text } : Substring::Null();
	}

	// N.B sexy script language string length is int32 with max 2^31-1 chars
	ROCOCO_API int32 StringLength(const char* s)
	{
		enum { MAX_INT32 = 0x7FFFFFFF };
		size_t l = strlen(s);
		if (l > MAX_INT32)
		{
			Throw(0, "The string length exceeded INT_MAX characters");
		}

		return (int32)l;
	}

#ifdef ROCOCO_WIDECHAR_IS_WCHAR_T

	// N.B sexy script language string length is int32 with max 2^31-1 chars
	ROCOCO_API int32 StringLength(const wchar_t* s)
	{
		enum { MAX_INT32 = 0x7FFFFFFF };
		size_t l = wcslen(s);
		if (l > MAX_INT32)
		{
			Throw(0, "The string length exceeded INT_MAX characters");
		}

		return (int32)l;
	}

#endif

	ROCOCO_API int WriteToStandardOutput(const char* format, ...)
	{
		va_list args;
		va_start(args, format);

#ifdef _WIN32
		return vprintf_s(format, args);
#else
		return vprintf(format, args);
#endif
	}

#ifdef _WIN32
	ROCOCO_API void CopyString(char* dest, size_t capacity, const char* source)
	{
		strcpy_s(dest, capacity, source);
	}

	ROCOCO_API void CopyString(char* dest, size_t capacity, const char* source, size_t nChars)
	{
		strncpy_s(dest, capacity, source, nChars);
	}
#else
	ROCOCO_API void CopyString(char* dest, size_t capacity, const char* source)
	{
		strncpy(dest, source, capacity);
	}
#endif

#ifdef _WIN32
	ROCOCO_API void StringCat(char* buf, const char* source, int maxChars)
	{
		strcat_s(buf, maxChars, source);
	}

	ROCOCO_API void StringCat(wchar_t* buf, crwstr source, int maxChars)
	{
		wcscat_s(buf, maxChars, source);
	}
#else
	ROCOCO_API void StringCat(char* buf, const char* source, int maxChars)
	{
		strncat(buf, source, maxChars);
	}
#endif

	ROCOCO_API void Assign(U8FilePath& dest, const char* src)
	{
		Format(dest, "%s", src);
	}

	ROCOCO_API void Assign(U8FilePath& dest, crwstr wideSrc)
	{
		Format(dest, "%ls", wideSrc);
	}

	ROCOCO_API void Assign(WideFilePath& dest, const char* src)
	{
		Format(dest, _RW_TEXT("%hs"), src);
	}

	ROCOCO_API void Assign(U32FilePath& dest, const char32_t* wideSrc)
	{
		if (wideSrc == nullptr) wideSrc = U"<null>";

		auto* end = dest.buf + U32FilePath::CAPACITY;

		char32_t* target = dest.buf;
		for (const char32_t* src = wideSrc; *src != 0; ++src, ++target)
		{
			if (target == end)
			{
				goto error;
			}

			*target = *src;
		}

		if (target == end)
		{
			goto error;
		}

		*target = 0;
		return;
	error:
		Throw(0, "Failed to assign UTF-32 string - truncation. UTF-32 is used internally for path directories. Since truncation of  paths is a security problem the function must throw an exception");
	}

	ROCOCO_API size_t rlen(cstr s)
	{
		return strlen(s);
	}

	ROCOCO_API int SafeFormat(char* buffer, size_t capacity, const char* format, ...)
	{
		va_list args;
		va_start(args, format);
		return SafeVFormat(buffer, capacity, format, args);
	}

#ifdef ROCOCO_WIDECHAR_IS_WCHAR_T
	ROCOCO_API int SafeVFormat(wchar_t* buffer, size_t capacity, crwstr format, va_list args)
	{

		int count = _vsnwprintf_s(buffer, capacity, capacity, format, args);

		if (count >= capacity)
		{
			return -1;
		}

		return count;
	}
#endif

	ROCOCO_API int SafeFormat(ROCOCO_WIDECHAR* buffer, size_t capacity, crwstr format, ...)
	{
		va_list args;
		va_start(args, format);
		return SafeVFormat(buffer, capacity, format, args);
	}

	ROCOCO_API int SecureFormat(char* buffer, size_t capacity, const char* format, ...)
	{
		va_list args;
		va_start(args, format);
		int count = SafeVFormat(buffer, capacity, format, args);
		if (count == -1)
		{
			Throw(0, "SecureFormat failed. Buffer length exceeded. Format String: %s", format);
		}
		return count;
	}

	ROCOCO_API int SecureFormat(ROCOCO_WIDECHAR* buffer, size_t capacity, crwstr format, ...)
	{
		va_list args;
		va_start(args, format);
		int count = SafeVFormat(buffer, capacity, format, args);
		if (count == -1)
		{
			Throw(0, "SecureFormat failed. Buffer length exceeded. Format String: %ls", format);
		}
		return count;
	}

	ROCOCO_API int SafeVFormat(char* buffer, size_t capacity, const char* format, va_list args)
	{
		int count = vsnprintf(buffer, capacity, format, args);
		if (count >= capacity)
		{
			return -1;
		}

		return count;
	}

	ROCOCO_API int StrCmpN(cstr a, cstr b, size_t len)
	{
		return strncmp(a, b, len);
	}

	ROCOCO_API void SplitString(const char* text, size_t length, IStringPopulator& onSubString, cstr delimiter)
	{
		if (length == 0) length = rlen(text);
		size_t bytecount = sizeof(char) * (length + 1);
		char* buf = (char*)alloca(bytecount);
		memcpy_s(buf, bytecount, text, bytecount);
		buf[length] = 0;

		char* next_token = nullptr;
		char* token = strtok_s(buf, delimiter, &next_token);
		while (token != nullptr)
		{
			onSubString.Populate(token);
			token = strtok_s(nullptr, delimiter, &next_token);
		}
	}

	ROCOCO_API size_t CountSubStrings(cstr text, size_t length, cstr delimiter)
	{
		struct : IStringPopulator
		{
			size_t count;
			void Populate(cstr text) override
			{
				UNUSED(text);
				count++;
			}
		} cb;

		cb.count = 0;
		SplitString(text, length, cb, delimiter);
		return cb.count;
	}

	ROCOCO_API uint32 FastHash(cstr text)
	{
		if (text == nullptr) return 0;

		uint32 hash = 5381;

		while (true)
		{
			int c = *text;
			if (c == 0) break;
			hash = ((hash << 5) + hash) + c;
			text++;
		}

		return hash;
	}

	ROCOCO_API cstr GetFinalNull(cstr s)
	{
		cstr p = s;
		while (*p++ != 0);
		return p - 1;
	}

	ROCOCO_API crwstr GetFinalNull(crwstr s)
	{
		crwstr p = s;
		while (*p++ != 0);
		return p - 1;
	}

	ROCOCO_API cstr GetRightSubstringAfter(cstr s, char c)
	{
		cstr p = GetFinalNull(s);
		for (cstr q = p; q >= s; --q)
		{
			if (*q == c)
			{
				return q;
			}
		}

		return nullptr;
	}

	ROCOCO_API crwstr GetRightSubstringAfter(crwstr s, wchar_t c)
	{
		crwstr p = GetFinalNull(s);
		for (crwstr q = p; q >= s; --q)
		{
			if (*q == c)
			{
				return q;
			}
		}

		return nullptr;
	}

	ROCOCO_API cstr GetFileExtension(cstr s)
	{
		return GetRightSubstringAfter(s, '.');
	}

	ROCOCO_API crwstr GetFileExtension(crwstr s)
	{
		return GetRightSubstringAfter(s, L'.');
	}

	ROCOCO_API bool Eq(const char* a, const char* b)
	{
		return strcmp(a, b) == 0;
	}

#ifdef ROCOCO_WIDECHAR_IS_WCHAR_T
	ROCOCO_API bool Eq(crwstr a, crwstr b)
	{
		return wcscmp(a, b) == 0;
	}

	ROCOCO_API bool EqI(crwstr a, crwstr b)
	{
		return _wcsicmp(a, b) == 0;
	}

	ROCOCO_API bool StartsWith(crwstr bigString, crwstr prefix)
	{
		return wcsncmp(bigString, prefix, wcslen(prefix)) == 0;
	}

	ROCOCO_API bool EndsWith(crwstr bigString, crwstr suffix)
	{
		size_t len = wcslen(suffix);
		size_t lenBig = wcslen(bigString);
		crwstr t = bigString + lenBig - len;
		return Eq(suffix, t);
	}
#endif

#ifdef _WIN32
	ROCOCO_API bool EqI(const char* a, const char* b)
	{
		return _strcmpi(a, b) == 0;
	}
#else
	ROCOCO_API bool EqI(const char* a, const char* b)
	{
		return strcasecmp(a, b) == 0;
	}
#endif

	ROCOCO_API bool StartsWith(cstr bigString, cstr prefix)
	{
		return strncmp(bigString, prefix, strlen(prefix)) == 0;
	}

	ROCOCO_API bool EndsWith(cstr bigString, cstr suffix)
	{
		size_t len = strlen(suffix);
		size_t lenBig = strlen(bigString);
		const char* t = bigString + lenBig - len;
		return Eq(suffix, t);
	}

	ROCOCO_API bool EndsWithI(cstr bigString, cstr suffix)
	{
		size_t len = strlen(suffix);
		size_t lenBig = strlen(bigString);
		const char* t = bigString + lenBig - len;

#ifdef _WIN32
		return _strcmpi(suffix, t) == 0;
#else
		return strcasecmp(suffix, t) == 0;
#endif
	}

	ROCOCO_API StackStringBuilder::StackStringBuilder(char* _buffer, size_t _capacity) :
		buffer(_buffer), capacity(_capacity), length(0)
	{
		buffer[0] = 0;
	}

	ROCOCO_API StackStringBuilder::StackStringBuilder(char* _buffer, size_t _capacity, CursorState type) :
		buffer(_buffer), capacity(_capacity)
	{
		UNUSED(type);
		size_t ulen = strlen(buffer);
		if (ulen > 0x000000007FFFFFFF)
		{
			Throw(0, "Maximum string length exceeded");
		}
		length = (int32)ulen;
		if (length >= capacity)
		{
			length = (int32)(capacity - 1);
			buffer[capacity - 1] = 0;
		}
	}

	ROCOCO_API int32 StackStringBuilder::Length() const
	{
		return length;
	}

	ROCOCO_API StringBuilder& StackStringBuilder::AppendFormat(const char* format, ...)
	{
		size_t ulen = (size_t)length;
		if (ulen == capacity) return *this;

		va_list args;
		va_start(args, format);
		int charsCopied = SafeVFormat(buffer + ulen, capacity - ulen, format, args);
		if (charsCopied > 0)
		{
			length += charsCopied;
			if ((size_t)length > capacity)
			{
				if (Rococo::OS::IsDebugging())
				{
					// vsnprintf_s appears buggy
					Rococo::OS::TripDebugger();
				}
				Throw(0, "_vsnprintf_s appears to be bugged");
			}
		}
		else if (charsCopied < 0)
		{
			length = (int32)(capacity - 1);
			buffer[length] = 0;
		}

		return *this;
	}

	ROCOCO_API StringBuilder& StackStringBuilder::operator << (cstr text)
	{
		return AppendFormat("%s", text);
	}

	ROCOCO_API StringBuilder& StackStringBuilder::AppendChar(char c)
	{
		return AppendFormat("%c", c);
	}

	ROCOCO_API StringBuilder& StackStringBuilder::operator << (int32 value)
	{
		return AppendFormat("%d", value);
	}

	ROCOCO_API StringBuilder& StackStringBuilder::operator << (uint32 value)
	{
		return AppendFormat("%u", value);
	}

	ROCOCO_API StringBuilder& StackStringBuilder::operator << (int64 value)
	{
		return AppendFormat("%lld", value);
	}

	ROCOCO_API StringBuilder& StackStringBuilder::operator << (uint64 value)
	{
		return AppendFormat("%llu", value);
	}

	ROCOCO_API StringBuilder& StackStringBuilder::operator << (float value)
	{
		return AppendFormat("%f", value);
	}

	ROCOCO_API StringBuilder& StackStringBuilder::operator << (double value)
	{
		return AppendFormat("%lf", value);
	}

	ROCOCO_API void StackStringBuilder::Clear()
	{
		buffer[0] = 0;
		length = 0;
	}

	ROCOCO_API bool IsFQNamespace(cr_substring s)
	{
		if (s.empty())
		{
			return false;
		}

		if (s.start == nullptr)
		{
			return false;
		}

		if (s.Length() > MAX_FQ_NAME_LEN)
		{
			return false;
		}

		enum State
		{
			State_ExpectingSubspace,
			State_InSupspace,
		} state = State_ExpectingSubspace;

		for (auto* p = s.start; p != s.finish; p++)
		{
			if (state == State_ExpectingSubspace)
			{
				if ((*p >= 'A' && *p <= 'Z'))
				{
					// Dandy
					state = State_InSupspace;
				}
				else
				{
					return false;
				}
			}
			else // Insubspace
			{
				if ((*p >= 'a' && *p <= 'z') || (*p >= 'A' && *p <= 'Z') || (*p >= '0' && *p <= '9'))
				{
					// Dandy
				}
				else if (*p == '.')
				{
					state = State_ExpectingSubspace;
				}
				else
				{
					return false;
				}
			}
		}

		if (state == State_ExpectingSubspace)
		{
			return false;
		}

		return true;
	}

	ROCOCO_API void ValidateFQNamespace(cstr fqName)
	{
		if (fqName == nullptr)
		{
			Throw(0, "Error validating fully qualified namespace - nul");
		}

		if (*fqName == 0)
		{
			Throw(0, "Error validating fully qualified namespace - blank");
		}

		if (rlen(fqName) > MAX_FQ_NAME_LEN)
		{
			Throw(0, "Error validating fully qualified namespace - exceeded maximum of %d chars", MAX_FQ_NAME_LEN);
		}

		enum State
		{
			State_ExpectingSubspace,
			State_InSupspace,
		} state = State_ExpectingSubspace;

		for (auto* p = fqName; *p != 0; p++)
		{
			if (state == State_ExpectingSubspace)
			{
				if ((*p >= 'A' && *p <= 'Z'))
				{
					// Dandy
					state = State_InSupspace;
				}
				else
				{
					size_t pos = p - fqName;
					Throw(0, "Error validating fully qualified name at pos %llu - Capital letters A-Z only", pos);
				}
			}
			else // Insubspace
			{
				if ((*p >= 'a' && *p <= 'z') || (*p >= 'A' && *p <= 'Z') || (*p >= '0' && *p <= '9'))
				{
					// Dandy
				}
				else if (*p == '.')
				{
					state = State_ExpectingSubspace;
				}
				else
				{
					size_t pos = p - fqName;
					Throw(0, "Error validating fully qualified name - Characters must be in range 0-9 or a-z or A-Z at pos %llu. Use '.' to separate subspaces", pos);
				}
			}
		}

		if (state == State_ExpectingSubspace)
		{
			Throw(0, "Error validating fully qualified name - name must not terminate on a period '.'");
		}
	}

	ROCOCO_API void ValidateFQNameIdentifier(cstr fqName)
	{
		if (fqName == nullptr)
		{
			Throw(0, "Error validating fully qualified name - nul");
		}

		if (*fqName == 0)
		{
			Throw(0, "Error validating fully qualified name - blank");
		}

		if (rlen(fqName) > MAX_FQ_NAME_LEN)
		{
			Throw(0, "Error validating fully qualified name - exceeded maximum of %d chars", MAX_FQ_NAME_LEN);
		}

		enum State
		{
			State_ExpectingSubspace,
			State_InSupspace,
		} state = State_ExpectingSubspace;

		for (auto* p = fqName; *p != 0; p++)
		{
			if (state == State_ExpectingSubspace)
			{
				if ((*p >= 'a' && *p <= 'z') || (*p >= '0' && *p <= '9'))
				{
					// Dandy
					state = State_InSupspace;
				}
				else
				{
					Throw(0, "Error validating fully qualified name - Characters must be in range 0-9 or a-z");
				}
			}
			else // Insubspace
			{
				if ((*p >= 'a' && *p <= 'z') || (*p >= '0' && *p <= '9'))
				{
					// Dandy
				}
				else if (*p == '.')
				{
					state = State_ExpectingSubspace;
				}
				else
				{
					Throw(0, "Error validating fully qualified name - Characters must be in range 0-9 or a-z. Use '.' to separate subspaces");
				}
			}
		}

		if (state == State_ExpectingSubspace)
		{
			Throw(0, "Error validating fully qualified name - name must not terminate on a period '.'");
		}
	}

#ifndef _WIN32
# define _stricmp strcasecmp
# define _strnicmp strncasecmp
#endif

	ROCOCO_API int32 Compare(cstr a, cstr b) { return strcmp(a, b); }
	ROCOCO_API int32 CompareI(cstr a, cstr b) { return _stricmp(a, b); }
	ROCOCO_API int32 CompareI(cstr a, cstr b, size_t count) { return _strnicmp(a, b, count); }
	ROCOCO_API int32 Compare(cstr a, cstr b, size_t count) { return strncmp(a, b, count); }

#ifdef _WIN32
	ROCOCO_API int32 Compare(crwstr a, crwstr b) { return wcscmp(a, b); }
	ROCOCO_API int32 CompareI(crwstr a, crwstr b) { return _wcsicmp(a, b); }
	ROCOCO_API int32 CompareI(crwstr a, crwstr b, size_t count) { return _wcsnicmp(a, b, count); }
	ROCOCO_API int32 Compare(crwstr a, crwstr b, size_t count) { return wcsncmp(a, b, count); }
#endif

	ROCOCO_API const char* GetSubString(const char* s, const char* subString) { return strstr(s, subString); }

	ROCOCO_API IDynamicStringBuilder* CreateDynamicStringBuilder(size_t initialCapacity)
	{
		return new StringsAnon::DynamicStringBuilder(initialCapacity);
	}
} // Rococo

#ifdef _WIN32
#include "xxhash.hpp"

namespace Rococo::Strings
{
	ROCOCO_API uint64 XXHash64Arg(const void* buffer, size_t nBytesLength)
	{
		xxh::hash_t<64> hash = xxh::xxhash<64>(buffer, nBytesLength);
		return hash;
	}
}
#endif

namespace Rococo::Strings
{
	// This is very slow algorithm that requires deep stack recursion for even modest sized strings
	ROCOCO_API int LevenshteinDistance(cstr source, cstr target)
	{
		int lenSrc = StringLength(source);
		int lenTarget = StringLength(target);

		if (lenSrc == 0) { return lenTarget; }
		if (lenTarget == 0) { return lenSrc; }

		int distance = toupper(source[lenSrc - 1]) == toupper(target[lenTarget - 1]) ? 0 : 1;

		char* sourcePrefix = (char*)alloca(lenSrc);
		char* targetPrefix = (char*)alloca(lenTarget);

		memcpy(sourcePrefix, source, lenSrc - 1);
		memcpy(targetPrefix, target, lenTarget - 1);
		sourcePrefix[lenSrc - 1] = 0;
		targetPrefix[lenTarget - 1] = 0;

		return min(min(LevenshteinDistance(sourcePrefix, target) + 1,
			LevenshteinDistance(source, targetPrefix)) + 1,
			LevenshteinDistance(sourcePrefix, targetPrefix) + distance);
	}

	ROCOCO_API void ReplaceChar(char* buffer, size_t capacity, char target, char replacement)
	{
		for (char* c = buffer; c < buffer + capacity; c++)
		{
			if (*c == 0) return;

			if (*c == target)
			{
				*c = replacement;
			}
		}
	}

	ROCOCO_API bool StartsWith(cr_substring token, const fstring& prefix)
	{
		size_t len = token.finish - token.start;
		return prefix.length <= len && strncmp(prefix, token.start, prefix.length) == 0;
	}

	ROCOCO_API bool StartsWith(cstr token, cr_substring prefix)
	{
		size_t len = Length(prefix);
		return strncmp(token, prefix.start, len) == 0;
	}

	ROCOCO_API ptrdiff_t Length(cr_substring token)
	{
		return token.finish - token.start;
	}

	ROCOCO_API bool Substring::TryCopyWithoutTruncate(char* outputBuffer, size_t sizeofOutputBuffer) const
	{
		if (Length() >= (ptrdiff_t)sizeofOutputBuffer)
		{
			return false;
		}

		char* writePtr = outputBuffer;
		cstr readPtr = start;
		while (readPtr < finish)
		{
			*writePtr++ = *readPtr++;
		}

		*writePtr = 0;

		return true;
	}

	ROCOCO_API bool Eq(cr_substring b, cstr a)
	{
		cstr p = a;
		cstr q = b.start;
		for (; q != b.finish; ++q, ++p)
		{
			if (*p != *q) return false;
			if (*p == 0) return false;
		}

		return *p == 0;
	}

	ROCOCO_API bool Eq(const fstring& a, cr_substring b)
	{
		if (a.length != Length(b))
		{
			return false;
		}

		cstr p = a.buffer;
		cstr q = b.start;
		for (; q != b.finish; ++q, ++p)
		{
			if (*p != *q) return false;
		}

		return true;
	}

	ROCOCO_API bool Eq(cr_substring a, const fstring& b)
	{
		return Eq(b, a);
	}

	ROCOCO_API bool IsEmpty(cr_substring token)
	{
		return token.start == token.finish;
	}

	ROCOCO_API bool Eq(cr_substring a, cr_substring b)
	{
		auto lenA = Length(a);
		auto lenB = Length(b);

		if (lenA != lenB)
		{
			return false;
		}

		cstr p = a.start;
		cstr q = b.start;
		for (; p < a.finish; p++, q++)
		{
			if (*p != *q)
			{
				return false;
			}
		}

		return true;
	}
}

namespace Rococo::Reflection
{
	ROCOCO_API void ReflectStackFormat(Reflection::IReflectionVisitor& v, cstr name, const char* format, ...)
	{
		char text[1024];
		va_list args;
		va_start(args, format);
		SafeVFormat(text, sizeof(text), format, args);
		va_end(args);

		auto readOnly = Reflection::ReflectionMetaData::ReadOnly();
		v.Reflect(name, text, readOnly);
	}

	void EnterSection(Reflection::IReflectionVisitor& v, const char* format, ...)
	{
		char text[256];
		va_list args;
		va_start(args, format);
		SafeVFormat(text, sizeof(text), format, args);
		va_end(args);

		v.EnterSection(text);
	}

	void EnterElement(Reflection::IReflectionVisitor& v, const char* format, ...)
	{
		char text[256];
		va_list args;
		va_start(args, format);
		SafeVFormat(text, sizeof(text), format, args);
		va_end(args);

		v.EnterElement(text);
	}
}

namespace Rococo::Sex::Inference
{
	ROCOCO_API bool IsNotTokenChar(char c)
	{
		return !IsAlphaNumeric(c) && c != '.' && c != '#';
	}

	ROCOCO_API bool IsSexyKeyword(cr_substring candidate)
	{
		size_t len = Length(candidate);

		static std::vector<fstring> keywords
		{
			"method"_fstring, "function"_fstring, "class"_fstring, "struct"_fstring
		};

		for (auto keyword : keywords)
		{
			if (StartsWith(candidate, keyword))
			{
				if (len > keyword.length && IsNotTokenChar(candidate.start[keyword.length]))
				{
					// We found a keyword, but we do not need to parse it
					return true;
				}
			}
		}

		return false;
	}

	ROCOCO_API cstr GetFirstNonTokenPointer(cr_substring s)
	{
		if (!s) return nullptr;

		for (cstr p = s.start; p < s.finish; ++p)
		{
			if (!IsNotTokenChar(*p))
			{
				return p;
			}
		}

		return s.finish;
	}

	ROCOCO_API cstr GetFirstNonTokenPointerFromRight(cr_substring doc, cstr startPosition)
	{
		if (!startPosition || !doc) return nullptr;

		for (cstr p = startPosition - 1; p >= doc.start; p--)
		{
			if (IsNotTokenChar(*p))
			{
				return p;
			}
		}

		return nullptr;
	}

	ROCOCO_API cstr GetFirstNonTypeCharPointer(cr_substring s)
	{
		bool inDot = false;

		for (cstr p = s.start; p < s.finish; ++p)
		{
			if (!inDot)
			{
				if (*p == '.')
				{
					inDot = true;
					continue;
				}
			}

			if (IsAlphaNumeric(*p) || *p == '#')
			{
				if (inDot)
				{
					inDot = false;
				}

				continue;
			}

			return p;
		}

		return s.finish;
	}

	ROCOCO_API Substring GetFirstTokenFromLeft(cr_substring s)
	{
		return s ? Substring{ s.start, GetFirstNonTypeCharPointer(s) } : Substring::Null();
	}
} // Rococo::Strings

namespace Rococo
{
	ROCOCO_API fstring to_fstring(cstr const msg)
	{
		size_t len = rlen(msg);
		if (len >= (uint64) Limits::FSTRING_LENGTH_LIMIT)
		{
			Throw(0, "String too long to convert to fstring");
		}
		return{ msg, (int)len };
	}

	ROCOCO_API IExpandingBuffer* CreateExpandingBuffer(size_t initialCapacity)
	{
		return new StringsAnon::ExpandingBuffer(initialCapacity);
	}

	ROCOCO_API bool operator == (const fstring& a, const fstring& b)
	{
		return a.length == b.length && Strings::StrCmpN(a.buffer, b.buffer, a.length) == 0;
	}
} // Rococo

namespace Rococo::Strings::CLI
{
	ROCOCO_API void GetCommandLineArgument(const fstring& prefix, cstr commandLine, char* buffer, size_t capacity, cstr defaultString)
	{
		cstr directive = strstr(commandLine, prefix);
		if (directive == nullptr)
		{
			CopyString(buffer, capacity, defaultString);
			return;
		}

		bool isQuoted = directive[prefix.length] == '\"';

		Substring arg;
		if (isQuoted)
		{
			arg.start = directive + prefix.length + 1;
			cstr p = arg.start;
			for (;;)
			{
				if (*p == 0 || *p == '\"')
				{
					arg.finish = p;
					break;
				}

				p++;
			}
		}
		else
		{
			arg.start = directive + prefix.length;
			cstr p;
			for (p = arg.start; !isblank(*p) && *p != 0; p++)
			{
			}
			arg.finish = p + 1;
		}

		if (arg)
		{
			arg.CopyWithTruncate(buffer, capacity);
		}
		else
		{
			CopyString(buffer, capacity, defaultString);
		}
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.util/rococo.base.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#ifndef ROCOCO_API
# error "Define ROCOCO_API"
#endif

#define ROCOCO_ID_API ROCOCO_API
#include <rococo.debugging.h>

#define ROCOCO_USE_SAFE_V_FORMAT
#include <rococo.strings.h>

#include <stdio.h>
#include <list>
#include <vector>

#define BREAK_ON_THROW 1

using namespace Rococo::Strings;

namespace
{
   int breakFlags = 0;
}

#ifdef __APPLE__
namespace Rococo
{
	FILE* _wfopen(crwstr filename, crwstr mode);
}
#endif

#include <rococo.ids.h>
#include <rococo.os.h>
#include <rococo.time.h>
#include <atomic>
#include <ctype.h>

#ifdef _WIN32
# include <immintrin.h>
#endif

namespace Rococo
{
	ROCOCO_API bool IsPointerValid(const void* ptr)
	{
		return ptr != nullptr;
	}

	namespace Ids
	{
#ifdef _WIN32
		static std::atomic<int32> uniqueCounter = 0;

		ROCOCO_ID_API UniqueIdHolder MakeNewUniqueId()
		{
			UniqueIdHolder id;

			static uint64 userTimeHash = 0;

			if (userTimeHash == 0)
			{
				struct Username : IStringPopulator
				{
					uint64 hash = 0;

					void Populate(cstr text) override
					{
						char cipherCrud[256];
						SafeFormat(cipherCrud, "%s_%lld_%lld", text, (int64)Rococo::OS::GetCurrentThreadIdentifier(), (int64)Rococo::Time::UTCTime());
						hash = Strings::XXHash64Arg(cipherCrud, strlen(cipherCrud));
						memset(cipherCrud, 0, sizeof(cipherCrud));
					}
				} username;

				Rococo::OS::GetCurrentUserName(username);

				userTimeHash = username.hash;
			}

			static uint64 cpuHash = 0;
			if (cpuHash == 0)
			{
				if (0 == _rdrand64_step(&cpuHash))
				{
					cpuHash = Rococo::Time::TickCount() << 32;
				}

				cpuHash &= 0xFFFF'FFFF'0000'0000ULL;
			}

			int32 next = uniqueCounter++;
			int64 cpuHashAndCounter = cpuHash | (int64)next;

			id.iValues[0] = cpuHashAndCounter;
			id.iValues[1] = userTimeHash;

			return id;
		}
#endif
		struct MehGuid
		{
			// Example: 30dd879c-ee2f-11db-8314-0800200c9a66
			uint32 a;
			uint16 b;
			uint16 c;
			uint16 d;
			uint16 e;
			uint32 f;
		};

		union GuidAndUniqueId
		{
			GuidAndUniqueId()
			{
				memset(this, 0, sizeof(GuidAndUniqueId));
			}
			UniqueIdHolder id;
			MehGuid guid;
		};

		static_assert(sizeof(MehGuid) == sizeof(UniqueIdHolder));
		static_assert(sizeof(GuidAndUniqueId) == 16);

		ROCOCO_ID_API void ToGuidString(UniqueIdHolder id, OUT GuidString& guidString)
		{
			GuidAndUniqueId glue;
			glue.id = id;

			MehGuid g = glue.guid;

			// Example: 30dd879c-ee2f-11db-8314-0800200c9a66
			SafeFormat(guidString.buffer, "%8.8x-%4.4x-%4.4x-%4.4x-%4.4x%8.8x", g.a, g.b, g.c, g.d, g.e, g.f);
		}

		bool TryGrabHexToken(OUT uint32& value, cstr start, cstr end)
		{
			char buffer[16];

			char* dest = buffer;

			for (cstr s = start; s < end; s++)
			{
				char c = *s;
				if (!isalnum(c))
				{
					return false;
				}

				*dest++ = c;
			}

			*dest++ = 0;

			if (sscanf_s(buffer, "%x", &value) != 1)
			{
				return false;
			}

			return true;
		}

		ROCOCO_ID_API bool TryScanGuid(OUT UniqueIdHolder& id, cstr buffer)
		{
			if (strlen(buffer) != 36)
			{
				return false;
			}

			uint32 a; // the first 8 digits
			if (!TryGrabHexToken(a, buffer, buffer + 8))
			{
				return false;
			}

			uint32 b; // the next 4 digits
			if (!TryGrabHexToken(b, buffer + 9, buffer + 13))
			{
				return false;
			}

			uint32 c; // the next 4 digits
			if (!TryGrabHexToken(c, buffer + 14, buffer + 18))
			{
				return false;
			}

			uint32 d; // the next 4 digits
			if (!TryGrabHexToken(d, buffer + 19, buffer + 23))
			{
				return false;
			}

			uint32 e; // the first 4 digits of the final 12 digit block
			if (!TryGrabHexToken(e, buffer + 24, buffer + 28))
			{
				return false;
			}

			uint32 f; // The final 8 digits of the final 12 digit block
			if (!TryGrabHexToken(f, buffer + 28, buffer + 36))
			{
				return false;
			}

			GuidAndUniqueId glue;
			glue.guid.a = a;
			glue.guid.b = (uint16)b;
			glue.guid.c = (uint16)c;
			glue.guid.d = (uint16)d;
			glue.guid.e = (uint16)e;
			glue.guid.f = f;

			id = glue.id;

			return true;
		}
	}

	namespace IO
	{
		ROCOCO_API void ToU8(const U32FilePath& src, U8FilePath& dest)
		{
			char* q = dest.buf;
			const char32_t* p = src;

			while (*p != 0)
			{
				char32_t c = *p;

				if (c < 32 || c > 127)
				{
					Throw(0, "Cannot convert Unicode to ascii. Character value out of range at position #llu", p - src.buf);
				}
				else
				{
					*q = (char)*p;
				}

				p++, q++;
			}

			*q = 0;
		}

		ROCOCO_API void ToWide(const U32FilePath& src, WideFilePath& dest)
		{
			ROCOCO_WIDECHAR* q = dest.buf;
			const char32_t* p = src;

			while (*p != 0)
			{
				char32_t c = *p;

				if (c < 32 || c > 32767)
				{
					Throw(0, "Cannot convert Unicode to wide char. Character value out of range at position #llu", p - src.buf);
				}
				else
				{
					*q = (char)*p;
				}

				p++, q++;
			}

			*q = 0;
		}

		ROCOCO_API void PathFromAscii(cstr ascii_string, U32FilePath& path)
		{
			char32_t* q = path.buf;
			const char* p = ascii_string;

			while (*p != 0)
			{
				if (*p < 32 || *p > 127)
				{
					Throw(0, "Cannot convert 8-bit to char32_t. Character value out of range at position #llu", p - ascii_string);
				}
				*q++ = *p++;
			}

			*q = 0;
		}

		ROCOCO_API void PathFromWide(crwstr wide_string, U32FilePath& path)
		{
			char32_t* q = path.buf;
			crwstr p = wide_string;

			while (*p != 0)
			{
				if (*p < 32 || *p >= 32767)
				{
					Throw(0, "Cannot convert wide to char32_t. Character value out of range at position #llu", p - wide_string);
				}
				*q++ = *p++;
			}

			*q = 0;
		}
	}

	namespace OS
	{
		ROCOCO_API void SetBreakPoints(int flags)
		{
			static_assert(sizeof(int64) == 8, "Bad int64");
			static_assert(sizeof(int32) == 4, "Bad int32");
			static_assert(sizeof(int16) == 2, "Bad int16");
			static_assert(sizeof(int8) == 1, "Bad int8");
			breakFlags = flags;
		}

#ifdef BREAK_ON_THROW
		ROCOCO_API void BreakOnThrow(Flags::BreakFlag flag)
		{
			if ((breakFlags & flag) != 0 && Rococo::OS::IsDebugging())
			{
				TripDebugger();
			}
		}
#else
		void BreakOnThrow(BreakFlag flag) {}
#endif
	}
}

namespace Rococo
{
	using namespace Rococo::Debugging;

	struct RococoException : public IException, public IStackFrameEnumerator
	{
		char msg[2048];
		int32 errorCode;

		virtual ~RococoException()
		{

		}

		std::list<StackFrame> stackFrames;

		cstr Message() const override
		{
			return msg;
		}

		int32 ErrorCode() const override
		{
			return errorCode;
		}

		IStackFrameEnumerator* StackFrames() override
		{
			return this;
		}

		void FormatEachStackFrame(IStackFrameFormatter& formatter) override
		{
			for (auto& i : stackFrames)
			{
				formatter.Format(i);
			}
		}
	};

	ROCOCO_API void Throw(int32 errorCode, cstr format, ...)
	{
		va_list args;
		va_start(args, format);

		RococoException ex;

		SafeVFormat(ex.msg, sizeof(ex.msg), format, args);

		ex.errorCode = errorCode;

		OS::BreakOnThrow((OS::Flags::BreakFlag)0x7FFFFFFF);

		struct ANON : public IStackFrameFormatter
		{
			RococoException* ex;
			void Format(const StackFrame& sf)
			{
				ex->stackFrames.push_back(sf);
			}
		} formatter;
		formatter.ex = &ex;

		FormatStackFrames(formatter);

		throw ex;
	}

	ROCOCO_API void ThrowMissingResourceFile(ErrorCode /* code */, cstr description, cstr filename)
	{
		struct MissingResourceFile : IException
		{
			char message[1024] = { 0 };
			Rococo::ErrorCode code;

			cstr Message() const override
			{
				return message;
			}

			int ErrorCode() const override
			{
				return (int) code;
			}

			Debugging::IStackFrameEnumerator* StackFrames() override
			{
				return nullptr;
			}
		} err;

		SafeFormat(err.message, "%s: %s", description, filename);
		throw err;
	}

	ROCOCO_API void ThrowIllFormedSExpression(int32 displacement, cstr format, ...)
	{
		va_list args;
		va_start(args, format);

		RococoException ex;

		SafeVFormat(ex.msg, sizeof(ex.msg), format, args);

		ex.errorCode = displacement;

		OS::BreakOnThrow(OS::Flags::BreakFlag_IllFormed_SExpression);

		struct ANON : public IStackFrameFormatter
		{
			RococoException* ex;
			void Format(const StackFrame& sf)
			{
				ex->stackFrames.push_back(sf);
			}
		} formatter;
		formatter.ex = &ex;

		FormatStackFrames(formatter);

		throw ex;
	}

	namespace Maths::IEEE475
	{
		ROCOCO_API float BinaryToFloat(uint32 binaryRepresentation)
		{
			return *(float*)(&binaryRepresentation);
		}

		ROCOCO_API double BinaryToDouble(uint64 binaryRepresentation)
		{
			return *(double*)(&binaryRepresentation);
		}

		ROCOCO_API uint32 FloatToBinary(float f)
		{
			return *(uint32*)(&f);
		}

		ROCOCO_API uint64 DoubleToBinary(double d)
		{
			return *(uint64*)(&d);
		}
	}
} // Rococo

#include <string>
#include <list>
#include <allocators/rococo.allocator.malloc.h>

namespace Rococo::Debugging
{
	typedef std::basic_string<char, std::char_traits<char>, AllocatorWithMalloc<char>> mstring;

	std::list<mstring, AllocatorWithMalloc<mstring>> rollingLog;

	ROCOCO_API void AddCriticalLog(cstr message)
	{
		rollingLog.push_back(message);
		if (rollingLog.size() > 10)
		{
			rollingLog.pop_front();
		}
	}

	ROCOCO_API void ForEachCriticalLog(Strings::IStringPopulator& onMessage)
	{
		for (auto& i : rollingLog)
		{
			onMessage.Populate(i.c_str());
		}
	}

	ROCOCO_API void ValidateCriticalLog()
	{
		if (!rollingLog.empty())
		{
			Throw(0, "The critical log has something to add:\n");
		}
	}
}

namespace Rococo::Script
{
	ROCOCO_API void ThrowBadNativeArg(int index, cstr source, cstr message)
	{
		WriteToStandardOutput("Error %d in %s: %s\r\n", index, source, message);
		Throw(0, "Bad native argument: %s - %s", source, message);
	}
}

// Origin: D:/work/rococo/source/rococo/rococo.util/rococo.heap.string.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.types.h>

#define USE_HSTRING_HASH
#include <rococo.strings.h>
#include <rococo.map.h>
#include <rococo.hashtable.h>

#include <new>
#include <string.h>
#include <vector>
#include <stdlib.h>

using namespace Rococo::Strings;

namespace Rococo::Strings
{
	// Heap-allocated immutable string

	static HStringData nullData{ "", 0, 0 };

	struct DefaultAllocator: public IAllocator
	{
		virtual ~DefaultAllocator()
		{			
		}

		void AtRelease(void(*FN_AllocatorRelease)()) override
		{
			atexit(FN_AllocatorRelease);
		}

		void* Allocate(size_t capacity) override
		{
			return malloc(capacity);
		}

		void FreeData(void* data) override
		{
			free(data);
		}

		void* Reallocate(void* ptr, size_t capacity) override
		{
			return realloc(ptr, capacity);
		}

		size_t EvaluateHeapSize()
		{
			return 0;
		}
	};

	static DefaultAllocator defaultAllocator;
	static IAllocator* stringAllocator = &defaultAllocator;

	ROCOCO_API void SetStringAllocator(IAllocator* a)
	{
		stringAllocator = (a == nullptr) ? &defaultAllocator : a;
	}

	ROCOCO_API HString::HString(HString&& other) noexcept
	{
		data = other.data;
		other.data = &nullData;
	}

	ROCOCO_API HString::HString(cstr s)
	{
		if (s == nullptr)
		{
			data = &nullData;
			return;
		}

		size_t length = strlen(s);
		char* a = (char*) stringAllocator->Allocate(sizeof(HStringData) + length + 1);
		char* insertPos = a + sizeof(HStringData);
		memcpy(insertPos, s, length + 1);
		data = (HStringData*) a;
		data->currentBuffer = insertPos;
		data->length = length;
		data->refCount = 1;
	}

	ROCOCO_API HString::HString() : data{ &nullData }
	{
	}

	ROCOCO_API HString::HString(const HString& s)
	{
		if (this == &s)
		{
			Throw(0, "Error. Client of HString tried to initialize a string with itself.");
		}
		data = s.data;
		if (data->refCount > 0) data->refCount++;
	}

	ROCOCO_API void FreeHeapStringData(HStringData* data)
	{
		if (data->refCount > 0)
		{
			data->refCount--;
			if (data->refCount == 0)
			{
				stringAllocator->FreeData(data);
			}
		}
	}

	ROCOCO_API HString& HString::operator = (const HString& s)
	{
		// Edge case - source may currently match the target
		if (s.data != data)
		{
			// Assiging a thing to itself does nothing
			FreeHeapStringData(data);

			data = s.data;
			if (data != &nullData) data->refCount++;
		}

		return *this;
	}

	ROCOCO_API HString& HString::operator = (cstr s)
	{
		// Edge case - source may currently match the target
		if (s != data->currentBuffer)
		{
			FreeHeapStringData(data);
			data = &nullData;

			if (s != nullptr && *s != 0)
			{
				size_t length = strlen(s);
				char* a = (char*)stringAllocator->Allocate(sizeof(HStringData) + length + 1);
				char* insertPos = a + sizeof(HStringData);
				memcpy(insertPos, s, length + 1);
				data = (HStringData*)a;
				data->currentBuffer = insertPos;
				data->length = length;
				data->refCount = 1;
			}
		}

		return *this;
	}

	ROCOCO_API HString::~HString()
	{
		FreeHeapStringData(data);
	}

	ROCOCO_API const fstring HString::to_fstring() const
	{
		if (length() >= 0x80000000LL)
		{
			Throw(0, "HString to Fstring -> length was too large for size_t to int32 conversion");
		}

		return fstring{ c_str(), (int32)length() };
	}

	ROCOCO_API size_t FastHash(cstr text, size_t length)
	{
		int64 nBigWords = length >> 3;
		const int64 * src = (int64*)text;

		int64 sum = 0;
		for (int64 i = 0; i < nBigWords; ++i)
		{
			sum ^= *src++;
		}

		int64 remainder = length - (nBigWords << 3);

		const char* trailer = (char*)src;

		int64 finalWord = 0;

		char* dest = (char*)&finalWord;

		for (int64 i = 0; i < remainder; ++i)
		{
			*dest++ = *trailer++;
		}

		sum ^= finalWord;

		return (size_t)sum;
	}

	// size_t operator is used by std::unordered_map to generate a hash code.
	ROCOCO_API size_t HString::ComputeHash() const
	{
		return FastHash(data->currentBuffer, data->length);
	}
}

namespace ANON
{
	using namespace Rococo;
	IAllocator* moduleAllocator = &defaultAllocator;
}

#define _MODULE_ALLOCATOR_AVAILABLE
#include <allocators/rococo.allocator.via.interface.h>

namespace ANON
{
	using namespace Rococo;

	struct Value
	{
		void *data;
	};

	class KeyValuePair
	{
		Rococo::Strings::HString key;
		Value data;
	};

	// StringKey is intended for use as a hash table key type
	// It supports both stack strings and heap strings
	// As a proxy for a stack string it can be used to match a string without using heap resources.
	// As a proxy for heap strings it can be used to persist a key-value pair in the hash table.
	struct StringKey
	{
		Rococo::Strings::HString stringKey;
		const char* invariantString;
		size_t hashCode;

		StringKey(cstr stackString, int unused) : invariantString(stackString)
		{
			UNUSED(unused);
			hashCode = Rococo::Strings::FastHash(stackString, strlen(stackString));
		}

		StringKey() : invariantString(""), hashCode(0) {}
		StringKey(const StringKey& src) :
			stringKey(src.stringKey),
			invariantString(src.invariantString),
			hashCode(src.hashCode)
		{
		}

		StringKey& operator = (const StringKey& src)
		{
			stringKey = src.stringKey;
			invariantString = src.invariantString;
			hashCode = src.hashCode;
			return *this;
		}

		StringKey(cstr key) : stringKey(key)
		{
			invariantString = stringKey.c_str();
			hashCode = stringKey.ComputeHash();
		}

		StringKey(cstr key, size_t _hashCode) : stringKey(key)
		{
			invariantString = stringKey.c_str();
			hashCode = _hashCode;
		}

		static StringKey AsStackPointer(cstr key)
		{
			return StringKey(key, 0);
		}

		operator size_t() const
		{
			return hashCode;
		}

		operator cstr() const
		{
			return stringKey;
		}

		size_t length() const
		{
			return stringKey.length();
		}
	};

	bool operator == (const StringKey& a, const StringKey& b)
	{
		return a.hashCode == b.hashCode && strcmp(a.invariantString, b.invariantString) == 0;
	}

	bool operator != (const StringKey& a, const StringKey& b)
	{
		return !(a == b);
	}

	struct KeyValuePairAllocator
	{
		typedef Value value_type;
	};

	struct StringKeyHash
	{
		size_t operator () (const StringKey& k) const
		{
			return k;
		}
	};

	struct StringKeyEq
	{
		bool operator () (const StringKey& a, const StringKey& b) const
		{
			return a == b;
		}
	};

	class DictionaryImplementation : public Rococo::IDictionarySupervisor
	{
		std::unordered_map<StringKey, Value, StringKeyHash, StringKeyEq, AllocatorWithInterface<std::pair<const StringKey, Value>>> map;
	public:
		virtual ~DictionaryImplementation()
		{

		}

		bool TryAddUnique(cstr key, void* data) override
		{
			const auto& s = StringKey::AsStackPointer(key);
			auto i = map.find(s);
			if (i == map.end())
			{
				map[StringKey(key, (size_t)s)] = Value{ data };
				return true;
			}
			else
			{
				return false;
			}
		}

		void Enumerate(IDictionaryEnumerator& enumerator) override
		{
			auto i = map.begin();
			while (i != map.end())
			{
				auto control = enumerator.OnIteration(i->first, i->first.length(), i->second.data);

				switch (control)
				{
				case ENUM_CONTINUE:
					i++;
					break;
				case ENUM_BREAK:
					return;
				case ENUM_ERASE_AND_BREAK:
					map.erase(i);
					return;
				case ENUM_ERASE_AND_CONTINUE:
					i = map.erase(i);
					break;
				default:
					Throw(0, "DictionaryImplementation::Enumerate(...) -> unrecognized enum value %u", control);
					return;
				}
			}
		}

		bool TryDetach(cstr key, void*& data) override
		{
			auto i = map.find(StringKey::AsStackPointer(key));
			if (i != map.end())
			{
				data = i->second.data;
				map.erase(i);
				return true;
			}
			else
			{
				data = nullptr;
				return false;
			}
		}

		bool TryFind(cstr key, void*& data) override
		{
			auto i = map.find(StringKey::AsStackPointer(key));
			if (i != map.end())
			{
				data = i->second.data;
				return true;
			}
			else
			{
				data = nullptr;
				return false;
			}
		}

		bool TryFind(cstr key, const void*& data) const override
		{
			auto i = map.find(StringKey::AsStackPointer(key));
			if (i != map.end())
			{
				data = i->second.data;
				return true;
			}
			else
			{
				data = nullptr;
				return false;
			}
		}

		void Free() override
		{
			DictionaryImplementation::~DictionaryImplementation();
			ANON::moduleAllocator->FreeData(this);
		}
	};
}

namespace Rococo
{
	ROCOCO_API IDictionarySupervisor* CreateDictionaryImplementation()
	{
		void* buffer = ANON::moduleAllocator->Allocate(sizeof(ANON::DictionaryImplementation));
		ANON::DictionaryImplementation* x = new (buffer) ANON::DictionaryImplementation();
		Rococo::IDictionarySupervisor * retValue = static_cast<Rococo::IDictionarySupervisor * >(x);
		return retValue;
	}

	ROCOCO_API void AddUnique(IDictionary& d, cstr key, void* data)
	{
		if (!d.TryAddUnique(key, data))
		{
			Throw(0, "Error, could not add key to dictionary: %s\nIt already exists.\n", key);
		}
	}
}
// Origin: D:/work/rococo/source/rococo/rococo.util/rococo.allocators.cpp
// Copyright (c)2025 Mark Anthony Taylor. Email: mark.anthony.taylor@gmail.com. All rights reserved.
#include <rococo.types.h>
#include <rococo.allocators.h>
#include <rococo.os.h>
#include <rococo.debugging.h>

#include <rococo.strings.h>
#include <stdlib.h>
#include <vector>
#include <unordered_map>

#include <rococo.debugging.h>

#ifdef _WIN32
# include <rococo.os.win32.h>
#else
# include <stdio.h>

namespace
{
      using namespace Rococo;
      void OutputDebugStringA(cstr text)
      {
         printf("%s\n", text);
      }

      typedef void* HANDLE;

      HANDLE HeapCreate(int unused, size_t start, size_t capacity)
      {
         return (void*) 1;
      }

      int GetLastError()
      {
         return 0;
      }

      void HeapDestroy(HANDLE hHeap)
      {

      }

      void* HeapAlloc(HANDLE hHeap, int unused, size_t capacity)
      {
         return malloc(capacity);
      }

      void HeapFree(HANDLE hHeap, int unused, void* data)
      {
         free(data);
      }

      void* HeapReAlloc(HANDLE hHeap, int unused, void* old, size_t capacity)
      {
         return realloc(old, capacity);
      }

      enum {  HEAP_NO_SERIALIZE = 0 };
} // anon
#endif

#include <vector>
#include <algorithm>
#include <allocators/rococo.allocator.malloc.h>

using namespace Rococo;
using namespace Rococo::Strings;
using namespace Rococo::Debugging;

namespace Rococo::Memory::ANON
{
    class CheckedAllocator : public IAllocator
    {
        uint32 allocCount{ 0 };
        uint32 freeCount{ 0 };
        uint32 reallocCount{ 0 };

        std::vector<FN_AllocatorReleaseFunction, AllocatorWithMalloc<FN_AllocatorReleaseFunction>> atReleaseQueue;

    public:
        virtual ~CheckedAllocator()
        {
            for (auto fn : atReleaseQueue)
            {
                fn();
            }

            PrintD("\nCheckedAllocator: Allocs: %u, Frees: %u, Reallocs: %u\n\n", allocCount, freeCount, reallocCount);
        }

        void* Allocate(size_t capacity) override
        {
            allocCount++;
            void* buf = malloc(capacity);
            if (buf == nullptr)
            {
                throw std::bad_alloc();
            }

            return buf;
        }

        void FreeData(void* data) override
        {
            freeCount++;
            free(data);
        }

        void* Reallocate(void* ptr, size_t capacity) override
        {
            if (ptr == nullptr)
            {
                return Allocate(capacity);
            }
            reallocCount++;
            return realloc(ptr, capacity);
        }

        void AtRelease(FN_AllocatorReleaseFunction fn) override
        {
            auto i = std::find(atReleaseQueue.begin(), atReleaseQueue.end(), fn);
            if (i != atReleaseQueue.end())
            {
                atReleaseQueue.push_back(fn);
            }
        }

        size_t EvaluateHeapSize()
        {
            return 0;
        }
    } s_CheckedAllocator;


#ifdef _WIN32
    class BlockAllocator : public IAllocatorSupervisor
    {
        HANDLE hHeap{ nullptr };
        uint32 allocCount{ 0 };
        uint32 freeCount{ 0 };
        uint32 reallocCount{ 0 };
        size_t maxBytes;
        const char* const name;

        std::vector<FN_AllocatorReleaseFunction, AllocatorWithMalloc<FN_AllocatorReleaseFunction>> atReleaseQueue;
    public:
        BlockAllocator(size_t kilobytes, size_t _maxkilobytes, const char* const _name) : maxBytes(_maxkilobytes * 1024), name(_name)
        {
            hHeap = HeapCreate(0, kilobytes * 1024, maxBytes);
            if (hHeap == nullptr) Throw(GetLastError(), "Error allocating heap");
        }

        virtual ~BlockAllocator()
        {
            for (auto fn : atReleaseQueue)
            {
                fn();
            }

            size_t totalAllocation = EvaluateHeapSize();

            PrintD("\nBlockAllocator(%s) Allocs: %u, Frees: %u, Reallocs: %u. Heap size: %llu MB\n", name, allocCount, freeCount, reallocCount, totalAllocation / 1_megabytes);

            if (allocCount > freeCount)
            {
                PrintD("Memory leaked. %llu allocations were not freed\n\n", allocCount - freeCount);
            }

            HeapDestroy(hHeap);
        }

        void* Allocate(size_t capacity) override
        {
            if (capacity > 0x7FFF8 && maxBytes != 0)
            {
                char msg[256];
                SafeFormat(msg, "Heap max must be set to zero (growable heap for allocations this large) %llu", maxBytes);
                Rococo::Debugging::AddCriticalLog(msg);
                throw std::bad_alloc();
            }
            allocCount++;
            auto* ptr = HeapAlloc(hHeap, 0, capacity);
            if (ptr == nullptr) throw std::bad_alloc();
            return ptr;
        }

        void AtRelease(FN_AllocatorReleaseFunction fn) override
        {
            auto i = std::find(atReleaseQueue.begin(), atReleaseQueue.end(), fn);
            if (i == atReleaseQueue.end())
            {
                atReleaseQueue.push_back(fn);
            }
        }

        void FreeData(void* data) override
        {
            if (data)
            {
                freeCount++;
                if (data) HeapFree(hHeap, 0, data);
            }
        }

        void* Reallocate(void* old, size_t capacity) override
        {
            if (old == nullptr)
            {
                return Allocate(capacity);
            }
            reallocCount++;
            auto* ptr = HeapReAlloc(hHeap, 0, old, capacity);
            if (ptr == nullptr) Throw(0, "Insufficient memory in dedicated BlockAllocator heap for realloc operation");
            return ptr;
        }

        void Free() override
        {
            delete this;
        }

        size_t EvaluateHeapSize() override
        {
            PROCESS_HEAP_ENTRY entry;
            entry = { 0 };

            size_t totalAllocation = 0;
            while (HeapWalk(hHeap, &entry))
            {
                totalAllocation += (entry.cbData + entry.cbOverhead);
            }

            return totalAllocation;
        }
    };
#else
    class BlockAllocator : public IAllocatorSupervisor
    {
        const char* const name;

        std::vector<FN_AllocatorReleaseFunction, AllocatorWithMalloc<FN_AllocatorReleaseFunction>> atReleaseQueue;
    public:
        BlockAllocator(size_t /* kilobytes - unused */, size_t /* maxBytes - unused */, const char* const _name) : name(_name)
        {
        }

        virtual ~BlockAllocator()
        {
            for (auto fn : atReleaseQueue)
            {
                fn();
            }
        }

        void* Allocate(size_t capacity) override
        {
            return malloc(capacity);
        }

        void AtRelease(FN_AllocatorReleaseFunction fn) override
        {
            auto i = std::find(atReleaseQueue.begin(), atReleaseQueue.end(), fn);
            if (i == atReleaseQueue.end())
            {
                atReleaseQueue.push_back(fn);
            }
        }

        void FreeData(void* data) override
        {
            free(data);
        }

        void* Reallocate(void* old, size_t capacity) override
        {
            free(old);
            return malloc(capacity);
        }

        void Free() override
        {
            delete this;
        }

        size_t EvaluateHeapSize() override
        {
            return 0;
        }
    };
#endif

    struct TrackingData
    {
        size_t capacity;
        StackFrame::Address addr;
    };

    class TrackingAllocator : public IAllocatorSupervisor
    {
        cstr name;
        std::vector<FN_AllocatorReleaseFunction, AllocatorWithMalloc<FN_AllocatorReleaseFunction>> atReleaseQueue;
        std::unordered_map<void*, TrackingData> mapAllocToData;

        enum { TRACK_SIZE = 47, TRACK_DEPTH = 6 };
    public:
        TrackingAllocator(cstr _name) :name(_name)
        {
        }

        virtual ~TrackingAllocator()
        {
            for (auto fn : atReleaseQueue)
            {
                fn();
            }

            if (mapAllocToData.empty())
            {
                return;
            }

            PrintD("\nTracking Allocator(%s): Leaks detected: %llu buffers\n", name, mapAllocToData.size());

            int count = 0;
            for (auto& i : mapAllocToData)
            {
                PrintD("Leak #%d: %llu bytes\n", ++count, i.second.capacity);
            }

            if constexpr (TRACK_SIZE != 0)
            {
                for (auto& i : mapAllocToData)
                {
                    auto addr = i.second.addr;

                    char buffer[1024];
                    FormatStackFrame(buffer, sizeof(buffer), addr);

                    PrintD("Leak allocated at %s\n", buffer);
                }
            }
        }

        void* Allocate(size_t capacity) override
        {
            auto* buffer = malloc(capacity);

            if (!buffer)
            {
                throw std::bad_alloc();
            }

            if constexpr(TRACK_SIZE == 0)
            {

                TrackingData data{ capacity, 0 };
                mapAllocToData.insert(std::make_pair(buffer, data));
            }
            else if (capacity == TRACK_SIZE)
            {
                TrackingData data{ capacity, FormatStackFrame(nullptr, 0, TRACK_DEPTH) };
                mapAllocToData.insert(std::make_pair(buffer, data));
            }

            return buffer;
        }

        void AtRelease(FN_AllocatorReleaseFunction fn) override
        {
            auto i = std::find(atReleaseQueue.begin(), atReleaseQueue.end(), fn);
            if (i == atReleaseQueue.end())
            {
                atReleaseQueue.push_back(fn);
            }
        }

        void FreeData(void* data) override
        {
            if (data)
            {
                mapAllocToData.erase(data);
            }

            free(data);
        }

        void* Reallocate(void* old, size_t capacity) override
        {
            UNUSED(old);
            return Allocate(capacity);
        }

        void Free() override
        {
            delete this;
        }

        size_t EvaluateHeapSize()
        {
            return 0;
        }
    };

    struct FreeListAllocator :IFreeListAllocatorSupervisor
    {
        size_t elementSize;

        std::vector<void*> freeList;

        FreeListAllocator(size_t varElementSize) : elementSize(varElementSize)
        {

        }

        virtual ~FreeListAllocator()
        {
            for (auto* v : freeList)
            {
                FreeBuffer(v);
            }
        }

        void* AllocateBuffer() override
        {
            if (freeList.empty())
            {
                return new char[elementSize];
            }
            else
            {
                void* lastElement = freeList.back();
                freeList.pop_back();
                return lastElement;
            }
        }

        void FreeBuffer(void* buffer) override
        {
            char* cBuffer = (char*)buffer;
            delete[] cBuffer;
        }

        void ReclaimBuffer(void* buffer) override
        {
            if (buffer == nullptr) return;
            freeList.push_back(buffer);
        }

        void Free() override
        {
            delete this;
        }
    };
}

namespace Rococo::Memory
{
    ROCOCO_API IFreeListAllocatorSupervisor* CreateFreeListAllocator(size_t elementSize)
    {
        return new ANON::FreeListAllocator(elementSize);
    }

    ROCOCO_API IAllocator& CheckedAllocator()
    {
        return ANON::s_CheckedAllocator;
    }

    ROCOCO_API IAllocatorSupervisor* CreateTrackingAllocator(size_t kilobytes, size_t maxkilobytes, const char* const name)
    {
        UNUSED(kilobytes);
        UNUSED(maxkilobytes);
        return new ANON::TrackingAllocator(name);
    }

    ROCOCO_API IAllocatorSupervisor* CreateBlockAllocator(size_t kilobytes, size_t maxkilobytes, const char* const name)
    {
        return new ANON::BlockAllocator(kilobytes, maxkilobytes, name);
    }

    ROCOCO_API void* AlignedAlloc(size_t nBytes, int32 alignment, void* allocatorFunction(size_t))
    {
        void* p1; // original block
        void** p2; // aligned block
        int offset = alignment - 1 + sizeof(void*);
        if ((p1 = (void*)allocatorFunction(nBytes + offset)) == NULL)
        {
            return nullptr;
        }
        p2 = (void**)(((size_t)(p1)+offset) & ~(alignment - 1));
        p2[-1] = p1;
        return p2;
    };

    ROCOCO_API void AlignedFree(void* buffer, void deleteFunction(void*))
    {
        if (buffer) deleteFunction(((void**)buffer)[-1]);
    };

    ROCOCO_API void Log(const AllocatorMetrics& stats, cstr name, cstr intro, int (*FN_LOG)(cstr format, ...))
    {
        FN_LOG("%s:  %s\n", name, intro);
        FN_LOG(" Total allocation size: %llu KB\n", stats.totalAllocationSize / 1024);
        FN_LOG(" Total allocations: %llu\n", stats.totalAllocations);
        FN_LOG(" Useful frees: %llu\n", stats.usefulFrees);
        FN_LOG(" Total frees: %llu\n", stats.totalFrees);
        FN_LOG(" Blank frees: %llu\n\n", stats.blankFrees);
    }

    AllocatorFunctions defaultAllocatorFunctions{ 0 };

    void* DefaultMallocWithBadAllocException(size_t nBytes)
    {
        void* buffer = malloc(nBytes);
        if (buffer != nullptr)
        {
            return buffer;
        }
        
        throw std::bad_alloc();
    }

    ROCOCO_API bool SetDefaultAllocators(AllocatorFunctions allocatorFunctions)
    {
        if (defaultAllocatorFunctions.Allocate != nullptr)
        {
            return false; // Allocator have already been initialized
        }

        defaultAllocatorFunctions = allocatorFunctions;
        return true;
    }

    ROCOCO_API AllocatorFunctions GetDefaultAllocators()
    {
        if (defaultAllocatorFunctions.Allocate == nullptr)
        {
            defaultAllocatorFunctions.Allocate = DefaultMallocWithBadAllocException;
            defaultAllocatorFunctions.Free = free;
            defaultAllocatorFunctions.Name = "Rococo::Utils defaults(malloc++/free)";
        }

        return defaultAllocatorFunctions;
    }

    AllocatorLogFlags logFlags = { 0 };

    ROCOCO_API void SetAllocatorLogFlags(AllocatorLogFlags flags)
    {
        logFlags = flags;
    }

    ROCOCO_API AllocatorLogFlags GetAllocatorLogFlags()
    {
        return logFlags;
    }

    ROCOCO_API void* rococo_aligned_malloc(size_t alignment, size_t bufferLength)
    {
        void* raw = malloc(bufferLength + alignment - 1 + sizeof(void*));
        if (!raw) return NULL;

        void** aligned = (void**)(((uintptr_t)raw + sizeof(void*) + alignment - 1) & ~(alignment - 1));
        aligned[-1] = raw; // Store original pointer for freeing
        return aligned;
    }

    ROCOCO_API void rococo_aligned_free(void* pData)
    {
        free(((void**)pData)[-1]);
    }
} // Rococo::Memory
// Origin: D:/work/rococo/source/rococo/rococo.util/rococo.throw.cr_sex.cpp
/*
	Sexy Scripting Language - Copright(c)2013. Mark Anthony Taylor. All rights reserved.

	http://www.sexiestengine.com

	Email: mark.anthony.taylor@gmail.com

	The Sexy copyright holder is Mark Anthony Taylor, the English author of 'Lazy Bloke Ghosts of Parliament', 'Lazy Bloke in the 35th Century', 'King of the Republic', 'Origin of the Species' 
	and 'Society of Demons.'

	1. This software is open-source. It can be freely copied, distributed, compiled and the compilation executed.
	
	1.a Modification of the software is not allowed where such modifcations fail to include this exact comment header in each source file, or alter, reduce or extend the Sexy language.
	The purpose of this limitation is to prevent different incompatible versions of the Sexy language emerging. 

	1.b You are allowed to fix bugs and implement performance improvements providing you inform Sexy's copyright owner via email. Such changes may then be incorporated in
	later versions of Sexy without compromising Sexy's copyright license.
	
	2. You are not permitted to copyright derivative versions of the source code. You are free to compile the code into binary libraries and include the binaries in a commercial application. 

	3. THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM �AS IS� WITHOUT
	WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY
	AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

	4. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR
	DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED
	INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
	SUCH DAMAGES.

	5. Any program that distributes this software in source or binary form must include an obvious credit to the the language, its copyright holder, and the language homepage. This must be the case in its
	principal credit screen and its principal readme file.
*/

#include <sexy.types.h>
#define ROCOCO_USE_SAFE_V_FORMAT
#include <sexy.strings.h>
#include "Sexy.S-Parser.h"
#include <sexy.compiler.public.h>
#include <sexy.debug.types.h>
#include <sexy.vm.h>
#include <sexy.vm.cpu.h>
#include <sexy.script.h>

#include <stdarg.h>
#include <stdio.h>
#include <string.h>

#ifndef _Printf_format_string_
# define _Printf_format_string_
#endif

using namespace Rococo;
using namespace Rococo::Sex;
using namespace Rococo::Compiler;
using namespace Rococo::Strings;

namespace Rococo
{
	namespace OS
	{
		ROCOCO_API void BreakOnThrow(Flags::BreakFlag flag);
	}

	namespace Sex
	{
		ROCOCO_API cstr ReadUntil(const Vec2i& pos, const ISourceCode& src)
		{
			Vec2i origin = src.Origin();

			int X = origin.x, Y = origin.y;

			int i;
			for (i = 0; i < src.SourceLength(); ++i)
			{
				if (Y > pos.y) break;
				else if (pos.y == Y && X == pos.x)
				{
					break;
				}
				char c = src.SourceStart()[i];
				switch (c)
				{
				case '\r':
					break;
				case '\n':
					Y++;
					X = origin.x;
					break;
				default:
					X++;
				}
			}

			return src.SourceStart() + i;
		}

		ROCOCO_API  void GetSpecimen(char specimen[64], const ISExpression& e)
		{
			auto& tree = e.Tree();
			cstr startPos = ReadUntil(e.Start(), tree.Source());
			cstr endPos = ReadUntil(e.End(), tree.Source());

			if (endPos - startPos >= 64)
			{
				SafeFormat(specimen, 64, ("%.28s... ...%.28s"), startPos, endPos - 28);
			}
			else
			{
				if (endPos > startPos)
				{
					memcpy_s(specimen, 63 * sizeof(char), startPos, (endPos - startPos) * sizeof(char));
				}
				specimen[endPos - startPos] = 0;
			}
		}

		ROCOCO_API ParseException::ParseException() : startPos{ 0,0 }, endPos{ 0, 0 }
		{
			srcName[0] = 0;
			errText[0] = 0;
			specimenText[0] = 0;
			source = nullptr;
		}

		ROCOCO_API ParseException::ParseException(const Vec2i& start, const Vec2i& end, cstr name, cstr err, cstr specimen, const ISExpression* _source) :
			startPos(start),
			endPos(end),
			source(_source)
		{
			CopyString(srcName, ParseException::MAX_SRC_LEN, name);
			CopyString(errText, ParseException::MAX_ERR_LEN, err);
			CopyString(specimenText, ParseException::MAX_SPECIMEN_LEN, specimen);
		}

		ROCOCO_API void Throw(ParseException& ex)
		{
			OS::BreakOnThrow(OS::Flags::BreakFlag_SS);
			throw ex;
		}

		ROCOCO_API const ISExpression* GetFirstAtomic(cr_sex s)
		{
			if (IsAtomic(s))
			{
				return &s;
			}

			for (int i = 0; i < s.NumberOfElements(); ++i)
			{
				auto* theAtomic = GetFirstAtomic(s[i]);
				if (theAtomic)
				{
					return theAtomic;
				}
			}

			return nullptr;
		}

		ROCOCO_API void Throw(cr_sex e, _Printf_format_string_ cstr format, ...)
		{
			va_list args;
			va_start(args, format);

			char message[4096];
			int len = SafeVFormat(message, sizeof(message), format, args);

			StackStringBuilder sb(message + len, sizeof(message) - len);

			auto* pOriginal = e.GetOriginal();
			if (pOriginal != nullptr)
			{
				cr_sex s = *pOriginal;

				const ISExpression* theAtomic = GetFirstAtomic(e);
				if (theAtomic)
				{
					sb.AppendFormat("(near %s)", theAtomic->c_str());
				}

				char specimen[64];
				GetSpecimen(specimen, s);
				ParseException ex(s.Start(), s.End(), s.Tree().Source().Name(), message, specimen, &s);
				Throw(ex);
			}
			else
			{
				char specimen[64];
				GetSpecimen(specimen, e);
				ParseException ex(e.Start(), e.End(), e.Tree().Source().Name(), message, specimen, &e);
				Throw(ex);
			}
		}
	}
}
#ifdef _WIN32
# pragma warning(default: 4458)
# pragma warning(default: 4265)
#else
# pragma clang diagnostic pop
#endif

